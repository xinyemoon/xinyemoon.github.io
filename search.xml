<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaSE</title>
      <link href="/2022/10/12/JavaSE/"/>
      <url>/2022/10/12/JavaSE/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="标柱注释"><a href="#标柱注释" class="headerlink" title="标柱注释"></a>标柱注释</h3><ul><li><p>单独重点加粗</p></li><li><p>单独背诵下划线</p></li><li><p>⭐️重点</p></li><li><p>⭐️⭐️重点的重点</p></li></ul><h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><ul><li>需求——&gt;知识点——&gt;基本原理语法——&gt;快速入门(基本程序)——&gt;技术细节</li></ul><h2 id="java概述"><a href="#java概述" class="headerlink" title="java概述"></a>java概述</h2><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul><li><p>\t  一个制表位，实现对齐功能</p></li><li><p>\n  换行</p></li><li><p>\  一个\</p></li><li><p>&quot;  一个”</p></li><li><p>\r  回车</p></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>单行注释:  &#x2F;&#x2F;注释文字 </p></li><li><p>多行注释:  &#x2F;<em>注释文字</em>&#x2F; </p></li><li><p>文档注释:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author</span><br><span class="line">* @version</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="代码规范⭐️"><a href="#代码规范⭐️" class="headerlink" title="代码规范⭐️"></a>代码规范⭐️</h3><ul><li><p>类、方法的注释，要以 javadoc 的方式来写</p></li><li><p>注释详细，着重告述读者为什么这样写，如何修改，注意什么问题等</p></li><li><p>使用tab、shift + tab</p></li><li><p>运算符和 &#x3D; 两边习惯性各加一个空格</p></li><li><p>源文件使用utf-8编码</p></li><li><p>行宽度不要超过80字符</p></li><li><p>代码编写次行风格和行尾风格</p></li></ul><h3 id="JDK-JRE⭐️"><a href="#JDK-JRE⭐️" class="headerlink" title="JDK  JRE⭐️"></a>JDK  JRE⭐️</h3><ul><li><p>JDK(java开发工具包)</p></li><li><p>JDK &#x3D; JRE + java开发工具</p></li><li><p>JRE &#x3D; JVM + Java的核心类库</p></li><li><p>JVM(java虚拟机)</p></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>变量相当于内存中一个<strong>数据存储空间</strong>的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量(值)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">double score = 88;</span><br><span class="line">char gender = &#x27;男&#x27;；</span><br><span class="line">String name = &quot;jack&quot;;</span><br></pre></td></tr></table></figure><h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>变量表示内存中的一个存储区域[不同的变量，类型不同，占用的空间大小不同]</p></li><li><p>该区域有自己的名称[变量名]和类型[数据类型]</p></li><li><p><strong>变量必须先声明，后使用</strong>，即有顺序</p></li><li><p>该区域的数据可以在同一类型范围内不断变化</p></li><li><p><strong>变量在同一个作用域内不能重名</strong></p></li><li><p>变量&#x3D;变量名＋值+数据类型</p></li></ul><h3 id="数据类型⭐️"><a href="#数据类型⭐️" class="headerlink" title="数据类型⭐️"></a>数据类型⭐️</h3><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061033405.png"></p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li><p>整数类型  (byte [1]  short[2]  int[4]  long [8]) </p><ul><li><p>Java的整型常量(具体值)<strong>默认为 int 型</strong>，声明 long 型常量须后加‘l’或‘L’</p></li><li><p>java程序中变量常声明为 int 型，除非不足以表示大数，才使用long</p></li><li><p>bit: 计算机中的最小存储单位</p></li><li><p>byte:t算机中基本存储单元，1byte &#x3D; 8 bit</p></li></ul></li><li><p>浮点(小数)类型 (float [4]  double [8]) </p><ul><li><p>浮点数 &#x3D; 符号位 + 指数位 + 尾数位</p></li><li><p>尾部可能丢失，造成精度损失</p></li><li><p>Java 的浮点型常量(具体值)默认为 double 型，声明 float 型常量，须后加’f’或’F’</p></li><li><p>十进制数形式：5.12   512.0f   .512(必须有小数点) 科学计数法形式：5.12e2   5.12E-2</p></li><li><p>通常情况<strong>默认使用 double</strong></p></li></ul></li><li><p>字符型(Char[2]) </p><ul><li><p>使用单引号表示</p></li><li><p>Java 中还允许使用转义字符来将其后的字符转变为特殊字符型常量</p></li><li><p>char 的<strong>本质是一个整数</strong>，输出时是 unicode 码对应字符</p></li><li><p>char 类可以进行运算</p></li></ul></li><li><p>布尔型(boolean[1]) </p><ul><li><p>boolean 类型数据只允许取值 true 和 false，无null</p></li><li><p>boolean类型占1个字节</p></li><li><p><strong>不可以用0或非0的整数代替 false 和 true</strong>，与C语言不同</p></li></ul></li></ul><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul><li>略</li></ul><h3 id="基本数据类型转化"><a href="#基本数据类型转化" class="headerlink" title="基本数据类型转化"></a>基本数据类型转化</h3><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>基本介绍</p><ul><li>java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int = &#x27;c&#x27;;</span><br><span class="line">double d = 80</span><br></pre></td></tr></table></figure><p> 转换规则 </p><ul><li>char &lt; int &lt; long &lt; float &lt; double</li><li>byte &lt; short &lt; int &lt; long &lt; float &lt; double</li></ul><p> 注意事项和细节 </p><ul><li><p>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，再进行计算</p></li><li><p>我们把精度(容量)大的数据类型赋值给精度(容量)小 的数据类型时，就会报错，反之就会进行自动类型转换。</p></li><li><p><strong>byte   short   char   之间不会相互转换</strong></p></li><li><p><strong>byte   short   char   计算是首先转换为int类型</strong></p></li><li><p>boolean 不参与转换</p></li><li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p></li></ul><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p> 基本介绍</p><ul><li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符()，但可能造成精度降低或溢出，格外要注意</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = (int)8.8;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p> 注意事项和细节 </p><ul><li><p>当数据从精度  大——＞小，就需要使用到强制转换 </p></li><li><p>强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int y = int(10*3.5+6*1.5)</span><br></pre></td></tr></table></figure><ul><li>char 类型可以保存 int 的常量值，但不能保存 int 的变量值，需要强转</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int m = 100;</span><br><span class="line">char c2 = m;//false</span><br><span class="line">char c3 = (char)m;//ture</span><br></pre></td></tr></table></figure><ul><li><strong>byte   short   char   类型在进行运算时，当做int类型处理</strong></li></ul><h3 id="基本数据类型和-String-类型转换"><a href="#基本数据类型和-String-类型转换" class="headerlink" title="基本数据类型和 String 类型转换"></a>基本数据类型和 String 类型转换</h3><h4 id="基本类型转-String-类型"><a href="#基本类型转-String-类型" class="headerlink" title="基本类型转 String 类型"></a>基本类型转 String 类型</h4><ul><li>语法<ul><li>将基本类型的值  + ” “</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n1 = 1</span><br><span class="line">float n2 = 1.1f;</span><br><span class="line">double n3 = 3.4;</span><br><span class="line">boolean b1 = true;</span><br><span class="line">String s1 = n1 + &quot;&quot;;</span><br><span class="line">String s2 = n2 + &quot;&quot;;</span><br><span class="line">String s3 = n3 + &quot;&quot;;</span><br><span class="line">String s4 = b1 + &quot;&quot;;</span><br></pre></td></tr></table></figure><h4 id="String-类型转基本数据类型"><a href="#String-类型转基本数据类型" class="headerlink" title="String 类型转基本数据类型"></a>String 类型转基本数据类型</h4><ul><li>语法<ul><li>通过基本类型的包装类调用 parseXX 方法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s5 = &quot;123&quot;;</span><br><span class="line">int num1 = InterInt.parseInt(s5);</span><br><span class="line">int num2 = InterInt.parseDouble(s5);</span><br><span class="line">int num3 = InterInt.parseFloat(s5);</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p> 基本介绍</p><ul><li>算术运算符是对数值类型的变量进行运算的</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061101711.png" alt="image-20221006110137548"></p><h4 id="号使用"><a href="#号使用" class="headerlink" title="+号使用"></a>+号使用</h4><ul><li><p>当左右两边都是数值型时，则做加法运算 </p></li><li><p>当左右两边有一方为<strong>字符串</strong>，则做<strong>拼接运算</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out，println(100 + 98): //198</span><br><span class="line">System.out.println(&quot;100&quot; + 98);//10098</span><br><span class="line">System.out.println(100 + 3 +&quot;hello&quot;);//103hello</span><br><span class="line">System.out.println(&quot;hello&quot;+ 100 +3);//hello1003</span><br></pre></td></tr></table></figure><h4 id="号使用-1"><a href="#号使用-1" class="headerlink" title="++号使用"></a>++号使用</h4><ul><li>前＋＋和后＋+都完全等价子 i&#x3D;i+1;作为表达式使用 </li><li>前++：++先自增后赋值 </li><li>后++：i++先赋值后自增</li></ul><h4 id="号使用-2"><a href="#号使用-2" class="headerlink" title="%号使用"></a>%号使用</h4><ul><li>a % b 当a是<strong>小数</strong>时，公式 &#x3D; a - (int)a &#x2F; b * b</li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li>关系运算符的结果都是 boolean 型</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061103576.png" alt="image-20221006110306463"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p> 基本介绍</p><ul><li>用于连接多个条件(多个关系表达式)，结果是 boolean</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061103114.png" alt="image-20221006110354000"></p><h4 id="amp-amp-和-amp-基本规则"><a href="#amp-amp-和-amp-基本规则" class="headerlink" title="&amp;&amp;和&amp;基本规则"></a>&amp;&amp;和&amp;基本规则</h4><p> &amp;&amp; 短路与</p><ul><li>如果第一个条件为 false ，后面的条件不再判断</li></ul><p> &amp; 逻辑与</p><ul><li>如果第一个条件为 false ，后面的条件仍然判断</li></ul><h4 id="和-基本规则"><a href="#和-基本规则" class="headerlink" title="||和|基本规则"></a>||和|基本规则</h4><p> || 短路或</p><ul><li>如果第一个条件为 true，则第二个条件不会判断，结果为true</li></ul><p> |  逻辑或</p><ul><li>不管第一个条件是否为true，第二个条件都要判断</li></ul><h4 id="逻辑异或"><a href="#逻辑异或" class="headerlink" title="^逻辑异或"></a>^逻辑异或</h4><ul><li>当 a 和 b 不同时，则结果为 true，否则为 false</li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p> 基本介绍</p><ul><li>赋值运算符就是将某个运算后的值，赋给指定的变量</li></ul><p> 注意事项和细节</p><ul><li><p>运算顺序从右往左 </p></li><li><p>赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值 </p></li><li><p>复合赋值： a  x&#x3D;  b  等于  a  &#x3D;  a  x  b </p></li><li><p><strong>复合赋值运算符会进行类型转换</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b = 3;</span><br><span class="line">b += 2;  //等价于 b = (byte)(b + 2)</span><br><span class="line">b++;  //等价于 b = (byte)(b + 1)</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p> 基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">条件表达式？表达式1：表达式2;</span><br><span class="line"></span><br><span class="line">int a = 10;</span><br><span class="line">int b = 99;</span><br><span class="line">int result = a&gt;b ? a++:b--;</span><br></pre></td></tr></table></figure><p>运算规则</p><ul><li><p>如果条件表达式为 true，运算后的结果是表达式1;</p></li><li><p>如果条件表达式为 false，运算后的结果是表达式2;</p></li></ul><p>注意事项和细节</p><ul><li>表达式1和表达式2要为可以赋给接收变量的类型(或可以自动转换)</li><li><!--三元运算符是一个整体，精度保持一致--></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int c = a &gt; b ? int(1.1) : int(3.4);</span><br></pre></td></tr></table></figure><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>优先级</p><ul><li>() {} , 等</li><li>单目运算符 ++ –</li><li>算术运算符</li><li>位移运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>三元运算符</li><li>赋值运算符</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061116765.png" alt="image-20221006111623543"></p><h3 id="标识符的命名规则和规范"><a href="#标识符的命名规则和规范" class="headerlink" title="标识符的命名规则和规范"></a>标识符的命名规则和规范</h3><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li><p>由26个英文字母大小写，0~9，或＄组成</p></li><li><p><strong>数字不可开头</strong></p></li><li><p>不可以使用关键字和保留宇，但能包含关键字和保留字</p></li><li><p>Java中严格区分大小写，长度无限制</p></li><li><p>标识符不能包含空格</p></li></ul><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><ul><li><p>包名</p><ul><li>多单词组成时所有字母都小写：aaa.bbb.ccc</li></ul></li><li><p>类名、接口名</p><ul><li>多单词组成时，所有单词的首字母大写：XxxYyyZzz</li></ul></li><li><p>变量名、方法名</p><ul><li>多单词组成时，第一个单词首字母小写，第二个单河开始每个单词首字母大写：xxxYyyzzz</li></ul></li><li><p>常量名</p><ul><li>所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li></ul></li></ul><h3 id="关键字、保留字"><a href="#关键字、保留字" class="headerlink" title="关键字、保留字"></a>关键字、保留字</h3><ul><li>被Java语言赋子了特殊含义，用做专门用途的字符串(单词)特点：关键字中所有字母都为小写</li></ul><p>关键字基本介绍</p><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061118450.png" alt="image-20221006111853324"></p><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071949470.png" alt="image-20221006111919985"></p><p>保留字基本介绍</p><ul><li>现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留宇 byValue、cast、future、 generic、 inner、 operator、outer、rest、var、goto、const</li></ul><h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><p>基本介绍</p><ul><li>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取lnput.java，需要一个扫描器(对象)，就是 Scanner</li></ul><p>步骤</p><ul><li><p>导入该类的包，java.util.*</p></li><li><p>创建该类的对象(声明变量)</p></li><li><p>调用里面的功能</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class hello &#123;</span><br><span class="line">    public static void main(String []args) &#123;</span><br><span class="line">        Scanner myScanner = new Scanner(System.in);//System.in 代表使用键盘输入</span><br><span class="line">        System.out.println(&quot;请输入名字&quot;);</span><br><span class="line">        String name = myScanner.next();</span><br><span class="line">        System.out.println(&quot;请输入年龄&quot;);</span><br><span class="line">        int age = myScanner.nextInt();</span><br><span class="line">        System.out.println(&quot;名字=&quot;+name+ &quot;\t&quot; +&quot;年龄=&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进制⭐️"><a href="#进制⭐️" class="headerlink" title="进制⭐️"></a>进制⭐️</h3><ul><li><p>二进制：0.1，满2进1，以 0b 或 0B 开头</p></li><li><p>十进制：0-9，满10进1</p></li><li><p>八进制：0-7，满8进1，以数字0开头表示</p></li><li><p>十六进制：0-9及A(10)-F(15)，满16进1.以 Ox 或 0x 开头表示，此处的 A-F 不区分大小写</p></li></ul><p>3.9.1 其他转十进制</p><ul><li>从最低位开始，将每个位上的数提取出来，乘以(几进制)的(位数-1)次方例：0b01011 &#x3D; 1 * 2^(1-1) + 1 * 2^(2-1) + 0 * 2^(3-1) + 1 * 2^(4-1) &#x3D; 1 + 2 + 0 + 8 &#x3D;11</li></ul><p>3.9.2 十进制转其他</p><ul><li>将该数不断除(几进制)，直到商为0，每步余数倒写</li></ul><p>3.9.3 二进制转八&#x2F;十六</p><ul><li><p>从低位开始，每三位一组，转成对应八进制</p></li><li><p>从低位开始，每四位一组，转成对应十六进制</p></li></ul><p>3.9.4 八&#x2F;十六进制转二</p><ul><li><p>将八进制的每一位，转成对应的一个三位的二进制数</p></li><li><p>将十六进制的每一位，转成对应的一个四位的二进制数</p></li></ul><h3 id="原码-反码-补码⭐️⭐️"><a href="#原码-反码-补码⭐️⭐️" class="headerlink" title="原码 反码 补码⭐️⭐️"></a>原码 反码 补码⭐️⭐️</h3><p>运算规则</p><ul><li><p>二进制的最高位是符号位：0表示正数，1表示负数</p></li><li><p>正数的原码、反码、补码都一样(三码合一)</p></li><li><p>负数的反码 &#x3D; 它的原码符号位不变，其它位取反</p></li><li><p>负数的补码 &#x3D; 它的反码+1，负数的反码 &#x3D; 负数的补码 - 1</p></li><li><p>0的反码，补码都是0</p></li><li><p>java中的数都是有符号的</p></li><li><p>计算机运算的时候，都是以补码的方式来运算的</p></li><li><p>看运算结果的时候，要看他的原码</p></li></ul><h3 id="位运算符⭐️"><a href="#位运算符⭐️" class="headerlink" title="位运算符⭐️"></a>位运算符⭐️</h3><p>位运算符</p><ul><li><p>按位与 &amp;</p></li><li><p>按位或 | </p></li><li><p>按位异或 ^ </p></li><li><p>按位取反 ~ </p></li><li><p>算数右移 &gt;&gt; 低位溢出，符号位不变，并用符号位补溢出的高位(本质&#x2F;2)</p></li><li><p>算数左移 &lt;&lt; 符号位不变，低位补0(本质*2)</p></li><li><p>逻辑右移 &gt;&gt;&gt; 低位溢出，高位补0</p></li></ul><p>位运算过程：</p><ul><li><p>用原码得到补码</p></li><li><p>用补码进行相关逻辑运算</p></li><li><p>运算完毕将补码转换成原码</p></li></ul><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>基本介绍</p><p>程序在运行的时候, 对代码执行的先后顺序, 称作程序的执行结构. 在Java中, 程序的执行结构分为三种:</p><ul><li><p>顺序结构:</p><ul><li>代码从上往下逐行执行, 是程序执行的基本结构</li></ul></li><li><p>分支结构</p><ul><li>代码执行到某一个节点遇到多个分支, 选择其中的一个分支执行, 其他的分支都不执行</li></ul></li><li><p>循环结构</p><ul><li>某一个代码段需要重复的执行</li></ul></li><li><p>程序默认采用的是顺序结构, 我们也可以通过一些语句来修改程序的执行结构, 这样的语句叫做<strong>流程控制语句</strong>, 按照修改的执行结构不同, 可以分为 <strong>分支流程控制</strong> 和 <strong>循环流程控制</strong></p></li></ul><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a><strong>顺序结构</strong></h3><ul><li>略</li></ul><h3 id="分支控制-if-else-switch"><a href="#分支控制-if-else-switch" class="headerlink" title="分支控制(if  else  switch)"></a>分支控制(if  else  switch)</h3><h4 id="单分支"><a href="#单分支" class="headerlink" title="单分支"></a>单分支</h4><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(条件表达式)&#123;</span><br><span class="line">  执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项和细节</p><ul><li><p>当条件表达式为 ture 时，就会执行 {} 的代码。如果为 false，就不执行</p></li><li><p>如果 {} 中只有一条语句，则可以不用 {} ，建议写上 {}</p></li></ul><h4 id="双分支"><a href="#双分支" class="headerlink" title="双分支"></a>双分支</h4><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(条件表达式)&#123;</span><br><span class="line">  执行代码块;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  执行代码块2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项和细节</p><ul><li><p>当条件表达式成立，即执行代码块1，否则执行代码块2</p></li><li><p>如果执行代码块有一条语句，则 {} 可以省略，否则，不能省略</p></li></ul><h4 id="多分支"><a href="#多分支" class="headerlink" title="多分支"></a>多分支</h4><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(条件表达式)&#123;</span><br><span class="line">  执行代码块;</span><br><span class="line">&#125;else if(条件表达式2)&#123;</span><br><span class="line">  执行代码块2;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else&#123;</span><br><span class="line">  执行代码块n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项和细节</p><ul><li><p>当条件表达式1成立时，即执行代码块1</p></li><li><p>如果表达式1不成立，才去判断表达式2是否成立</p></li><li><p>如果表达式2成立，就执行代码块2</p></li><li><p>以此类推，如果所有的表达式都不成立则执行 else 的代码块</p></li><li><p>多分支可以没有 else</p></li></ul><h4 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h4><p>基本介绍</p><ul><li>在一个分支结构中又完整的嵌套了另个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外层分支</li></ul><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if()&#123;</span><br><span class="line">  if()&#123;</span><br><span class="line">    //if-else</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    //if-else</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch分支结构"><a href="#switch分支结构" class="headerlink" title="switch分支结构"></a>switch分支结构</h4><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">    case 常量1:</span><br><span class="line">      语句块1;</span><br><span class="line">      break;</span><br><span class="line">    </span><br><span class="line">    case 常量2:</span><br><span class="line">      语句块2;</span><br><span class="line">      break;</span><br><span class="line">    </span><br><span class="line">    default:</span><br><span class="line">      语句块;</span><br><span class="line">      break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li><p>switch 关键字，表示 swtich 分支</p></li><li><p>表达式对应一个值</p></li><li><p>case 常量1:</p><ul><li>当表达式的值等于常量1，就执行语句块1</li></ul></li><li><p>break</p><ul><li>表示退出 swtich</li></ul></li><li><p>如果和 case 常量1匹配，就执行语句块1，如果没有匹配，就继续匹配 case 常量2</p></li><li><p>如果一个都没有匹配上，执行 default</p></li></ul><p>注意事项和细节</p><ul><li><p>表达式数据类型，应和 case 后的常量类型一致，或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是 int</p></li><li><p>switch (表达式)中表达式的返回值必须是：(byte,short.int,char,enum,String)</p></li><li><p>case 子句中的值必须是常量,而不能是变量</p></li><li><p>default 子句是可选的，当没有匹配的 case 时，执行 default</p></li><li><p>break 语句跳出 switch 语句块，如果没有 break，程序会执行到结尾</p></li></ul><h3 id="循环控制-for-while-do-while-⭐️"><a href="#循环控制-for-while-do-while-⭐️" class="headerlink" title="循环控制(for  while  do while)⭐️"></a>循环控制(for  while  do while)⭐️</h3><h4 id="for循环控制"><a href="#for循环控制" class="headerlink" title="for循环控制"></a>for循环控制</h4><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(循环变量初始化;循环条件;循环变量迭代)&#123;</span><br><span class="line">  循环操作语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li><p>四要素：</p><ul><li>循环变量初始化</li><li>循环条件</li><li>循环操作</li><li>循环变量迭代</li></ul></li><li><p>循环操作，这里可以有多条语句，也就是我们要循环执行的代码</p></li><li><p>如果 循环操作(语句) 只有一条语句，可以省路 {}，建议不要省略</p></li></ul><p>注意事项和细节</p><ul><li><p>循环条件是返回一个布尔值的表达式</p></li><li><p><strong>for(;循环判断条件;)中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略</strong></p></li><li><p>循环初始值可以有多条初始化语句，但要求类型一样，井且中间用逗号隔开</p></li><li><p>循环变量迭代也司以有名条变量迭代语句，中间用逗号隔开</p></li></ul><h4 id="while循环控制"><a href="#while循环控制" class="headerlink" title="while循环控制"></a>while循环控制</h4><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环变量初始化;</span><br><span class="line">while(循环条件)&#123;</span><br><span class="line">  循环体;</span><br><span class="line">  循环变量迭代;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li><p>四要素</p><ul><li><p>循环变量初始化</p></li><li><p>循环条件</p></li><li><p>循环操作</p></li><li><p>循环变量迭代</p></li></ul></li><li><p>四要素位置不同</p></li></ul><p>注意事项和细节</p><ul><li><p>循环条件是返回一个布尔值的表达式</p></li><li><p>while循环是先判断在执行语句</p></li></ul><h4 id="do-while循环控制"><a href="#do-while循环控制" class="headerlink" title="do while循环控制"></a>do while循环控制</h4><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环变量初始化;</span><br><span class="line">do&#123;</span><br><span class="line">  循环体;</span><br><span class="line">  循环变量迭代;</span><br><span class="line">&#125;while(循环条件);</span><br></pre></td></tr></table></figure><p>说明</p><ul><li><p>四要素</p><ul><li><p>循环变量初始化</p></li><li><p>循环条件</p></li><li><p>循环操作</p></li><li><p>循环变量迭代</p></li></ul></li><li><p>四要素位置不同</p></li></ul><p>注意事项和细节</p><ul><li><p>循环条件是返回一个布尔值的表达式</p></li><li><p><strong>先执行在判断，至少执行一次</strong></p></li></ul><h4 id="多重循环控制"><a href="#多重循环控制" class="headerlink" title="多重循环控制"></a>多重循环控制</h4><p>介绍</p><ul><li><p>将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do.while 均可以作为外层循环和内层循环</p></li><li><p>嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内层盾环，才可结束外层的当次循环，开始下一次的循环</p></li><li><p>设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行m*n 次</p></li></ul><h3 id="跳转控制break"><a href="#跳转控制break" class="headerlink" title="跳转控制break"></a>跳转控制break</h3><p>基本介绍</p><ul><li>break语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for,while,do while]</li></ul><p>注意事项和细节</p><ul><li><p>break 语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块 </p></li><li><p>标签的基本使用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label1:&#123;......</span><br><span class="line">  label2:&#123;</span><br><span class="line">  break label1;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳转控制continue"><a href="#跳转控制continue" class="headerlink" title="跳转控制continue"></a>跳转控制continue</h3><p>基本介绍</p><ul><li><p>continue 语句用于结束本次循环，继续执行下一次循环 </p></li><li><p>continue 语句出现在多层嵌套的福环语句体中时，可以通过标签指明要跳过的是哪一层循环</p></li></ul><p>注意事项和细节</p><ul><li><p>continue 语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块 </p></li><li><p>标签的基本使用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label1:&#123;......</span><br><span class="line">  label2:&#123;</span><br><span class="line">  continue label1;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳转控制return"><a href="#跳转控制return" class="headerlink" title="跳转控制return"></a>跳转控制return</h3><p>基本介绍</p><ul><li>return 使用在方法，表示跳出所在的方法</li></ul><h2 id="数组、排序、查找"><a href="#数组、排序、查找" class="headerlink" title="数组、排序、查找"></a>数组、排序、查找</h2><h3 id="数组⭐️"><a href="#数组⭐️" class="headerlink" title="数组⭐️"></a>数组⭐️</h3><h4 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h4><ul><li><p><strong>数组是一个容器，是一个用来存储指定数据类型的多个元素的容器</strong></p><ul><li>这多个变量的数据类型要一致</li></ul></li><li><p>数组是一个定长容器，一旦实例化完成，长度不能修改</p></li></ul><h4 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h4><ul><li><p>数组长度: 指的就是这个容器的容量, 表示这个数组中能存储多少个数据</p></li><li><p>元素:  指的就是数组中存储的数据</p></li><li><p>下标: 某一个元素在数组中的一个位置索引</p></li><li><p>遍历数组: 依次获取到数组中的每一个元素</p></li></ul><h4 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h4><p>格式</p><ul><li><p>数据类型[] 数组名;</p></li><li><p>数据类型 数组名[];</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:int[] a; 定义一个int类型的数组，数组名是a</span><br><span class="line">B:int a[]; 定义一个int类型的变量，变量名是a数组</span><br></pre></td></tr></table></figure><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><ul><li><p><strong>Java中的数组必须先初始化,然后才能使用</strong></p></li><li><p>所谓初始化</p><ul><li>就是为数组中的数组元素<strong>分配内存空间</strong>，并为每个数组元素赋值</li></ul></li></ul><h5 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h5><ul><li>初始化时只指定数组长度，由系统为数组分配初始值</li></ul><p>注意：</p><ul><li>数组元素的类型是基本类型中的整数类型（byte、short、int 和 long），则数组元素的初始化值是 0</li><li>数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的初始化值是 0.0</li><li>数组元素的类型是基本类型中的字符类型（char），则数组元素的初始化值是‘\u0000’</li><li>数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的初始化值是 false</li><li>数组元素的类型是引用类型（类、接口和数组），则数组元素的初始化值是 null</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//格式：数据类型[] 数组名 = new 数据类型[数组长度];</span><br><span class="line">//数组长度其实就是数组中元素的个数。</span><br><span class="line">//定义了一个int类型的数组，这个数组中可以存放3个int类型的值。</span><br><span class="line">//数组元素的初始化值为0</span><br><span class="line">int[] arr = new int[3];</span><br><span class="line">for (int elem : arr) &#123;</span><br><span class="line">    System.out.println(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h5><ul><li>初始化时指定数组元素，即给出初始化值，由系统决定长度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] number = new int[]&#123;1, 2, 3, 5, 8&#125;;</span><br><span class="line">int[] number = &#123;1,2,3,5,8&#125;;</span><br></pre></td></tr></table></figure><h4 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h4><ul><li>数组名<code>[下标/索引]</code>，下标从0开始</li></ul><h4 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</li><li>使用数组的步骤<ul><li>声明数组并开辟空间 </li><li>给数组各个元素赋值 </li><li>使用数组</li></ul></li><li>数组的下标是从0开始的</li><li>数组下标必须在指定范围内使用，否则报：下标越界异常</li><li>数组属引用类型，数组型数据是对象(object)</li></ul><h4 id="数组赋值机制"><a href="#数组赋值机制" class="headerlink" title="数组赋值机制"></a>数组赋值机制</h4><ul><li>数组在<strong>默认情況下是引用传递</strong>，赋的值是地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr1 = &#123;1,2,3&#125;;</span><br><span class="line">int arr2 = arr1;</span><br><span class="line">arr2[0] = 10;  //arr1[0]=10</span><br></pre></td></tr></table></figure><h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a><strong>数组拷贝</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] arr1 = &#123;1,2,3&#125;;</span><br><span class="line">int[] arr2 = new int[arr1.length];</span><br><span class="line">for (int i = 0;i &lt; arr1.length;i++)&#123;</span><br><span class="line">  arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a><strong>数组反转</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayReverse01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;11,22,33,44,55,66&#125;;</span><br><span class="line">        int temp = 0,len = arr.length;</span><br><span class="line">        for (int i = 0;i &lt; len/2;i++)&#123;</span><br><span class="line">            temp = arr[len-1-i];</span><br><span class="line">            arr[len-1-i] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+&quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>逆序赋值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayReverse02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr1 = &#123;11,22,33,44,55,66&#125;;</span><br><span class="line">        int[] arr2 = new int[arr1.length];</span><br><span class="line">        int len = arr1.length;</span><br><span class="line">        for(int i = len-1;i &gt;= 0;i--)&#123;</span><br><span class="line">            arr2[len-i-1] = arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr1 = arr2;//arr1指向arr2数据空间，此时arr原来的数据空间没有变量引用，会被当作垃圾销毁</span><br><span class="line">        for(int i = 0;i &lt; arr1.length;i++) &#123;</span><br><span class="line">            System.out.print(arr1[i] + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组添加"><a href="#数组添加" class="headerlink" title="数组添加"></a><strong>数组添加</strong></h4><h5 id="静态添加"><a href="#静态添加" class="headerlink" title="静态添加"></a><strong>静态添加</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayAdd01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1,2,3&#125;;</span><br><span class="line">        int[] arr2 = new int[arr.length+1];</span><br><span class="line">        for (int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            arr2[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr2[arr2.length-1] = 4;</span><br><span class="line">        arr = arr2;</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态添加"><a href="#动态添加" class="headerlink" title="动态添加"></a><strong>动态添加</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayAdd02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner myScanner = new Scanner(System.in);</span><br><span class="line">        double[] arr = &#123;1,2,3&#125;;</span><br><span class="line">        do&#123;</span><br><span class="line">            double[] arr2 = new double[arr.length+1];</span><br><span class="line">            for (int i = 0;i &lt; arr.length;i++) &#123;</span><br><span class="line">                arr2[i] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;请输入添加的元素&quot;);</span><br><span class="line">            double addNum = myScanner.nextInt();</span><br><span class="line">            arr2[arr2.length-1] = addNum;</span><br><span class="line">            arr = arr2;</span><br><span class="line">            for(int i = 0;i &lt; arr.length;i++) &#123;</span><br><span class="line">                System.out.print(arr[i] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;是否继续添加 y/n&quot;);</span><br><span class="line">            char key = myScanner.next().charAt(0);</span><br><span class="line">            if(key == &#x27;n&#x27;)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while (true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态删减"><a href="#动态删减" class="headerlink" title="动态删减"></a><strong>动态删减</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayReduce01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner myScanner = new Scanner(System.in);</span><br><span class="line">        int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            int[] arr2 = new int[arr.length-1];</span><br><span class="line">            for (int i = 0;i &lt; arr2.length;i++)&#123;</span><br><span class="line">                arr2[i] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            arr = arr2;</span><br><span class="line">            for(int i = 0;i &lt; arr.length;i++) &#123;</span><br><span class="line">                System.out.print(arr[i] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;请输入是否删除最后一个数字 yes/no&quot;);</span><br><span class="line">            char key = myScanner.next().charAt(0);</span><br><span class="line">            if(key == &#x27;n&#x27;)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>一维数组构成了二维数组</li></ul><h4 id="二维数组遍历"><a href="#二维数组遍历" class="headerlink" title="二维数组遍历"></a><strong>二维数组遍历</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TwoDimensionalArrary &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;</span><br><span class="line">        for (int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            for (int j = 0;j &lt; arr[i].length;j++)&#123;</span><br><span class="line">                System.out.print(arr[i][j]+&quot;\t&quot;);</span><br><span class="line">            &#125;System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维数组内存图"><a href="#二维数组内存图" class="headerlink" title="二维数组内存图"></a><strong>二维数组内存图</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071949421.png" alt="image-20221006142936848"></p><h4 id="注意事项和细节-2"><a href="#注意事项和细节-2" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>二维数组元素个数：arr.length</li><li>取出一维元素需要遍历两次</li><li>访问第(i+1)个一维数组的第(j+1)个值  arr [i] [j]</li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a><strong>使用方式</strong></h4><h5 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a><strong>动态初始化</strong></h5><ul><li>类型 数组名[] [] &#x3D; new 类型 [大小] [大小]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TwoDimensionalArrary02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[][] = new int[2][3];</span><br><span class="line">        arr[1][1] = 8;</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            for(int j = 0;j &lt; arr[i].length;j++)&#123;</span><br><span class="line">                System.out.print(arr[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态初始化2"><a href="#动态初始化2" class="headerlink" title="动态初始化2"></a><strong>动态初始化2</strong></h5><p>先声明数组</p><ul><li>数据类型 数组名[] []; 例：<ul><li>int a[] [];</li></ul></li></ul><p>再创建数组</p><ul><li>数组名 &#x3D; new 数据类型[大小] [大小]; 例：<ul><li>a &#x3D; new int [2] [3];</li></ul></li></ul><h5 id="动态初始化-列数不确定"><a href="#动态初始化-列数不确定" class="headerlink" title="动态初始化-列数不确定"></a><strong>动态初始化-列数不确定</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TwoDimensionalArrary03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[][] arr = new int[3][];//创建二维数组，只确定一维数组的个数，一维数组开没有开数据空间</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            arr[i] = new int[i+1];//给一维数组开空间</span><br><span class="line">            for (int j = 0; j &lt; arr[i].length;j++)&#123;</span><br><span class="line">                arr[i][j] = i+1;//给每一个一维数组元素赋值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            for (int j = 0; j &lt; arr[i].length;j++)&#123;</span><br><span class="line">                System.out.print(arr[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果：1 22 333</span><br></pre></td></tr></table></figure><h5 id="静态初始化-1"><a href="#静态初始化-1" class="headerlink" title="静态初始化"></a>静态初始化</h5><p>语法</p><ul><li>类型 数组名<code>[] [] = &#123;&#123;值1,值2&#125;,&#123;值1,值2&#125;,&#123;值1,值2&#125;&#125; </code></li></ul><p>注意事项和细节</p><ul><li>一维数组声明方式：<code>int [] x 或者 int x []</code></li><li>二维数组声明方式：<code>int [] [] y 或者 int[] y [] 或者 int y [] []</code></li><li>二维数组实际上是由多个一维数组组成的，<strong>它的各个一维数组的长度可以相同，也可以不相同</strong></li></ul><h3 id="排序-基础"><a href="#排序-基础" class="headerlink" title="排序(基础)"></a>排序(基础)</h3><h4 id="排序分类"><a href="#排序分类" class="headerlink" title="排序分类"></a>排序分类</h4><ul><li><p>想需要处理的所有数据都加载到内部存储器中进行排序。</p><ul><li>包括(交换式排序法、选择式排序法和插入式排序法)</li></ul></li><li><p>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。</p><ul><li>包括(合并排序法和直接合并排序法)</li></ul></li></ul><p>5.3.2 冒泡排序</p><p><strong>定义</strong></p><ul><li>冒泡排序  (Bubble Sorting) 的基本思想是<ul><li>通过对待排序序列从后向前(从下标较大的元素开始)，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒</li></ul></li></ul><p><strong>冒泡排序特点</strong></p><ul><li><p>一共有n个元素</p></li><li><p>一共进行了n-1轮排序，可以看成是外层循</p></li><li><p>每1轮排序可以确定一个数的位置，比如第1轮排序确定最大数,第2轮排序，确定第2大的数位置，依次类推</p></li><li><p>当进行比较时，如果前面的数大于后面的数，就交换</p></li></ul><h3 id="查找-基础"><a href="#查找-基础" class="headerlink" title="查找(基础)"></a><strong>查找(基础)</strong></h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a><strong>顺序查找</strong></h4><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h4><h2 id="面向对象-基础"><a href="#面向对象-基础" class="headerlink" title="面向对象(基础)"></a>面向对象(基础)</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a><strong>类与对象</strong></h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>类是抽象的，概念的，代表一类事物,比如人类, 猫类…即它是数据类型</li><li>对象是具体的，实际的，代表一个具体事物，即是实例</li><li>类是对象的模板，对象是类的一个个体，对应一个实例</li></ul><h4 id="对象存在形式⭐️"><a href="#对象存在形式⭐️" class="headerlink" title="对象存在形式⭐️"></a><strong>对象存在形式⭐️</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061439172.png" alt="image-20221006143947024"></p><h4 id="属性-x2F-成员变量"><a href="#属性-x2F-成员变量" class="headerlink" title="属性&#x2F;成员变量"></a>属性&#x2F;成员变量</h4><h5 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li><p>从概念或叫法上看</p><ul><li>成员变量 &#x3D; 属性 &#x3D; field(字段)</li></ul></li><li><p>属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)，比如定义猫类 的 int age 就是属性</p></li></ul><h5 id="注意事项和细节-3"><a href="#注意事项和细节-3" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li><p>属性的定义语法同变量，示例：访问修饰符 属性类型 属性名 </p></li><li><p>访问修饰符：控制属性和访问范围，有四种访问修饰符 public,proctected,defaul,private </p></li><li><p>属性的定义类型可以为任意类型，包含基本类型或引用类型 </p></li><li><p>属性如果不赋值，有默认值，规则和数组一致:</p><ul><li>int0,short 0,byte 0, long 0</li><li>float 0.0,double 0.0 </li><li>char \u0000</li><li>boolean false</li><li>String null</li></ul></li></ul><h4 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h4><ul><li><strong>先声明在创建</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat;</span><br><span class="line">cat = new Cat();</span><br></pre></td></tr></table></figure><h5 id="对象创建流程分析⭐️⭐️"><a href="#对象创建流程分析⭐️⭐️" class="headerlink" title="对象创建流程分析⭐️⭐️"></a>对象创建流程分析⭐️⭐️</h5><ul><li><p>加载 Person 类信息(就是Person.class 且只加载一次) </p></li><li><p>在堆中分配空间(地址) </p></li><li><p>完成对象初始化 </p><ul><li><p>默认初始化 age &#x3D; 0 name &#x3D;null  </p></li><li><p>显示初始化 age &#x3D; 90 name &#x3D; null  </p></li><li><p>构造器初始化 age &#x3D; 20 name &#x3D; 小倩)</p></li></ul></li><li><p>在对象在堆中的地址返回给 P (P是对象名，是对象的引用)</p></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061447426.png" alt="image-20221006144745244"></p><h4 id="对象分配机制"><a href="#对象分配机制" class="headerlink" title="对象分配机制"></a><strong>对象分配机制</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">p1.age = 10;</span><br><span class="line">p1.name = &quot;小明&quot;;</span><br><span class="line">Person p2 = p1//把p1赋给了p2，或让p2指向p1</span><br><span class="line">System.out.println(p2.age);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061449738.png" alt="image-20221006144902621"></p><h4 id="Java内存结构分析"><a href="#Java内存结构分析" class="headerlink" title="Java内存结构分析"></a>Java内存结构分析</h4><ul><li><p>栈：一般存放基本数据类型(局部变量)</p></li><li><p>堆：存放对象(Cat cat，数组等)</p></li><li><p>方法区：常量池(常量，比如字符串)，类加载信息</p></li></ul><h4 id="Java创建对象流程"><a href="#Java创建对象流程" class="headerlink" title="Java创建对象流程"></a>Java创建对象流程</h4><ul><li><p>先加载Person类信息(<strong>属性和方法信息，只会加载一次</strong>) </p></li><li><p>在堆中分配空间，进行默认初始化(看规则) </p></li><li><p>把地址赋给 p，p 就指向对象 </p></li><li><p>行指定初始化，比如 p.name &#x3D;” jack”  p.age &#x3D; 10</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">p.name = &quot;jack&quot;;</span><br><span class="line">p.age = 10;</span><br></pre></td></tr></table></figure><h3 id="成员方法⭐️"><a href="#成员方法⭐️" class="headerlink" title="成员方法⭐️"></a>成员方法⭐️</h3><h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回数据类型 方法名(形参列表)  &#123;</span><br><span class="line">//方法体       </span><br><span class="line">语句;       </span><br><span class="line">return 返回值; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>解析</p><ul><li>形参列表：表示成员方法输入 callint n)</li><li>数据类型(返回类型)<ul><li>表示成员方法输出，void 表示没有返回值</li></ul></li><li>方法主体：表示为了实现某一功能代码块</li><li>return 语句不是必须的</li></ul><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Method01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p1 = new Person();</span><br><span class="line">        p1.speak();</span><br><span class="line">        p1.cal01();</span><br><span class="line">        p1.cal02(10);</span><br><span class="line">        int returnRes = p1.getSum(1,2);</span><br><span class="line">        System.out.println(returnRes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public void speak()&#123;</span><br><span class="line">        System.out.println(&quot;你是一个猪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void cal01()&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1;i &lt;= 1000;i++)&#123;</span><br><span class="line">            res += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    public void cal02(int n)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">            res += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSum(int num1,int num2)&#123;</span><br><span class="line">        int res = num1 + num2;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析</p><ul><li>public <ul><li>表示方法是公开</li></ul></li><li>void<ul><li>表示方法没有返回值</li></ul></li><li>speak()<ul><li>speak是方法名，()形参列表</li></ul></li><li>{}方法体<ul><li>可以写我们要执行的代码</li></ul></li><li>System.out.println(“”)<ul><li>表示我们的方法就是输出一句话</li></ul></li><li>p1.speak() 为调用</li></ul><h4 id="调用的内存机制"><a href="#调用的内存机制" class="headerlink" title="调用的内存机制"></a><strong>调用的内存机制</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int getSum(int num1,int num2)&#123;</span><br><span class="line">        int res = num1 + num2;</span><br><span class="line">        return res;</span><br></pre></td></tr></table></figure><ul><li>public <ul><li>表示方法是公开的</li></ul></li><li>int <ul><li>表示方法执行后，返回一个 int 值</li></ul></li><li>getsum 方法名 </li><li>(int num1， int num2) <ul><li>形参列表，2个形参，可以接收用户传入的两个数</li></ul></li><li>5 return res<ul><li>表示把res 的值，返回</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061457696.png" alt="image-20221006145724526"></p><h4 id="注意事项和细节-4"><a href="#注意事项和细节-4" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><ul><li>作用是控制方法使用的适用范围，若果不写则默认访问</li></ul><h5 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h5><ul><li><p>一个方法最多有一个返回值</p></li><li><p>返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)</p></li><li><p><strong>方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值;要求返回值类型必须和return的值类型一致或兼容</strong></p></li><li><p>如果方法是void，则方法体中可以没有return语句，或者 只写 return</p></li></ul><h5 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h5><ul><li>方法名遵循驼峰法则</li></ul><h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h5><ul><li><p>一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如 getSum(int n1,int n2) </p></li><li><p>参数类型可以为任意类型，包含基本类型或引用类型，比如 printArr(intlIl map) </p></li><li><p>调用参数的方法时，一定对应着参数列表传入相同类型或莱容类型 的参数 </p></li><li><p><strong>方法定义时的参数称为形式参数，简称形参；方法调用时的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致</strong></p></li></ul><h5 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h5><ul><li><p>里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用</p></li><li><p>里面不能再定义方法！即：<strong>方法不能嵌套定义</strong></p></li></ul><h5 id="方法调用细节"><a href="#方法调用细节" class="headerlink" title="方法调用细节"></a>方法调用细节</h5><ul><li><p>同一个类中的方法调用：直接调用即可</p></li><li><p>跨类中的方法 A 类调用 B 类方法：需要通过对象名调用</p></li><li><p>跨类的方法调用和方法的访问修饰符相关</p></li></ul><h3 id="成员方传法参机制⭐️⭐️"><a href="#成员方传法参机制⭐️⭐️" class="headerlink" title="成员方传法参机制⭐️⭐️"></a><strong>成员方传法参机制⭐️⭐️</strong></h3><h4 id="基本数据类型的传参数机制"><a href="#基本数据类型的传参数机制" class="headerlink" title="基本数据类型的传参数机制"></a><strong>基本数据类型的传参数机制</strong></h4><ul><li>传递的是值(拷贝)，形参的任何改变不影响实参</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071949393.png" alt="image-20221007182910593"></p><h4 id="引用数据类型的传参数机制"><a href="#引用数据类型的传参数机制" class="headerlink" title="引用数据类型的传参数机制"></a><strong>引用数据类型的传参数机制</strong></h4><ul><li>引用类型传递的是地址(传递也是值，但是值是地址)，可以通过形参影响实参</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071829590.png" alt="image-20221007182953355"></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li><strong>递归就是方法自己调用自己,每次调用时传入不同的变量</strong></li></ul><h4 id="递归调用内存机制"><a href="#递归调用内存机制" class="headerlink" title="递归调用内存机制"></a>递归调用内存机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Recursion01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        t1.test(5);</span><br><span class="line">        int res = t1.factorial(5);</span><br><span class="line">        System.out.println(&quot;res = &quot;+ res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  T&#123;</span><br><span class="line">    public void test(int n)&#123;</span><br><span class="line">        if(n &gt; 2)&#123;</span><br><span class="line">            test(n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int factorial(int n)&#123;</span><br><span class="line">        if(n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return factorial(n - 1)*n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071830340.png" alt="image-20221007183021205"></p><h4 id="注意事项和细节-5"><a href="#注意事项和细节-5" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li><li>方法的局部变量是独立的，不会相互影响，比如n变量</li><li>如果方法中使用的是引用类型变量(比如数组、对象)，就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则就是无限递归</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕，栈空间回收</li></ul><h3 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载 (overload)"></a><strong>方法重载 (overload)</strong></h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>java 中允许同一个类中，多个同名方法的存在，但要求<strong>形参列表不一致</strong></li></ul><h4 id="注意事项和细节-6"><a href="#注意事项和细节-6" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><ul><li>方法名<ul><li>必须相同</li></ul></li><li>形参列表<ul><li>必须不同(参数类型、个数、顺序)</li></ul></li><li>返回类型<ul><li>无要求</li></ul></li></ul><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变参数</strong></h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><ul><li>java 允许将同一个类中多个同名同功能<strong>但参数个数不同</strong>的方法，封装成一个方法，通过可变参数实现</li></ul><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回类型 方法名(**数据类型...** 形参名)&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项和细节-7"><a href="#注意事项和细节-7" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>可变参数的实参可以为0个或任意多个</li><li>可变参数的实参可以为数组</li><li>可变参数的本质就是数组</li><li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li><li>一个形参列表中只能出现一个可变参数</li></ul><h3 id="变量作用域⭐️"><a href="#变量作用域⭐️" class="headerlink" title="变量作用域⭐️"></a><strong>变量作用域⭐️</strong></h3><h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><ul><li><p>主要的变量就是属性(成员变量)和局部变量</p></li><li><p>局部变量一般是指在成员方法中定义的变量</p></li><li><p>全局变量：也就是属性，作用域为整个类体</p></li><li><p>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</p></li><li><p><strong>全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值</strong></p></li></ul><h4 id="注意事项和细节-8"><a href="#注意事项和细节-8" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>全局变量和局部变量可以重名，访问时遵循就近原则</p></li><li><p>在同一个作用域中，两个局部变量，不能重名</p></li><li><p>全局变量生命周期长，伴随着对象的创建而创建，伴随着对象的销毁而销毁</p></li><li><p>局部变量生命周期短，伴随着它的代码块的执行而创建，伴随着代码块的结束而结束：即在一次方法调用过程中</p></li><li><p>作用域范围不同 全局变量&#x2F;属性：可以被本类使用，或其他类使用(通过对象调用) 局部变量：只能在本类中对应的方法中使用</p></li><li><p>修饰符不同 全局变量&#x2F;属性可以加修饰符 局部变量不可以加修饰符</p></li></ul><h4 id="两种调用方式"><a href="#两种调用方式" class="headerlink" title="两种调用方式"></a><strong>两种调用方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class VarScopeDetail &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        E e1 = new E();</span><br><span class="line">        e1.test();</span><br><span class="line"></span><br><span class="line">        Per p1 = new Per();</span><br><span class="line">        e1.test2(p1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class E&#123;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        Per p1 = new Per();</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">    &#125;</span><br><span class="line">    public void test2(Per p)&#123;//接收一个类</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Per&#123;</span><br><span class="line">    String name = &quot;jack&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器⭐️"><a href="#构造器⭐️" class="headerlink" title="构造器⭐️"></a><strong>构造器⭐️</strong></h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对<strong>新对象的初始化</strong></li></ul><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法名 (行参列表)&#123;</span><br><span class="line">  方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项和细节-9"><a href="#注意事项和细节-9" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><ul><li>修饰符可以默认 </li><li>一个类可以定义多个不同的构造器，即构造器重载 </li><li>构造器名和类名要相同 </li><li><strong>构造器没有返回值</strong> </li><li>构造器是完成对象的初始化，井不是创建对象 </li><li>在创建对象时,系统自动的调用该类的构造方法 </li><li><strong>如果没有定义构造器，系统会自动给类生成一个默认无参构造器</strong>(默认构造器) </li><li><strong>定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Constructor01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pers p1 = new Pers();</span><br><span class="line">        Pers p2 = new Pers(&quot;jack&quot;,80);</span><br><span class="line">        System.out.println(p1.name+p1.age);</span><br><span class="line">        System.out.println(p2.name+p2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pers&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public Pers()&#123;</span><br><span class="line">        System.out.println(&quot;构造器1被调用&quot;);</span><br><span class="line">        age = 18;</span><br><span class="line">    &#125;</span><br><span class="line">    public Pers(String pName,int pAge)&#123;</span><br><span class="line">        System.out.println(&quot;构造器2被调用&quot;);</span><br><span class="line">        name = pName;</span><br><span class="line">        age = pAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>java虚拟机会给每个对象分配this，代表当前对象</li></ul><h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a><strong>内存分析</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071830533.png" alt="image-20221007183055402"></p><h4 id="注意事项和细节-10"><a href="#注意事项和细节-10" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><ul><li>this关键字可以用来访问本类的属性、方法、构造器</li><li>this用于区分当前类的属性和局部变量</li><li>访问成员方法的语法：this.方法名(参数列表);</li><li>访问构造器语法<ul><li>this(参数列表)：<strong>注意只能在构造器中使用(在构造器中访问另外一个构造器，必须放在第一条语句)</strong></li></ul></li><li>this不能在类定义的外部使用，只能在类定义的方法中使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ThisExercise01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        person p1 = new person(&quot;marry&quot;,20);</span><br><span class="line">        person p2 = new person(&quot;marry&quot;,20);</span><br><span class="line">        System.out.println(p1.compareTo(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class person&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public person(String name,int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean compareTo(person p)&#123;</span><br><span class="line">        return this.name.equals(p.name) &amp;&amp; this.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象-中级"><a href="#面向对象-中级" class="headerlink" title="面向对象(中级)"></a><strong>面向对象(中级)</strong></h2><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a><strong>IDEA</strong></h3><p><strong>常用快捷键</strong></p><ul><li><p>win + d  删除当前行</p></li><li><p>win + shift + 向下光标  向下复制当前行</p></li><li><p>shift + &#x2F;  补全代码</p></li><li><p>win + &#x2F;  注释</p></li><li><p>shift+enter  导入该行的类</p></li><li><p>win + shift + L  格式化代码</p></li><li><p>control + R  运行</p></li><li><p>shift + A  构造器</p></li><li><p>control + H 查看继承关系</p></li><li><p>win + B  定位方法</p></li><li><p>var  自动变量名</p></li><li><p>win + shift + T 环绕方式</p></li></ul><p>常用模块快捷键</p><ul><li><p>fori  遍历</p></li><li><p>itar  遍历数组</p></li><li><p>iter  增强遍历</p></li><li><p>sout  打印换行</p></li></ul><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li>Package 包名</li></ul><h4 id="包的命名"><a href="#包的命名" class="headerlink" title="包的命名"></a>包的命名</h4><ul><li>只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字</li></ul><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><ul><li>小写字母＋小圆点一般是  com.公司名.项目名.业务模块名</li></ul><h4 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h4><ul><li><p>import java.uti Scanner；就只是引入一个类Scanner</p></li><li><p>import java.util*：1&#x2F; 表示将java.util 包所有都引入</p></li></ul><h4 id="注意事项和细节-11"><a href="#注意事项和细节-11" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一个package</p></li><li><p>import指令 位置放在package的下面，在类定义前面,可以有多句目没有顺序要求</p></li></ul><h3 id="访问修饰符-1"><a href="#访问修饰符-1" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>java提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限(范围)</li></ul><h4 id="访问权限⭐️⭐️"><a href="#访问权限⭐️⭐️" class="headerlink" title="访问权限⭐️⭐️"></a>访问权限⭐️⭐️</h4><ul><li><p>公开级别</p><ul><li>用public修饰,对外公开</li></ul></li><li><p>受保护级别</p><ul><li>用protected修饰，对子类和同一个包中的类公开</li></ul></li><li><p>默认级别</p><ul><li>没有修饰符号，向同一个包的类公开</li></ul></li><li><p>私有级别</p><ul><li>用private修饰,只有类本身可以访问，不对外公开</li></ul></li></ul><table><thead><tr><th>访问级别</th><th>访问修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr><td>公开</td><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>受保护</td><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>默认</td><td>无</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>私有</td><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><h4 id="注意事项和细节-12"><a href="#注意事项和细节-12" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>修饰符可以用来修饰类中的属性，成员方法以及类</li><li><strong>只有默认的和public才能修饰类</strong>，并目遵循上述访问权限的特点</li><li>子类待定</li><li>成员方法的访问规则和属性完全样</li></ul><h3 id="封装⭐️"><a href="#封装⭐️" class="headerlink" title="封装⭐️"></a><strong>封装⭐️</strong></h3><h4 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作方法封装在一起数据被保护在内部，程序的其它部分只有通过被授权的操作（方法），才能对数据进行操作</li></ul><h4 id="封装步骤"><a href="#封装步骤" class="headerlink" title="封装步骤"></a><strong>封装步骤</strong></h4><ul><li>将属性进行私有化private【不能直接修改属性】</li><li>提供一个公共的(public)set方法，用于对属性判断井赋值 public void setxxx(类型 参数名){ 加入数据验证的业务逻辑; 属性 &#x3D; 参数名;}</li><li>提供个公共的(public)get方法，用于获取属性的值 public 数据类型 getXxxx0{ return XX;}</li></ul><h3 id="继承⭐️"><a href="#继承⭐️" class="headerlink" title="继承⭐️"></a><strong>继承⭐️</strong></h3><h4 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>继承可以<strong>解决代码复用</strong>，当多个类存在相同的属性(变量)和方法时,可以以这些类中抽象出交类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可</li></ul><h4 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li>class 子类 extends 父类{}</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071832706.png" alt="image-20221007183209452"></p><h4 id="注意事项和细节-13"><a href="#注意事项和细节-13" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问</li><li><strong>子类必须调用父类的构造器，完成父类的初始化</strong></li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</li><li>指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)</li><li>super在使用时，必须放在构造器第一行(super只能在构造器中使用)</li><li>super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java所有类都是Object类的子类</li><li>父类构造器的调用不限于直接父类！将一直往上追潮直到Object类</li><li>子类最多只能继承一个父类(指直接继承)，即<strong>java中是单继承机制</strong></li><li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public class TopBase &#123; //父类是Object</span><br><span class="line"></span><br><span class="line">    public TopBase() &#123;</span><br><span class="line">        //super(); Object的无参构造器</span><br><span class="line">        System.out.println(&quot;构造器TopBase() 被调用...&quot;);//1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Base extends TopBase &#123; //父类</span><br><span class="line">    //4个属性</span><br><span class="line">    public int n1 = 100;</span><br><span class="line">    protected int n2 = 200;</span><br><span class="line">    int n3 = 300;</span><br><span class="line">    private int n4 = 400;</span><br><span class="line"></span><br><span class="line">    public Base() &#123; //无参构造器</span><br><span class="line">        System.out.println(&quot;父类Base()构造器被调用....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Base(String name, int age) &#123;//有参构造器</span><br><span class="line">        //默认super()</span><br><span class="line">        System.out.println(&quot;父类Base(String name, int age)构造器被调用....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Base(String name) &#123;//有参构造器</span><br><span class="line">        System.out.println(&quot;父类Base(String name)构造器被调用....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //父类提供一个public的方法,返回了n4</span><br><span class="line">    public int getN4() &#123;</span><br><span class="line">        return n4;</span><br><span class="line">    &#125;</span><br><span class="line">    public void test100() &#123;</span><br><span class="line">        System.out.println(&quot;test100&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void test200() &#123;</span><br><span class="line">        System.out.println(&quot;test200&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void test300() &#123;</span><br><span class="line">        System.out.println(&quot;test300&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void test400() &#123;</span><br><span class="line">        System.out.println(&quot;test400&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //call</span><br><span class="line">    public void callTest400() &#123;</span><br><span class="line">        test400();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/输入ctrl + H 可以看到类的继承关系</span><br><span class="line">public class Sub extends Base &#123; //子类</span><br><span class="line"></span><br><span class="line">    public Sub(String name, int age) &#123;</span><br><span class="line">        //1. 调用父类的无参构造器, 如下或者 什么都不写,默认就是调用super()</span><br><span class="line">        //super();//父类的无参构造器</span><br><span class="line">        //2. 调用父类的 Base(String name) 构造器</span><br><span class="line">        //super(&quot;hsp&quot;);</span><br><span class="line">        //3. 调用父类的 Base(String name, int age) 构造器</span><br><span class="line">        super(&quot;king&quot;, 20);</span><br><span class="line"></span><br><span class="line">        //细节：super在使用时，必须放在构造器第一行</span><br><span class="line">        //细节: super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</span><br><span class="line">        //this() 不能再使用了</span><br><span class="line">        System.out.println(&quot;子类Sub(String name, int age)构造器被调用....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Sub() &#123;//无参构造器</span><br><span class="line">        //super(); //默认调用父类的无参构造器</span><br><span class="line">        super(&quot;smith&quot;, 10);</span><br><span class="line">        System.out.println(&quot;子类Sub()构造器被调用....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器</span><br><span class="line">    public Sub(String name) &#123;</span><br><span class="line">        super(&quot;tom&quot;, 30);</span><br><span class="line">        //do nothing...</span><br><span class="line">        System.out.println(&quot;子类Sub(String name)构造器被调用....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayOk() &#123;//子类方法</span><br><span class="line">        //非私有的属性和方法可以在子类直接访问</span><br><span class="line">        //但是私有属性和方法不能在子类直接访问</span><br><span class="line">        System.out.println(n1 + &quot; &quot; + n2 + &quot; &quot; + n3);</span><br><span class="line">        test100();</span><br><span class="line">        test200();</span><br><span class="line">        test300();</span><br><span class="line">        //test400();错误</span><br><span class="line">        //要通过父类提供公共的方法去访问</span><br><span class="line">        System.out.println(&quot;n4=&quot; + getN4());</span><br><span class="line">        callTest400();//</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="继承本质"><a href="#继承本质" class="headerlink" title="继承本质"></a>继承本质</h4><ul><li>子对象创建完成，建立查找关系</li></ul><h4 id="继承内存图"><a href="#继承内存图" class="headerlink" title="继承内存图"></a>继承内存图</h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071833402.png" alt="image-20221007183305242"></p><h3 id="多态⭐️⭐️"><a href="#多态⭐️⭐️" class="headerlink" title="多态⭐️⭐️"></a>多态⭐️⭐️</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础之上的</li></ul><h4 id="多态具体体现"><a href="#多态具体体现" class="headerlink" title="多态具体体现"></a>多态具体体现</h4><h5 id="方法的多态"><a href="#方法的多态" class="headerlink" title="方法的多态"></a>方法的多态</h5><ul><li>重写和重载就是体现多态</li></ul><h5 id="对象的多态"><a href="#对象的多态" class="headerlink" title="对象的多态"></a><strong>对象的多态</strong></h5><ul><li><p>一个对象的编译类型和运行类型可以不一致</p></li><li><p>编译类型在定义对象时，就确定了，不能改变</p></li><li><p>运行类型是可以变化的</p></li><li><p><strong>编译类型看定义时 &#x3D; 号 的左边，运行类型看 &#x3D; 号的 右边</strong></p></li></ul><h6 id="注意事项和细节-14"><a href="#注意事项和细节-14" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h6><h6 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h6><ul><li><p>本质</p><ul><li>父类的引用指向了子类的对象</li></ul></li><li><p>语法</p><ul><li>父类类型 引用名 &#x3D; new 子类类型();</li></ul></li><li><p>特点</p><ul><li>编译类型看左边，运行类型看右边</li></ul></li><li><p>可以调用父类中的所有成员(需遵守访问权限)</p></li><li><p>不能调用子类特有成员</p></li><li><p>最终运行效果看子类的具体实现</p></li></ul><h6 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h6><ul><li><p>本质</p><ul><li>把指向子类对象的父类引用，转成子类对象的子类引用</li></ul></li><li><p>语法</p><ul><li>子类类型 引用名 &#x3D; (子类类型) 父类引用;</li></ul></li><li><p><strong>只能强转父类引用，不能强转父类对象</strong></p></li><li><p>父类的引用必须指向的是当前目标类型的对象</p></li><li><p>当向下转型后，可以调用子类类型中所有的成员</p></li></ul><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li>属性没有重写，属性的值看编译类型</li><li><strong>instance of 比较较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">             //语法：父类类型引用名 = new 子类类型();</span><br><span class="line">             Animal animal = new Cat();</span><br><span class="line">             Object obj = new Cat();//可以吗? 可以 Object 也是 Cat的父类</span><br><span class="line">     </span><br><span class="line">             //向上转型调用方法的规则如下:</span><br><span class="line">             //(1)可以调用父类中的所有成员(需遵守访问权限)</span><br><span class="line">             //(2)但是不能调用子类的特有的成员</span><br><span class="line">             //(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的</span><br><span class="line">             //animal.catchMouse();错误</span><br><span class="line">             //(4)最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法</span><br><span class="line">             //，然后调用，规则我前面我们讲的方法调用规则一致。</span><br><span class="line">             animal.eat();//猫吃鱼..</span><br><span class="line">             animal.run();//跑</span><br><span class="line">             animal.show();//hello,你好</span><br><span class="line">             animal.sleep();//睡</span><br><span class="line">     </span><br><span class="line">             //可以调用Cat的 catchMouse方法</span><br><span class="line">             //多态的向下转型</span><br><span class="line">             //(1)语法：子类类型 引用名 =（子类类型）父类引用;</span><br><span class="line">             //问一个问题? cat 的编译类型 Cat,运行类型是 Cat</span><br><span class="line">             Cat cat = (Cat) animal;</span><br><span class="line">             cat.catchMouse();//猫抓老鼠</span><br><span class="line">             //(2)要求父类的引用必须指向的是当前目标类型的对象</span><br><span class="line">             Dog dog = (Dog) animal; //可以吗？</span><br><span class="line">     </span><br><span class="line">             System.out.println(&quot;ok~~&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyDetail02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//属性没有重写之说！属性的值看编译类型</span></span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();<span class="comment">//向上转型</span></span><br><span class="line">        System.out.println(base.count);<span class="comment">// ？ 看编译类型 10</span></span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(sub.count);<span class="comment">//?  20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;<span class="comment">//子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyDetail03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        System.out.println(bb <span class="keyword">instanceof</span>  BB);<span class="comment">// true</span></span><br><span class="line">        System.out.println(bb <span class="keyword">instanceof</span>  AA);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//aa 编译类型 AA, 运行类型是BB</span></span><br><span class="line">        <span class="comment">//BB是AA子类</span></span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        System.out.println(aa <span class="keyword">instanceof</span> AA);</span><br><span class="line">        System.out.println(aa <span class="keyword">instanceof</span> BB);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> AA);<span class="comment">//false</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">//System.out.println(str instanceof AA);</span></span><br><span class="line">        System.out.println(str <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;&#125; <span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">AA</span> &#123;&#125;<span class="comment">//子类</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="动态绑定机制⭐️⭐️"><a href="#动态绑定机制⭐️⭐️" class="headerlink" title="动态绑定机制⭐️⭐️"></a>动态绑定机制⭐️⭐️</h4><ul><li>当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;<strong>运行类型</strong>绑定</li><li>当调用对象属性时，没有动态綁定机制，哪里声明，那里使用()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;<span class="comment">//当子类不存在sum方法时，会从父类找到sum方法，但动态绑定机制会找到子类的getI返回i值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a><strong>多态的应用</strong></h4><h5 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h5><ul><li>多态数组<ul><li>定义类型为父类类型，里面保存的实际元素类型为子类类型</li></ul></li><li>多态参数<ul><li>方法定义的形参类型为父类类型，实参类型允许为子类类型</li></ul></li></ul><h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>super 代表父类的引用，用于访问父类的属性、方法、构造器</li></ul><h4 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li>访问父类的属性，但不能访问父类的 private 属性 super.属性名</li><li>访问父类的方法，不能访问父类的 private 方法 super.方法名(参数列表)</li><li>访问父类的构造器(只能放在构造器的第一句，只能出现一句) super(参数列表)</li></ul><h4 id="注意事项和细节-15"><a href="#注意事项和细节-15" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>调用父类的构造器的好处 (分工明确，父类属性由父类初始化，子类的属性由子类初始化)</li><li>当子类中有和父类中的成员(属性和方法) 重名时，为了访问父类的成员，必须通过super，如果没有重名，使用super、this、 直接访问效果相同</li><li><strong>super的访问不限于直接父类</strong>，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类(上级类)中都有同名的成员，使用super访问遵循就近原则</li></ul><h4 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a><strong>super和this</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071835631.png" alt="image-20221007183503501"></p><h3 id="方法重写-overwrite"><a href="#方法重写-overwrite" class="headerlink" title="方法重写(overwrite)"></a><strong>方法重写(overwrite)</strong></h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>子类的方法和父类方法一致，那么子类的方法覆盖了父类的方法</li></ul><h4 id="注意事项和细节-16"><a href="#注意事项和细节-16" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><strong>子类的方法的形参列表,方法名称，要和父类方法的形参列表,方法名称完全一样</strong></li><li><strong>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类</strong></li><li><strong>子类方法大于等于父类方法的访问权限</strong></li></ul><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Base &#123; //父类是Object</span><br><span class="line"></span><br><span class="line">    public int n1 = 999;</span><br><span class="line">    public int age = 111;</span><br><span class="line">    public void cal() &#123;</span><br><span class="line">        System.out.println(&quot;Base类的cal() 方法...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;Base类的eat().....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a><strong>Object类</strong></h3><ul><li>常见的方法</li></ul><h4 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h4><ul><li>既可以判断基本类型，又可以判断引用类型 </li><li>如果判断基本类型，判断的是值是否相等 </li><li><strong>如果判断引用类型，判断的是地址是否相等</strong>，即判定是不是同一个对象</li></ul><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><ul><li>equals:是 Object 类中的方法，<strong>只能判断引用类型</strong></li><li>默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等</li></ul><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><ul><li><p><strong>提高具有哈希结构的容器的效率</strong></p></li><li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</p></li><li><p>两个引用，如果指向的是不同对象，则哈希值是不一样的</p></li><li><p>哈希值主要根据地址号来的，不能完全将哈希值等价子地址</p></li><li><p>后面在集合中 hashCode 如果需要的话，也会重写</p></li></ul><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><ul><li><p>默认返回：全类名＋@+哈希值的十六进制</p></li><li><p>子类往往重写 to String 方法，用于返回对象的属性信息</p></li><li><p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式</p></li><li><p>当直接输出一个对象时，toString  方法会被默认的调用</p></li></ul><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><ul><li><p>当对象被回收时，系统自动调用该对象的  finalize 方法。子类可以重写该方法，做一些释放资源的操作</p></li><li><p>什么时候被回收</p><ul><li>当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法</li></ul></li><li><p>垃圾回收机制的调用，是由系统来決定(即有自己的GC算法)，也可以通过System.gc() 主动触发垃圾回收机制</p></li></ul><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a><strong>断点调试</strong></h3><h4 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug</li></ul><h4 id="注意事项和细节-17"><a href="#注意事项和细节-17" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>在断点调试 过程中，是运行状态，是以对象的运行类型来执行的</p></li><li><p>F7：跳入方法内</p></li><li><p>F8：逐行执行代码 shift+F8:跳出方法</p></li><li><p>F9：resume，执行到下一个断点</p></li></ul><h2 id="面向对象-高级"><a href="#面向对象-高级" class="headerlink" title="面向对象(高级)"></a><strong>面向对象(高级)</strong></h2><h3 id="类变量和类方法⭐️"><a href="#类变量和类方法⭐️" class="headerlink" title="类变量和类方法⭐️"></a><strong>类变量和类方法⭐️</strong></h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a><strong>类变量</strong></h4><h5 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul><li>类变量也叫<strong>静态变量&#x2F;静态属性</strong>，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量</li></ul><h5 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 static 数据类型 变量名;</span><br><span class="line">static 访问修饰符 数据类型 变量名;</span><br></pre></td></tr></table></figure><h5 id="如何访问类变量"><a href="#如何访问类变量" class="headerlink" title="如何访问类变量"></a>如何访问类变量</h5><ul><li>类名.类变量名</li><li>对象名.类变量名</li></ul><p><strong>静态变量的访问修饰符的访问权限和范围和普通属性是一样的</strong></p><h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a><strong>内存布局</strong></h5><ul><li>略</li></ul><h5 id="注意事项和细节-18"><a href="#注意事项和细节-18" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量(静态变量)</li><li>类变量是该类的所有对象共享的，而实例变量是每个对象独享的</li><li>加上static称为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量</li><li>类变量可以通过 <ul><li>类名.类变量名 或者 对象名.类变量名 来访问</li></ul></li><li>实例变量不能通过 类名.类变量名 方式访问</li><li>类变量是在类加载时就初始化</li><li>类变量的生命周期是随类的加载开始，随着类消亡而销毁</li></ul><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a><strong>类方法</strong></h4><h5 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li>类方法也叫静态方法</li></ul><h5 id="基本语法-6"><a href="#基本语法-6" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 static 数据返回类型 方法名()&#123;&#125;;</span><br><span class="line">static 访问修饰符 数据返回类型 方法名()&#123;&#125;;</span><br></pre></td></tr></table></figure><h5 id="类方法调用"><a href="#类方法调用" class="headerlink" title="类方法调用"></a>类方法调用</h5><ul><li>类名.类方法名</li><li>对象名.类方法名</li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法,提高开发效率</p></li><li><p>程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用</p></li></ul><h5 id="注意事项和细节-19"><a href="#注意事项和细节-19" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li><p><strong>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区</strong></p><ul><li>类方法中无 this 的参数，普通方法中隐含着 this 的参数</li></ul></li><li><p>类方法可以通过类名调用，也可以通过对象名调用</p></li><li><p>音通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用</p></li><li><p>类方法中不允许使用和对象有关的关键字，比如this和super</p></li><li><p><strong>静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员</strong></p></li></ul><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a><strong>main方法</strong></h3><h4 id="深入理解main方法"><a href="#深入理解main方法" class="headerlink" title="深入理解main方法"></a><strong>深入理解main方法</strong></h4><ul><li>java虛拟机需要调用类的 main() 方法，所以该方法的访问权限化须是 public</li><li>java虚拟机在执行 main() 方法时不必创建对象，所以该方法心须是 static</li><li>该方法接收 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数</li><li>java 执行的程序 参数1 参数2 参数3</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071835730.png" alt="image-20221007183555627"></p><h4 id="注意事项和细节-20"><a href="#注意事项和细节-20" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>在 main() 方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性</li><li>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的目标静态成员</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h3><h4 id="基本介绍-17"><a href="#基本介绍-17" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>代码化块又称为初始化块,属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过们包围起来</li><li>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用</li></ul><h4 id="基本语法-7"><a href="#基本语法-7" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line">  代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h5><ul><li><p>修饰符 可选，要写的话，也只能写 static</p></li><li><p>代码块分为两类，使用static 修饰的叫静态代码块，没有static修饰的，叫普通代码块</p></li><li><p>逻辑语句可以为任何逻辑语句</p></li><li><p>号可以写上，也可以省略</p></li></ul><h4 id="注意事项和细节-21"><a href="#注意事项和细节-21" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p><strong>static 代码块是类加载时执行，且只会执行一次</strong></p></li><li><p>普通代码块是在创建对象的调用的，创建一次，调用一次</p></li><li><p>类什么时候被加载⭐️⭐️： </p><ul><li><p>创建对象实例时</p></li><li><p>创建子类对象实例时，父类也会被加载</p></li><li><p>使用类的静态成员时</p></li></ul></li><li><p><strong>创建一个对象时，在一个类的调用顺序</strong> </p><ul><li><p>调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调</p></li><li><p>调用普通代码块和普通属性的初始化(注意：普通代码块和普通属性初始化调用的优先级一样，若果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)</p></li><li><p>调用构造器</p></li></ul></li><li><p>构造方法(构造器)的最前面其实隐含了 super()和调用普通代码块</p></li><li><p>创建子类时顺序⭐️⭐️： </p><ul><li><p>父类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p></li><li><p>子类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p></li><li><p>父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p></li><li><p>父类构造方法</p></li><li><p>子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p></li><li><p>子类构造方法</p></li></ul></li><li><p>静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员</p></li></ul><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a><strong>单例设计模式</strong></h3><h4 id="基本介绍-18"><a href="#基本介绍-18" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法 </li><li>单例模式有两种方式<ul><li>饿汉式 </li><li>懒汉式</li></ul></li></ul><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><ul><li><p>构造器私有化 </p></li><li><p>类的内部创建静态对象 </p></li><li><p>向外暴露一个静态公共方法 </p></li><li><p>特点：在类加载的时候就创建对象实例，可能存在资源浪费</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private static GirlFriend gf = new GirlFriend(&quot;新野&quot;);</span><br><span class="line"></span><br><span class="line">    private GirlFriend(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static GirlFriend Instance() &#123;</span><br><span class="line">        return gf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul><li>构造器私有化 </li><li>定义一个 static 静态属性对象 </li><li>提供一个 public 的 static 方法，返回一个对象 </li><li>只有当使用(3)的方法时，才返回对象，再次调用时，返回上次创建的对象 </li><li>特点：线程安全问题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private static Cat cat;</span><br><span class="line"></span><br><span class="line">    private Cat(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Cat getInstance()&#123;</span><br><span class="line">        if(cat == null)&#123;</span><br><span class="line">            cat = new Cat(&quot;小花&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li>最主要的区别在于创建对象的时机不同<ul><li>饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li></ul></li><li>饿汉式不存在线程安全问题，而懒汉式存在线程安全问题</li><li>饿汉式存在浪费姿源的可能，对象实例都没有使用，那么饿汉式创建的对象就浪费，懒汉式是使用时才创建，就不存在这个问题</li></ul><h3 id="final"><a href="#final" class="headerlink" title="final"></a><strong>final</strong></h3><h4 id="基本介绍-19"><a href="#基本介绍-19" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>final 可以修饰类、属性、方法、局部变量 </p></li><li><p>final 类</p><ul><li>类不能被继承</li></ul></li><li><p>final 方法</p><ul><li>子类无法重写方法</li></ul></li><li><p>final 属性</p><ul><li>属性无法被修改</li></ul></li><li><p>final 局部变量</p><ul><li>局部变量无法被修改</li></ul></li></ul><h4 id="注意事项和细节-22"><a href="#注意事项和细节-22" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>final 修饰的属性又叫常量，一般用XX_XX_XX 来命名</p></li><li><p>final 修饰的属性在定义时,必须赋初值,并且以后不能再修改，赋值可以在如下位置： 定义时、构造器、代码块</p></li><li><p>final 修饰的属性是静态的，则初始化的位置只能是 定义时、静态代码块</p></li><li><p>final 类不能继承，但可以实例化对象</p></li><li><p>如果类不是 final 类，但是含有 final 方法，则该方法虽然不能重写，但是可以被继承</p></li><li><p>如果一个类已经是 final 类了，就没有必要再将方法修饰成 final 方法</p></li><li><p>final不能修饰构造器本身</p></li><li><p>final 和 static 往往搭配使用，效率更高，不会导致类加载-底层编译器做了优化处理</p></li><li><p>包装类(Integer, Double,Float,Boolean等都是final)，String也是final类</p></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h3><h4 id="基本介绍-20"><a href="#基本介绍-20" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>用 abstract 关键字来修饰一个类时,这个类就叫抽象类 </li><li>用abstract 关键字来修饰一个方法时,这个方法就是抽象方法，没有方法体 </li><li><strong>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类</strong></li></ul><h4 id="注意事项和细节-23"><a href="#注意事项和细节-23" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><ul><li>抽象类不能被实例化</li><li>抽象类不一定要包含 abstract 方法。也就是说,抽象类可以没有 abstract 方法</li><li>一旦类包含了 abstract 方法,则这个类必须声明为 abstract</li><li>abstract 只能修饰类和方法</li><li>抽象类可以有任意成员，抽象类本质还是类</li><li>抽象方法不能有主体</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有的抽象方法，除非它自己也声明为 abstract 类</li><li>抽象方法不能使用 private 、final 和 static 来修饰，因为这些关键字都是和重写相违背的</li></ul><h4 id="抽象类模版设计模式"><a href="#抽象类模版设计模式" class="headerlink" title="抽象类模版设计模式"></a>抽象类模版设计模式</h4><p>实例</p><ul><li>编写方法cal()，可以计算某段代码的耗时时间</li><li>b写抽象方法job()</li><li>编写一个子类A,继承抽象类Template，井实现job方法</li><li>编写一个测试类TestTemplate,看看是否好用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class TextTemplate &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a = new A();</span><br><span class="line">        a.cal();</span><br><span class="line"></span><br><span class="line">        B b = new B();</span><br><span class="line">        b.cal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract public class Template &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void job();</span><br><span class="line"></span><br><span class="line">    public void cal() &#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            job();</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;时间&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A extends Template&#123;</span><br><span class="line"></span><br><span class="line">    public void job() &#123;</span><br><span class="line">        long num = 0;</span><br><span class="line">        for (long i = 0; i &lt;= 10000000; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends Template&#123;</span><br><span class="line"></span><br><span class="line">    public void job() &#123;</span><br><span class="line">        long num = 0;</span><br><span class="line">        for (long i = 0; i &lt;= 10000000; i++) &#123;</span><br><span class="line">            num *= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口⭐️"><a href="#接口⭐️" class="headerlink" title="接口⭐️"></a><strong>接口⭐️</strong></h3><h4 id="基本介绍-21"><a href="#基本介绍-21" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>接口就是给出一些没有实现的方法,封装到一起,到某个类要使用的时候,再根据具体情况把这些方法写出来</li></ul><h4 id="基本语法-8"><a href="#基本语法-8" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">  //属性</span><br><span class="line">  //方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 类名 implements 接口 &#123;</span><br><span class="line">  自己属性;</span><br><span class="line">  自己方法;</span><br><span class="line">  //必须实现接口的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Jdk7.0 前接口里的所有方法都没有方法体(只能抽象方法)</li><li>Jdk8.0 后接口类可以有静态方法，defaut 实现方法，<strong>也就是说接口中可以有方法的具体实现</strong></li></ul><h4 id="注意事项和细节-24"><a href="#注意事项和细节-24" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>接口不能被实例化</p></li><li><p>接口中所有的方法是 public 和 abstract 方法，接口中抽象方法，可以不用 abstract 修饰</p></li><li><p>普通类实现接口，就必须将该接口的所有方法实现</p></li><li><p>抽象类实现接口，可以不用实现接口的方法</p></li><li><p>一个类同时可以实现多个接口</p></li><li><p>接口中的属性,只能是 final 的，而且是 public static final 修饰符</p></li><li><p>接口中属性的访问形式：接口名.属性名</p></li><li><p>一个接口不能继承其它的类,但是可以继承多个别的接口</p></li><li><p>接口的修饰符 只能是 public 和默认，这点和类的修饰符是一样的</p></li></ul><h4 id="实现接口VS继承类"><a href="#实现接口VS继承类" class="headerlink" title="实现接口VS继承类"></a>实现接口VS继承类</h4><ul><li><p>继承的价值主要在于</p><ul><li>解决代码的复用性和可维护性</li></ul></li><li><p>接口的价值主要在于</p><ul><li><strong>设计，设计好各种规范(方法)，让其它类去实现这些方法</strong></li></ul></li><li><p>接口比继承更加灵活，继承是满足 is -a的关系，而接口只需满足 like-a的关系</p></li><li><p>接口在一定程度上实现代码解耦</p></li></ul><h4 id="接口类型数组"><a href="#接口类型数组" class="headerlink" title="接口类型数组"></a><strong>接口类型数组</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class InterfacePolyArr &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //多态数组 -&gt; 接口类型数组</span><br><span class="line">        Usb[] usbs = new Usb[2];</span><br><span class="line">        usbs[0] = new Phone_();</span><br><span class="line">        usbs[1] = new Camera_();</span><br><span class="line">        /*</span><br><span class="line">        给Usb数组中，存放 Phone 和 相机对象，Phone类还有一个特有的方法call（），</span><br><span class="line">        请遍历Usb数组，如果是Phone对象，除了调用Usb 接口定义的方法外，</span><br><span class="line">        还需要调用Phone 特有方法 call</span><br><span class="line">         */</span><br><span class="line">        for(int i = 0; i &lt; usbs.length; i++) &#123;</span><br><span class="line">            usbs[i].work();//动态绑定..</span><br><span class="line">            //和前面一样，我们仍然需要进行类型的向下转型</span><br><span class="line">            if(usbs[i] instanceof Phone_) &#123;//判断他的运行类型是 Phone_</span><br><span class="line">                ((Phone_) usbs[i]).call();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Usb&#123;</span><br><span class="line">    void work();</span><br><span class="line">&#125;</span><br><span class="line">class Phone_ implements Usb &#123;</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;手机可以打电话...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;手机工作中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Camera_ implements Usb &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;相机工作中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类⭐️"><a href="#内部类⭐️" class="headerlink" title="内部类⭐️"></a>内部类⭐️</h3><h4 id="基本介绍-22"><a href="#基本介绍-22" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)</li><li>内部类最大的特点就是<strong>可以直接访问私有属性</strong>，井且可以<strong>体现类与类之间的包含关系</strong></li></ul><h4 id="基本语法-9"><a href="#基本语法-9" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;//外部类</span><br><span class="line">  class Inner&#123;//内部类</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other&#123;//外部其他类</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h4><ul><li>定义在外部类局部位置上<ul><li>局部类内部(有类名)</li><li>匿名局部类(没有类名⭐️)</li></ul></li><li>定义在外部类的成员位置上<ul><li>成员内部类(无static修饰)</li><li>静态内部类(static修饰)</li></ul></li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a><strong>局部内部类</strong></h4><h5 id="基本介绍-23"><a href="#基本介绍-23" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul><li>局部内部类是定义在外部类的局部位置，在方法中、代码块中，并且有类名</li></ul><h5 id="注意事项和细节-25"><a href="#注意事项和细节-25" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>可以直接访问外部类的所有成员，包含私有的 </li><li>不能添加访问修饰符,但是可以使用final修饰 </li><li>作用域：仅仅在定义它的方法或代码块中 </li><li>内部类访问外部类：直接访问 </li><li>外部类访问内部类：创建对象再访问 </li><li>外部其他类访问局部内部类：不能访问 </li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果访问外部类的成员使用”外部类名.this.成员”去访问</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInnerClass &#123;//</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //演示一遍</span><br><span class="line">        Outer02 outer02 = new Outer02();</span><br><span class="line">        outer02.m1();</span><br><span class="line">        System.out.println(&quot;outer02的hashcode=&quot; + outer02);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Outer02 &#123;//外部类</span><br><span class="line">    private int n1 = 100;</span><br><span class="line"></span><br><span class="line">    private void m2() &#123;</span><br><span class="line">        System.out.println(&quot;Outer02 m2()&quot;);</span><br><span class="line">    &#125;//私有方法</span><br><span class="line"></span><br><span class="line">    public void m1() &#123;//方法</span><br><span class="line">        //1.局部内部类是定义在外部类的局部位置,通常在方法</span><br><span class="line">        //3.不能添加访问修饰符,但是可以使用final 修饰</span><br><span class="line">        //4.作用域 : 仅仅在定义它的方法或代码块中</span><br><span class="line">        final class Inner02 &#123;//局部内部类(本质仍然是一个类)</span><br><span class="line">            //2.可以直接访问外部类的所有成员，包含私有的</span><br><span class="line">            private int n1 = 800;</span><br><span class="line"></span><br><span class="line">            public void f1() &#123;</span><br><span class="line">                //5. 局部内部类可以直接访问外部类的成员，比如下面 外部类n1 和 m2()</span><br><span class="line">                //7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，</span><br><span class="line">                //   使用 外部类名.this.成员)去访问</span><br><span class="line">                //    Outer02.this 本质就是外部类的对象, 即哪个对象调用了m1, Outer02.this就是哪个对象</span><br><span class="line">                System.out.println(&quot;n1=&quot; + n1 + &quot; 外部类的n1=&quot; + Outer02.this.n1);</span><br><span class="line">                System.out.println(&quot;Outer02.this hashcode=&quot; + Outer02.this);</span><br><span class="line">                m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //6. 外部类在方法中，可以创建Inner02对象，然后调用方法即可</span><br><span class="line">        Inner02 inner02 = new Inner02();</span><br><span class="line">        inner02.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类⭐️⭐️"><a href="#匿名内部类⭐️⭐️" class="headerlink" title="匿名内部类⭐️⭐️"></a><strong>匿名内部类⭐️⭐️</strong></h4><h5 id="基本介绍-24"><a href="#基本介绍-24" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul><li>匿名内部类是定义在外部类的局部位置，比如方法中，<strong>并目没有类名</strong>，同时还是一个对象</li></ul><h5 id="基本语法-10"><a href="#基本语法-10" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类或接口(参数列表)&#123;</span><br><span class="line">  类体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="底层"><a href="#底层" class="headerlink" title="底层"></a><strong>底层</strong></h5><ul><li>本质： IA tiger &#x3D; class Xxxx$1    class Xxxx$1 &#x3D; new IA</li><li>接口的底层：class Xxxx$1 implement IA{@Overide}</li><li>本质： Father father &#x3D; class Xxxx$2    class Xxxx$2 &#x3D; new Father</li><li>类的底层：class Xxxx$2 extends Father{@Overide}</li></ul><h5 id="注意事项和细节-26"><a href="#注意事项和细节-26" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>匿名内部类既是一个类的定义同时本身也是一个对象,因此从语法上看，它既有定义类的特征，也有创建对象的特征 </li><li>可以直接访问外部类的所有成员，包含私有的 </li><li>不能添加访问修饰符,因为它的地位就是一个局部变量 </li><li>作用域：仅仅在定义它的方法或代码块中 </li><li>匿名内部类方位外部类成员：直接访问 </li><li><strong>外部其他类访问匿名内部类：不能访问</strong> </li><li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.this.成员)去访问</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class AnonymousInnerClass &#123;</span><br><span class="line"></span><br><span class="line">        //演示基于类的匿名内部类</span><br><span class="line">        //分析</span><br><span class="line">        //1. father编译类型 Father</span><br><span class="line">        //2. father运行类型 Outer04$2</span><br><span class="line">        //3. 底层会创建匿名内部类</span><br><span class="line">        /*</span><br><span class="line">            class Outer04$2 extends Father&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void test() &#123;</span><br><span class="line">                    System.out.println(&quot;匿名内部类重写了test方法&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">        //4. 同时也直接返回了 匿名内部类 Outer04$2的对象</span><br><span class="line">        //5. 注意(&quot;jack&quot;) 参数列表会传递给 构造器</span><br><span class="line">        Father father = new Father(&quot;jack&quot;)&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void test() &#123;</span><br><span class="line">                System.out.println(&quot;匿名内部类重写了test方法&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(&quot;father对象的运行类型=&quot; + father.getClass());//Outer04$2</span><br><span class="line">        father.test();</span><br><span class="line"></span><br><span class="line">        //基于抽象类的匿名内部类</span><br><span class="line">        Animal animal = new Animal()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            void eat() &#123;</span><br><span class="line">                System.out.println(&quot;小狗吃骨头...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IA &#123;//接口</span><br><span class="line">    public void cry();</span><br><span class="line">&#125;</span><br><span class="line">//class Tiger implements IA &#123;</span><br><span class="line">//</span><br><span class="line">//    @Override</span><br><span class="line">//    public void cry() &#123;</span><br><span class="line">//        System.out.println(&quot;老虎叫唤...&quot;);</span><br><span class="line">//    &#125;</span><br><span class="line">//&#125;</span><br><span class="line">//class Dog implements  IA&#123;</span><br><span class="line">//    @Override</span><br><span class="line">//    public void cry() &#123;</span><br><span class="line">//        System.out.println(&quot;小狗汪汪...&quot;);</span><br><span class="line">//    &#125;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">class Father &#123;//类</span><br><span class="line">    public Father(String name) &#123;//构造器</span><br><span class="line">        System.out.println(&quot;接收到name=&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">    public void test() &#123;//方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Animal &#123; //抽象类</span><br><span class="line">    abstract void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><strong>成员内部类</strong></h4><h5 id="基本介绍-25"><a href="#基本介绍-25" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li>成员内部类是定义在外部类的成员位置，并且没有static修饰</li></ul><h5 id="注意事项和细节-27"><a href="#注意事项和细节-27" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li><p>可以直接访问外部类的所有成员，包含私有的 </p></li><li><p>可以添加任意访问修饰符 </p></li><li><p>作用域：为整个外部类类体 </p></li><li><p>成员内部类访问外部类：直接访问 </p></li><li><p>外部类访问成员内部类；创建对象，再访问 </p></li><li><p>外部其他类访问成员内部类 </p><ul><li><p>外部类.内部类  引用名 &#x3D; 外部对象.new 内部类(); </p></li><li><p>外部类.内部类  引用名 &#x3D; <strong>外部对象</strong>.get();</p></li></ul></li><li><p>如果外部类和成员内部类的成员重名时，成员内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.this.成员)去访问</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MemberInnerClass01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer08 outer08 = new Outer08();</span><br><span class="line">        outer08.t1();</span><br><span class="line"></span><br><span class="line">        //外部其他类，使用成员内部类的三种方式</span><br><span class="line">        //</span><br><span class="line">        // 第一种方式</span><br><span class="line">        // outer08.new Inner08(); 相当于把 new Inner08()当做是outer08成员</span><br><span class="line">        // 这就是一个语法，不要特别的纠结.</span><br><span class="line">        Outer08.Inner08 inner08 = outer08.new Inner08();</span><br><span class="line">        inner08.say();</span><br><span class="line">        // 第二方式 在外部类中，编写一个方法，可以返回 Inner08对象</span><br><span class="line">        Outer08.Inner08 inner08Instance = outer08.getInner08Instance();</span><br><span class="line">        inner08Instance.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer08 &#123; //外部类</span><br><span class="line">    private int n1 = 10;</span><br><span class="line">    public String name = &quot;张三&quot;;</span><br><span class="line"></span><br><span class="line">    private void hi() &#123;</span><br><span class="line">        System.out.println(&quot;hi()方法...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.注意: 成员内部类，是定义在外部内的成员位置上</span><br><span class="line">    //2.可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员</span><br><span class="line">    public class Inner08 &#123;//成员内部类</span><br><span class="line">        private double sal = 99.8;</span><br><span class="line">        private int n1 = 66;</span><br><span class="line"></span><br><span class="line">        public void say() &#123;</span><br><span class="line">            //可以直接访问外部类的所有成员，包含私有的</span><br><span class="line">            //如果成员内部类的成员和外部类的成员重名，会遵守就近原则.</span><br><span class="line">            //，可以通过  外部类名.this.属性 来访问外部类的成员</span><br><span class="line">            System.out.println(&quot;n1 = &quot; + n1 + &quot; name = &quot; + name + &quot; 外部类的n1=&quot; + Outer08.this.n1);</span><br><span class="line">            hi();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方法，返回一个Inner08实例</span><br><span class="line">    public Inner08 getInner08Instance() &#123;</span><br><span class="line">        return new Inner08();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //写方法</span><br><span class="line">    public void t1() &#123;</span><br><span class="line">        //使用成员内部类</span><br><span class="line">        //创建成员内部类的对象，然后使用相关的方法</span><br><span class="line">        Inner08 inner08 = new Inner08();</span><br><span class="line">        inner08.say();</span><br><span class="line">        System.out.println(inner08.sal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><strong>静态内部类</strong></h4><h5 id="基本介绍-26"><a href="#基本介绍-26" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul><li>静态内部类是定义在外部类的成员位置，并且有 static 修饰</li></ul><h5 id="注意事项和细节-28"><a href="#注意事项和细节-28" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员 </li><li>可以添加任意访问修饰符 </li><li>作用域：整个外部类类体 </li><li>静态内部类访问外部类：直接访问 </li><li>外部类访问静态内部类：创建对象，再访问 </li><li>外部其他类访问静态内部类： <ul><li>外部类.内部类  引用名 &#x3D; new 外部类.内部类(); </li><li>外部类.内部类  引用名 &#x3D; <strong>外部对象</strong>.get(); </li><li>外部类.内部类  引用名 &#x3D; <strong>外部类</strong>.get();</li></ul></li><li>如果外部类和静态内部类的成员重名时，静态内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.this.成员)去访问</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class StaticInnerClass01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer10 outer10 = new Outer10();</span><br><span class="line">        outer10.m1();</span><br><span class="line"></span><br><span class="line">        //外部其他类 使用静态内部类</span><br><span class="line">        //方式1</span><br><span class="line">        //因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)</span><br><span class="line">        Outer10.Inner10 inner10 = new Outer10.Inner10();</span><br><span class="line">        inner10.say();</span><br><span class="line">        //方式2</span><br><span class="line">        //编写一个方法，可以返回静态内部类的对象实例.</span><br><span class="line">        Outer10.Inner10 inner101 = outer10.getInner10();</span><br><span class="line">        System.out.println(&quot;============&quot;);</span><br><span class="line">        inner101.say();</span><br><span class="line"></span><br><span class="line">        Outer10.Inner10 inner10_ = Outer10.getInner10_();</span><br><span class="line">        System.out.println(&quot;************&quot;);</span><br><span class="line">        inner10_.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer10 &#123; //外部类</span><br><span class="line">    private int n1 = 10;</span><br><span class="line">    private static String name = &quot;张三&quot;;</span><br><span class="line">    private static void cry() &#123;&#125;</span><br><span class="line">    //Inner10就是静态内部类</span><br><span class="line">    //1. 放在外部类的成员位置</span><br><span class="line">    //2. 使用static 修饰</span><br><span class="line">    //3. 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</span><br><span class="line">    //4. 可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员</span><br><span class="line">    //5. 作用域 ：同其他的成员，为整个类体</span><br><span class="line">    static class Inner10 &#123;</span><br><span class="line">        private static String name = &quot;韩顺平教育&quot;;</span><br><span class="line">        public void say() &#123;</span><br><span class="line">            //如果外部类和静态内部类的成员重名时，静态内部类访问的时，</span><br><span class="line">            //默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.成员)</span><br><span class="line">            System.out.println(name + &quot; 外部类name= &quot; + Outer10.name);</span><br><span class="line">            cry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void m1() &#123; //外部类---访问------&gt;静态内部类 访问方式：创建对象，再访问</span><br><span class="line">        Inner10 inner10 = new Inner10();</span><br><span class="line">        inner10.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Inner10 getInner10() &#123;</span><br><span class="line">        return new Inner10();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Inner10 getInner10_() &#123;</span><br><span class="line">        return new Inner10();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="类加载顺序⭐️⭐️"><a href="#类加载顺序⭐️⭐️" class="headerlink" title="类加载顺序⭐️⭐️"></a><strong>类加载顺序⭐️⭐️</strong></h3><h4 id="类什么时候被加载"><a href="#类什么时候被加载" class="headerlink" title="类什么时候被加载"></a>类什么时候被加载</h4><ul><li><p>创建对象实例时</p></li><li><p>创建子类对象实例时，父类也会被加载</p></li><li><p>使用类的静态成员时</p></li></ul><h4 id="创建一个对象时，在一个类的调用顺序"><a href="#创建一个对象时，在一个类的调用顺序" class="headerlink" title="创建一个对象时，在一个类的调用顺序"></a>创建一个对象时，在一个类的调用顺序</h4><ul><li><p>调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级样，如果有多个静态代码块和多个静 态变量初始化，则按他们定义的顺序调 </p></li><li><p>调用普通代码块和普通属性的初始化(注意：普通代码块和普通属性初始化调用的优先级一样，若果有多个普通代码块和多个普通属性初始化，则按定义顺序调用) </p></li><li><p>调用构造方法</p></li></ul><h4 id="创建子类时顺序"><a href="#创建子类时顺序" class="headerlink" title="创建子类时顺序"></a>创建子类时顺序</h4><ul><li><p>父类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p></li><li><p>子类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p></li><li><p>父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p></li><li><p>父类构造方法</p></li><li><p>子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p></li><li><p>子类构造方法</p></li></ul><h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a><strong>枚举和注解</strong></h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="基本介绍-27"><a href="#基本介绍-27" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>枚举是一组常量的集合，属于一种特殊的类，里面只包含一组有限的特定的对象</li></ul><h3 id="定义类实现枚举"><a href="#定义类实现枚举" class="headerlink" title="定义类实现枚举"></a><strong>定义类实现枚举</strong></h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>构造器私有化<br>本类内部创建一组对象</li><li>对外暴露对象(通过为对象添加public final static修饰符)</li><li>提供get方法，但是不提供set方法</li></ul><h4 id="注意事项和细节-29"><a href="#注意事项和细节-29" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>不需要提供setxxx 方法，因为<strong>枚举对象值通常为只读</strong></li><li>枚举对象&#x2F;属性使用 final + static 共同修饰，实现底层优化</li><li>枚举对象名通常使用全部大写，常量的命名规范</li><li>枚举对象根据需要，也可以有多个属性</li></ul><h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a><strong>enum关键字实现枚举</strong></h3><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h4><ul><li>关键字 enum 代替 class </li><li>行首：常量名(实参列表)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Season &#123;</span><br><span class="line">    SPRING(&quot;春天&quot;,&quot;温暖&quot;),WINTER(&quot;冬天&quot;,&quot;寒冷&quot;);</span><br><span class="line">  </span><br><span class="line">    private String name;</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    private Season(String name, String desc) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项和细节-30"><a href="#注意事项和细节-30" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类 </p></li><li><p>传统的 public static final Season SPRING &#x3D; new Season(“春天””温暖”)； 简化成 SPRING(“春天”，”温暖”)，我们必须知道它调用的是哪个构造器 </p></li><li><p>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略 </p></li><li><p>多个枚举对象，使用,间隔，最后;结尾 </p></li><li><p>枚举对象必须放在枚举类行首</p></li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><p>toString：Enum类己经重写过了，返回的是当前对象名子类可以重写该方法，用于返回对象的属性信息 </p></li><li><p>name：返回当前对象名(常量名)，子类中不能重写 </p></li><li><p>ordinal：返回当前对象的位置号，默认从0开始 </p></li><li><p>values：返回当前枚举类中所有的常量 </p></li><li><p>valueof：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常 </p></li><li><p>compareTo：比较两个枚举常量的编号，做差</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class EnumMethod &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //使用Season2 枚举类，来演示各种方法</span><br><span class="line">        Season2 autumn = Season2.AUTUMN;</span><br><span class="line"></span><br><span class="line">        //输出枚举对象的名字</span><br><span class="line">        System.out.println(autumn.name());</span><br><span class="line">        //ordinal() 输出的是该枚举对象的次序/编号，从0开始编号</span><br><span class="line">        //AUTUMN 枚举对象是第三个，因此输出 2</span><br><span class="line">        System.out.println(autumn.ordinal());</span><br><span class="line">        //从反编译可以看出 values方法，返回 Season2[]</span><br><span class="line">        //含有定义的所有枚举对象</span><br><span class="line">        Season2[] values = Season2.values();</span><br><span class="line">        System.out.println(&quot;===遍历取出枚举对象(增强for)====&quot;);</span><br><span class="line">        for (Season2 season: values) &#123;//增强for循环</span><br><span class="line">            System.out.println(season);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //valueOf：将字符串转换成枚举对象，要求字符串必须␋为已有的常量名，否则报异常</span><br><span class="line">        //执行流程</span><br><span class="line">        //1. 根据你输入的 &quot;AUTUMN&quot; 到 Season2的枚举对象去查找</span><br><span class="line">        //2. 如果找到了，就返回，如果没有找到，就报错</span><br><span class="line">        Season2 autumn1 = Season2.valueOf(&quot;AUTUMN&quot;);</span><br><span class="line">        System.out.println(&quot;autumn1=&quot; + autumn1);</span><br><span class="line">        System.out.println(autumn == autumn1);</span><br><span class="line"></span><br><span class="line">        //compareTo：比较两个枚举常量，比较的就是编号</span><br><span class="line">        //</span><br><span class="line">        //1. 就是把 Season2.AUTUMN 枚举对象的编号 和 Season2.SUMMER枚举对象的编号比较</span><br><span class="line">        //2. 看看结果</span><br><span class="line">        /*</span><br><span class="line">        public final int compareTo(E o) &#123;</span><br><span class="line"></span><br><span class="line">            return self.ordinal - other.ordinal;</span><br><span class="line">        &#125;</span><br><span class="line">        Season2.AUTUMN的编号[2] - Season2.SUMMER的编号[3]</span><br><span class="line">         */</span><br><span class="line">        System.out.println(Season2.AUTUMN.compareTo(Season2.SUMMER));</span><br><span class="line"></span><br><span class="line">        //补充了一个增强for</span><br><span class="line">//        int[] nums = &#123;1, 2, 9&#125;;</span><br><span class="line">//        //普通的for循环</span><br><span class="line">//        System.out.println(&quot;=====普通的for=====&quot;);</span><br><span class="line">//        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">//            System.out.println(nums[i]);</span><br><span class="line">//        &#125;</span><br><span class="line">//        System.out.println(&quot;=====增强的for=====&quot;);</span><br><span class="line">//        //执行流程是 依次从nums数组中取出数据，赋给i, 如果取出完毕，则退出for</span><br><span class="line">//        for(int i : nums) &#123;</span><br><span class="line">//            System.out.println(&quot;i=&quot; + i);</span><br><span class="line">//        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><ul><li>使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制</li><li>枚举类和普通类一样，可以实现接口：enum 类名 implements 接口1，接口2{}</li></ul><h3 id="JDk内置的基本注解类型"><a href="#JDk内置的基本注解类型" class="headerlink" title="JDk内置的基本注解类型"></a><strong>JDk内置的基本注解类型</strong></h3><h4 id="基本介绍-28"><a href="#基本介绍-28" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包,类、方法、属性、构造器、局部变量等数据信息 </li><li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息 </li><li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版本中所有遗留的繁冗代码和XML配置</li></ul><h4 id="基本Annotation介绍"><a href="#基本Annotation介绍" class="headerlink" title="基本Annotation介绍"></a>基本Annotation介绍</h4><ul><li>@Override： 限定某个方法，是重写父类方法，该注解只能用于方法 </li><li>@Deprecated：用于表示某个程序元素(类，方法等)己过时 </li><li>@SuppressWarnings：抑制编译器警告</li></ul><h4 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h4><h5 id=""><a href="#" class="headerlink" title=""></a></h5><ul><li>Override表示指定重写父类的方法(从编译层面验证)，如果父类没有方法，则会报错 </li><li>如果没写 Override还是会重写父类  </li><li>Override只能修饰方法，不能修饰其它类，包，属性等等  </li><li>如果写了Override注解，编译器就会去检查该方法是否真的重写了父类的方法，若果没有构成重写则编译错误  </li><li>查看@Override注解源码@Target(ElementType.MRTHOD)，说明只能修饰方法<br>@Target是修饰注解的注解，称为元注解</li></ul><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><ul><li>用于表示某个程序元素(类，方法等)己过时 </li><li>可以修饰方法，类，字段，包，参数 等等 </li><li>@Target(value&#x3D;(CONSTRUCTOR,FIELD,LOCAL_ VARIABLE, METHOD,PACKAGE, PARAMETER, TYPE})  </li><li>@Deprecated 的作用可以做到新旧版本的兼容和过渡</li></ul><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><ul><li>抑制编译器警告信息 </li><li>unchecked 是忽略没有检查的警告 </li><li>rawtypes 是忽略没有指定泛型的警告 </li><li>unused 是忽略没有使用某个变量的警告错误 </li><li>@SuppressWarnings 可以修饰的程序元素为，查看 @Target</li><li>生成 @SupperssWarnings  时，不用背，直接点击左侧的黄色提示，就可以选择(注意可以指定生成的位置)</li></ul><h3 id="元注解：对注解进行注解"><a href="#元注解：对注解进行注解" class="headerlink" title="元注解：对注解进行注解"></a>元注解：对注解进行注解</h3><h4 id="基本介绍-29"><a href="#基本介绍-29" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>JDK 的元 Annotation 用于修饰其他 Annotation</li></ul><h4 id="四种元注解"><a href="#四种元注解" class="headerlink" title="四种元注解"></a>四种元注解</h4><ul><li><p>Retention：指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</p></li><li><p>Target：指定注解可以在哪些地方使用</p></li><li><p>Documented：指定该注解是否会在 javadoc 体现</p></li><li><p>lnherited：子类会继承父类注解</p></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h2><h3 id="基本介绍-30"><a href="#基本介绍-30" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h3><ul><li>Java语言中，将程序执行中发生的不正常情况称为 “异常”</li></ul><h3 id="执行中异常事件分类"><a href="#执行中异常事件分类" class="headerlink" title="执行中异常事件分类"></a>执行中异常事件分类</h3><ul><li>Error(错误)：Java虚拟机无法解决的严重问题<ul><li>如：JVM系统内部错误、资源耗尽等严重情況<ul><li>比如：StackoverflowError[栈溢出]和OOM(out ofmemory)，Error 是严重错误，程序会崩溃</li></ul></li></ul></li><li>Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理<ul><li>例如空指针访问， 试图读取不存在的文件，网络连接中断等等</li><li>Exception 分为两大类<ul><li>运行时异常</li><li>编译时异常</li></ul></li></ul></li></ul><h3 id="异常体系图⭐️"><a href="#异常体系图⭐️" class="headerlink" title="异常体系图⭐️"></a><strong>异常体系图⭐️</strong></h3><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071837830.png" alt="image-20221007183718691"></p><h4 id="注意事项和细节-31"><a href="#注意事项和细节-31" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>异常分为两大类</p><ul><li>运行时异常</li><li>编译时异常</li></ul></li><li><p>运行时异常</p><ul><li><p>编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常</p></li><li><p>可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</p></li></ul></li><li><p>编译时异常</p><ul><li><strong>编译器要求必须处置的异常</strong></li></ul></li></ul><h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a><strong>常见的异常</strong></h3><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><ul><li><p>NullPointerException：空指针异常 </p></li><li><p>ArithmeticException：数学运算异常 </p></li><li><p>ArrayIndexOutOfBoundsException：数组下标越界异常 </p></li><li><p>ClassCastException：类型转换异常 </p></li><li><p>NumberFormatException：数字格式不正确异常</p></li></ul><h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><ul><li><p>SQLException：操作数据库时，查询表可能发生异常 </p></li><li><p>lOException：操作文供时，发生的异常 </p></li><li><p>FileNotFoundException：当操作一个不存在的文件时，发生异常 </p></li><li><p>ClassNotFoundException：加载类，而该类不存在时异常 </p></li><li><p>EOFException：操作文件，到文件末尾，发生异常 </p></li><li><p>illegalArguementException：参数异常</p></li></ul><h3 id="异常处理⭐️"><a href="#异常处理⭐️" class="headerlink" title="异常处理⭐️"></a>异常处理⭐️</h3><h4 id="基本介绍-31"><a href="#基本介绍-31" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>异常处理就是当异常发生时，对异常处理的方式</li></ul><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a><strong>try-catch-finally</strong></h4><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><strong>流程图</strong></h5><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071837034.png" alt="image-20221007183736843"></p><h5 id="注意事项和细节-32"><a href="#注意事项和细节-32" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块</li><li>如果异常没有发生，则顺序执行 try 的代码块，不会进入到 catch 块</li><li>如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)，则使用如下代码-finally{}</li><li>可以有多个 catch 语句，捕获不同的异常(进行不同的业务处理)，要求父类异常在后，子类异常在前，比如(Exception 在后，NullPointer Exception 在前)，如果发生异常，只会匹配一个 catch</li><li>try-finally 配合，相当于没有捕获异常，程序直接崩溃但执行 finally</li></ul><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a><strong>throws</strong></h4><h5 id="基本介绍-32"><a href="#基本介绍-32" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul><li>将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是 JVM，默认抛出运行异常</li></ul><h5 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a><strong>流程图</strong></h5><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071837925.png" alt="image-20221007183758706"></p><h5 id="注意事项和细节-33"><a href="#注意事项和细节-33" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>对于编译异常，程序中必须处理，比如 try-catch 或者 throws</li><li>对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理</li><li>子类重写父类的方法时，对抛出异常的规定：子类重与的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类拋出的异常的类型的子类型</li><li>在throws 过程中，如果有方法 try-catch，就相当于处理异常，就可以不必throws</li><li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a><strong>自定义异常</strong></h3><h4 id="基本介绍-33"><a href="#基本介绍-33" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>当程序中出现了某些 “错误〞，但该错误信息并没有在 Throwable 子类中描述处理，这时可以设计异常类，用于描达该错误信息</li></ul><h4 id="自定义异常步骤"><a href="#自定义异常步骤" class="headerlink" title="自定义异常步骤"></a>自定义异常步骤</h4><ul><li>定义类<ul><li>自定义异常类名(程序员自己写)继承Exception或Runtime Exception</li></ul></li><li>如果继承Exception，属于编译异常</li><li>如果继承RuntimeException，属子运行异常(一般来说，继承RuntimeException)</li></ul><h3 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a><strong>throw和throws</strong></h3><h4 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a><strong>对比</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071838515.png" alt="image-20221007183817378"></p><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a><strong>常用类</strong></h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a><strong>包装类</strong></h3><h4 id="基本介绍-34"><a href="#基本介绍-34" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul><li>八种基本数据类型相应的引用类型——包装类</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071838691.png" alt="image-20221007183850438"></p><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a><strong>装箱和拆箱</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Integer01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //演示int &lt;--&gt; Integer 的装箱和拆箱</span><br><span class="line">        //jdk5前是手动装箱和拆箱</span><br><span class="line">        //手动装箱 int-&gt;Integer</span><br><span class="line">        int n1 = 100;</span><br><span class="line">        Integer integer = new Integer(n1);</span><br><span class="line">        Integer integer1 = Integer.valueOf(n1);</span><br><span class="line"></span><br><span class="line">        //手动拆箱</span><br><span class="line">        //Integer -&gt; int</span><br><span class="line">        int i = integer.intValue();</span><br><span class="line"></span><br><span class="line">        //jdk5后，就可以自动装箱和自动拆箱</span><br><span class="line">        int n2 = 200;</span><br><span class="line">        //自动装箱 int-&gt;Integer</span><br><span class="line">        Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)</span><br><span class="line">        //自动拆箱 Integer-&gt;int</span><br><span class="line">        int n3 = integer2; //底层仍然使用的是 intValue()方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="包装类方法"><a href="#包装类方法" class="headerlink" title="包装类方法"></a><strong>包装类方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class WrapperVSString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //包装类(Integer)-&gt;String</span><br><span class="line">        Integer i = 100;//自动装箱</span><br><span class="line">        //方式1</span><br><span class="line">        String str1 = i + &quot;&quot;;</span><br><span class="line">        //方式2</span><br><span class="line">        String str2 = i.toString();</span><br><span class="line">        //方式3</span><br><span class="line">        String str3 = String.valueOf(i);</span><br><span class="line"></span><br><span class="line">        //String -&gt; 包装类(Integer)</span><br><span class="line">        String str4 = &quot;12345&quot;;</span><br><span class="line">        Integer i2 = Integer.parseInt(str4);//使用到自动装箱</span><br><span class="line">        Integer i3 = new Integer(str4);//构造器</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;ok~~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Integer创建机制"><a href="#Integer创建机制" class="headerlink" title="Integer创建机制"></a><strong>Integer创建机制</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class WrapperExercise03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //示例一</span><br><span class="line">        Integer i1 = new Integer(127);</span><br><span class="line">        Integer i2 = new Integer(127);</span><br><span class="line">        System.out.println(i1 == i2);//F</span><br><span class="line">//示例二</span><br><span class="line">        Integer i3 = new Integer(128);</span><br><span class="line">        Integer i4 = new Integer(128);</span><br><span class="line">        System.out.println(i3 == i4);//F</span><br><span class="line"></span><br><span class="line">//示例三</span><br><span class="line">        Integer i5 = 127;//底层Integer.valueOf(127)</span><br><span class="line">        Integer i6 = 127;//-128~127</span><br><span class="line">        System.out.println(i5 == i6); //T</span><br><span class="line">//示例四</span><br><span class="line">        Integer i7 = 128;</span><br><span class="line">        Integer i8 = 128;</span><br><span class="line">        System.out.println(i7 == i8);//F</span><br><span class="line">//示例五</span><br><span class="line">        Integer i9 = 127; //Integer.valueOf(127)</span><br><span class="line">        Integer i10 = new Integer(127);</span><br><span class="line">        System.out.println(i9 == i10);//F</span><br><span class="line"></span><br><span class="line">        //示例六</span><br><span class="line">        Integer i11=127;</span><br><span class="line">        int i12=127;</span><br><span class="line">//只有有基本数据类型，判断的是</span><br><span class="line">//值是否相同</span><br><span class="line">        System.out.println(i11==i12); //T</span><br><span class="line">//示例七</span><br><span class="line">        Integer i13=128;</span><br><span class="line">        int i14=128;</span><br><span class="line">        System.out.println(i13==i14);//T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String⭐️"><a href="#String⭐️" class="headerlink" title="String⭐️"></a><strong>String⭐️</strong></h3><h4 id="基本介绍-35"><a href="#基本介绍-35" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>String 对象用于保存字符串，也就是一组字符序列 </li><li>字符串常量对象是用<strong>双引号</strong>括起的字符序列 </li><li>宇符串的宇符使用 Unicode 宇符编码，一个字符(不区分字母还是汉字)占两个字节</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071840344.png" alt="image-20221007184047207"></p><h4 id="创建String对象方式"><a href="#创建String对象方式" class="headerlink" title="创建String对象方式"></a>创建String对象方式</h4><ul><li><p>直接赋值 String s &#x3D; “hsp”;</p></li><li><p>调用构造器 String s2 &#x3D; new String(“hsp”);</p></li></ul><h5 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a>两种方式对比</h5><ul><li><p>方式一：先从常量池查看是否有”hsp”数据空间，如果有，直接指向； 如果沒有则重新创建，然后植自。s最终指向的是常量池的空间地址 </p></li><li><p>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的 hsp 空间。如果常量池没有”hsp’，重新创建，如果有，直接通过 value 指向，最终指向的是堆中的空间地址</p></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071842968.png" alt="image-20221007184253786"></p><h4 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h4><ul><li><p>String s1 &#x3D; new String(); </p></li><li><p>String s2 &#x3D; new String (String original); </p></li><li><p>String s3 &#x3D; new String (char[] a); </p></li><li><p>String s4 &#x3D; new String (char[] a,int startIndex,int count);</p></li></ul><h4 id="注意事项和细节-34"><a href="#注意事项和细节-34" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>String 是 final 类，不能被继承</p></li><li><p>string 有属性 private final char valve []; 用于存放字符串内容</p></li><li><p><strong>value 是一个 final 类型，不可以修改(值可以修改，地址不可修改)</strong></p></li><li><p>intern 方法：返回常量池的地址对象</p></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071845020.png" alt="image-20221007184518582"></p><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071845452.png" alt="image-20221007184533176"></p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><h5 id="相等特性"><a href="#相等特性" class="headerlink" title="相等特性"></a>相等特性</h5><ul><li>equals判断内容</li><li>&#x3D;&#x3D;判断地址</li></ul><h5 id="字符串特性"><a href="#字符串特性" class="headerlink" title="字符串特性"></a>字符串特性</h5><ul><li>String c1 &#x3D;“ab”+”cd”;<ul><li>常量在池中相加</li></ul></li><li>String c1 &#x3D; a + b;<ul><li>变量在堆中相加</li></ul></li></ul><p>使用例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StringExercise03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = &quot;hsp&quot;; //a 指向 常量池的 “hsp”</span><br><span class="line">        String b =new String(&quot;hsp&quot;);//b 指向堆中对象</span><br><span class="line">        System.out.println(a.equals(b)); //T</span><br><span class="line">        System.out.println(a==b); //F</span><br><span class="line">        //b.intern() 方法返回常量池地址</span><br><span class="line">        System.out.println(a==b.intern()); //T //ntern方法：返回常量池的地址对象</span><br><span class="line">        System.out.println(b==b.intern()); //F</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StringExercise09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = &quot;hspedu&quot;;  //s1 指向池中的 “hspedu”</span><br><span class="line">        String s2 = &quot;java&quot;; // s2 指向池中的 “java”</span><br><span class="line">        String s5 = &quot;hspedujava&quot;; //s5 指向池中的 “hspedujava”</span><br><span class="line">        String s6 = (s1 + s2).intern();//s6 指向池中的   “hspedujava”</span><br><span class="line">        System.out.println(s5 == s6); //T</span><br><span class="line">        System.out.println(s5.equals(s6));//T</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;hello&quot;;</span><br><span class="line">s1 = &quot;haha&quot;;</span><br><span class="line"></span><br><span class="line">//创建了两个对象，s1指向“hello”，</span><br><span class="line">//再在常量池中创建“haha”，s1指向&quot;haha“</span><br></pre></td></tr></table></figure><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>equals：区分大小写，判断内容是否相等 </li><li>equalslgnoreCase：忽略大小写的判断内容是否相等 </li><li>length：获取字符的个数，字符串的长度 </li><li>indexOf：获取字符在字符串中第1次出现的索引,索引从0开始，如果找不到,返回-1 </li><li>lastlndexOf：获取宇符在字符串中最后1次出现的索引,索引从0开始，如找不到,返回-1 </li><li>substring： 截取指定范围的子串 </li><li>trim：去前后空格 </li><li>charAt：获取某索引处的字符，注意不能使用Str[index]这种方式 </li><li>toUpperCase：大写字母 </li><li>toLowerCase：小写字母 </li><li>concat：拼接 </li><li>replace：替换字符串中的字符 </li><li>split：分割字符串 </li><li>compareTo：比较两个字符串的大小 </li><li>toCharArray：转换成字符数组 </li><li>format：格式字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//1. equals 前面已经讲过了. 比较内容是否相同，区分大小写</span><br><span class="line">        String str1 = &quot;hello&quot;;</span><br><span class="line">        String str2 = &quot;Hello&quot;;</span><br><span class="line">        System.out.println(str1.equals(str2));//</span><br><span class="line"></span><br><span class="line">        // 2.equalsIgnoreCase 忽略大小写的判断内容是否相等</span><br><span class="line">        String username = &quot;johN&quot;;</span><br><span class="line">        if (&quot;john&quot;.equalsIgnoreCase(username)) &#123;</span><br><span class="line">            System.out.println(&quot;Success!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Failure!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3.length 获取字符的个数，字符串的长度</span><br><span class="line">        System.out.println(&quot;韩顺平&quot;.length());</span><br><span class="line"></span><br><span class="line">        // 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从0开始，如果找不到，返回-1</span><br><span class="line">        String s1 = &quot;wer@terwe@g&quot;;</span><br><span class="line">        int index = s1.indexOf(&#x27;@&#x27;);</span><br><span class="line">        System.out.println(index);// 3</span><br><span class="line">        System.out.println(&quot;weIndex=&quot; + s1.indexOf(&quot;we&quot;));//0</span><br><span class="line"></span><br><span class="line">        // 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1</span><br><span class="line">        s1 = &quot;wer@terwe@g@&quot;;</span><br><span class="line">        index = s1.lastIndexOf(&#x27;@&#x27;);</span><br><span class="line">        System.out.println(index);//11</span><br><span class="line">        System.out.println(&quot;ter的位置=&quot; + s1.lastIndexOf(&quot;ter&quot;));//4</span><br><span class="line"></span><br><span class="line">        // 6.substring 截取指定范围的子串</span><br><span class="line">        String name = &quot;hello,张三&quot;;</span><br><span class="line">        //下面name.substring(6) 从索引6开始截取后面所有的内容</span><br><span class="line">        System.out.println(name.substring(6));//截取后面的字符</span><br><span class="line">        //name.substring(0,5)表示从索引0开始截取，截取到索引 5-1=4位置</span><br><span class="line">        System.out.println(name.substring(2,5));//llo</span><br></pre></td></tr></table></figure><h3 id="StringBuffer⭐️"><a href="#StringBuffer⭐️" class="headerlink" title="StringBuffer⭐️"></a>StringBuffer⭐️</h3><h4 id="基本介绍-36"><a href="#基本介绍-36" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>java.lang.StringBuffer 代表可变的字符序列，可以对字符串内容进行增删。</p></li><li><p>很多方法与 String 相同，但 StringBuffer 是可变长度的。</p></li><li><p>String Buffer 是一个容器。</p></li></ul><h4 id="注意事项和细节-35"><a href="#注意事项和细节-35" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><p>StringBuffer 的直接父类是 AbstractstringBuilder</p></li><li><p>StringBuffer 实现了 Serializable，即StringBuffer的对象可以串行化</p></li><li><p>在父类中 AbstractstringBuilder 有属性 char[] valve,不是final，该 valve 数组存放 宁符串内容，引出存放在堆中的</p></li><li><p>StringBuffer 是一个 final 类，不能被继承</p></li><li><p>StringBuffer 字符内容存在 char[] value，所以在变化〔增加&#x2F;删除)不用每次都更换地址(即不是每次创建新对象)</p></li></ul><h4 id="String和StringBuffer对比"><a href="#String和StringBuffer对比" class="headerlink" title="String和StringBuffer对比"></a>String和StringBuffer对比</h4><ul><li><p>String 保存的是宇符串常量，里面的值不能更改，每次 String 类的更新实际上就是更改地址</p></li><li><p>StringBuffer 保存的是字符串变量，里面的值可以更改，不用更新地址，效率高</p></li></ul><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a><strong>构造器</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1. 创建一个 大小为 16的 char[] ,用于存放字符内容</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line"></span><br><span class="line">//2 通过构造器指定 char[] 大小</span><br><span class="line">StringBuffer stringBuffer1 = new StringBuffer(100);</span><br><span class="line"></span><br><span class="line">//3. 通过 给一个String 创建 StringBuffer, char[] 大小就是 str.length() + 16</span><br><span class="line">StringBuffer hello = new StringBuffer(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><h4 id="String和StringBuffer转换"><a href="#String和StringBuffer转换" class="headerlink" title="String和StringBuffer转换"></a><strong>String和StringBuffer转换</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// String——&gt;StringBuffer</span><br><span class="line">String str = &quot;hello tom&quot;;</span><br><span class="line"></span><br><span class="line">//方式1 使用构造器</span><br><span class="line">//注意： 返回的才是StringBuffer对象，对str 本身没有影响</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer(str);</span><br><span class="line">//方式2 使用的是append方法</span><br><span class="line">StringBuffer stringBuffer1 = new StringBuffer();</span><br><span class="line">stringBuffer1 = stringBuffer1.append(str);</span><br><span class="line"></span><br><span class="line">// StringBuffer -&gt;String</span><br><span class="line">StringBuffer stringBuffer3 = new StringBuffer(&quot;韩顺平教育&quot;);</span><br><span class="line">//方式1 使用StringBuffer提供的 toString方法</span><br><span class="line">String s = stringBuffer3.toString();</span><br><span class="line">//方式2: 使用构造器来搞定</span><br><span class="line">String s1 = new String(stringBuffer3);</span><br></pre></td></tr></table></figure><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>增：append </li><li>删：delete(start,end) </li><li>改：replace (start,end,string) </li><li>查：indexOf </li><li>插：insert </li><li>获取长度：length</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer s = new StringBuffer(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">//增</span><br><span class="line">s.append(&#x27;,&#x27;);// &quot;hello,&quot;</span><br><span class="line">s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot;</span><br><span class="line">s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏100true10.5&quot;</span><br><span class="line">System.out.println(s);//&quot;hello,张三丰赵敏100true10.5&quot;</span><br><span class="line"></span><br><span class="line">//删</span><br><span class="line">/*</span><br><span class="line">* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span><br><span class="line">* : 删除 11~14的字符 [11, 14)</span><br><span class="line">*/</span><br><span class="line">s.delete(11, 14);</span><br><span class="line">System.out.println(s);//&quot;hello,张三丰赵敏true10.5&quot;</span><br><span class="line"></span><br><span class="line">//改</span><br><span class="line">//，使用 周芷若 替换 索引9-11的字符 [9,11)</span><br><span class="line">s.replace(9, 11, &quot;周芷若&quot;);</span><br><span class="line">System.out.println(s);//&quot;hello,张三丰周芷若true10.5&quot;</span><br><span class="line">//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1</span><br><span class="line">int indexOf = s.indexOf(&quot;张三丰&quot;);</span><br><span class="line">System.out.println(indexOf);//6</span><br><span class="line"></span><br><span class="line">//插</span><br><span class="line">//，在索引为9的位置插入 &quot;赵敏&quot;,原来索引为9的内容自动后移</span><br><span class="line">s.insert(9, &quot;赵敏&quot;);</span><br><span class="line">System.out.println(s);//&quot;hello,张三丰赵敏周芷若true10.5&quot;</span><br><span class="line"></span><br><span class="line">//长度</span><br><span class="line">System.out.println(s.length());//22</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><h4 id="StringBulider⭐️"><a href="#StringBulider⭐️" class="headerlink" title="StringBulider⭐️"></a>StringBulider⭐️</h4><h4 id="基本介绍-37"><a href="#基本介绍-37" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步，</li><li>该类被设计用作 String Buffer 的个简易替换，用在字符串缓冲区被单个线程使用的时候</li><li>如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer 快</li><li>在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据</li></ul><h4 id="注意事项和细节-36"><a href="#注意事项和细节-36" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>StringBuilder 继承 AbstractstringBuilder 类</li><li>实现了 Serializable，说明 StringBuilder 对象是可以串行化(对象可以网络传输，可以保存到文件)</li><li>StringBuilder 是 final 类，不能被继承</li><li>StringBuitder 对象字符序列仍然足存放在其父类 AbstractstringBuilder的 char [I valve;因此，字符序列是堆中</li><li>StringBoilder 的方法，没有做互斥的处理，即没有synchronized 关键字，此在单线程的情況下使用</li></ul><h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>和 StringBuffer 相同</li></ul><h4 id="三类对比"><a href="#三类对比" class="headerlink" title="三类对比"></a>三类对比</h4><ul><li><p>String：不可变字符序列，效率低,但是复用率高</p></li><li><p>StringBuffer：可变字符序列，效率较高(增删)，线程安全</p></li><li><p>String Builder：可变字符序列、效率最高、线程不安全</p></li><li><p>StringBuilder 和  StringBuffer 非常类似，均代表可变的字符序列，且方法相同</p></li><li><p>String使用注意说明：string s&#x3D;”a”;&#x2F;&#x2F;创建了一个字符串s+&#x3D;”b”;1&#x2F;实际上原来的”a”字符串对象已经丢奔了，现在又产生了一个字符串S+”b”(也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能</p></li></ul><h4 id="三类选择"><a href="#三类选择" class="headerlink" title="三类选择"></a>三类选择</h4><ul><li><p>如果宇符串存在大量的修改操作，一般使用 StringBuffer 或StringBuilder</p></li><li><p>如果字符串存在大量的修改操作，并在单线程的情況，使用 StringBuilder</p></li><li><p>如果字符串存在大量的修改操作，并在多线程的情况，使用 String Buffer</p></li><li><p>如果我们字符串很少修改，被多个对象引用，使用String</p></li></ul><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><h4 id="基本介绍-38"><a href="#基本介绍-38" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数，均为静态方法</li></ul><h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><p>abs：绝对值</p></li><li><p>pow：求幂</p></li><li><p>ceil：向上取整</p></li><li><p>floor：向下取整</p></li><li><p>round：四舍五入</p></li><li><p>sqrt：求开方</p></li><li><p>random：求随机数</p></li><li><p>max：求两个数的最大值</p></li><li><p>min：求两个数的最小值</p></li></ul><h3 id="Date、Calenda、LocalDate"><a href="#Date、Calenda、LocalDate" class="headerlink" title="Date、Calenda、LocalDate"></a>Date、Calenda、LocalDate</h3><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><h5 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h5><ul><li><p>Date：精确到毫秒，代表特定时间 </p></li><li><p>Simple Date Format：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类 它允许进行格式化（日期一＞文本）解析（文本-＞日期）和规范化</p></li></ul><h4 id="Calenda"><a href="#Calenda" class="headerlink" title="Calenda"></a>Calenda</h4><h5 id="基本介绍-39"><a href="#基本介绍-39" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li>是一个抽象类，并且构造器是 private，可以通过 getInstance() 来获得实例，提供大量的方法和字段</li></ul><h5 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h5><ul><li><p>getInstance()：获取实例</p></li><li><p>get.XXXX：获取字段</p></li></ul><h4 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h4><h5 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h5><ul><li><p>LocalDateTime ldt &#x3D; LocalDateTime.now()</p><ul><li>获取时间</li></ul></li><li><p>get.Xxxx()</p><ul><li>获取字段</li></ul></li><li><p>DateTimeFormatter.format()</p><ul><li>格式化</li></ul></li><li><p>DateTimeFormatter.ofPattern()</p><ul><li>定制格式化</li></ul></li><li><p>Date date &#x3D; Date.from(instant);</p><ul><li>Instant转换Date</li></ul></li><li><p>Instant instant &#x3D; date.tolnstant();</p><ul><li>Date转换Instant</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//1. 使用now() 返回表示当前日期时间的 对象</span><br><span class="line">LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()</span><br><span class="line">System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">//2. 使用DateTimeFormatter 对象来进行格式化</span><br><span class="line">// 创建 DateTimeFormatter对象</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">String format = dateTimeFormatter.format(ldt);</span><br><span class="line">System.out.println(&quot;格式化的日期=&quot; + format);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;年=&quot; + ldt.getYear());</span><br><span class="line">System.out.println(&quot;月=&quot; + ldt.getMonth());</span><br><span class="line">System.out.println(&quot;月=&quot; + ldt.getMonthValue());</span><br><span class="line">System.out.println(&quot;日=&quot; + ldt.getDayOfMonth());</span><br><span class="line">System.out.println(&quot;时=&quot; + ldt.getHour());</span><br><span class="line">System.out.println(&quot;分=&quot; + ldt.getMinute());</span><br><span class="line">System.out.println(&quot;秒=&quot; + ldt.getSecond());</span><br><span class="line"></span><br><span class="line">LocalDate now = LocalDate.now(); //可以获取年月日</span><br><span class="line">LocalTime now2 = LocalTime.now();//获取到时分秒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//提供 plus 和 minus方法可以对当前时间进行加或者减</span><br><span class="line">//看看890天后，是什么时候 把 年月日-时分秒</span><br><span class="line">LocalDateTime localDateTime = ldt.plusDays(890);</span><br><span class="line">System.out.println(&quot;890天后=&quot; + dateTimeFormatter.format(localDateTime));</span><br><span class="line"></span><br><span class="line">//看看在 3456分钟前是什么时候，把 年月日-时分秒输出</span><br><span class="line">LocalDateTime localDateTime2 = ldt.minusMinutes(3456);</span><br><span class="line">System.out.println(&quot;3456分钟前 日期=&quot; + dateTimeFormatter.format(localDateTime2));</span><br></pre></td></tr></table></figure><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><h4 id="常用方法-8"><a href="#常用方法-8" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><p>exit</p><ul><li>退出当前程序</li></ul></li><li><p>arraycopy</p><ul><li>复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组 int[] src&#x3D;{1,2.3}: int[] dest &#x3D; new int[3]; System.arraycopy (src, 0, dest, 0, 3);</li></ul></li><li><p>currentTimeMillens</p><ul><li>返回当前时间距离1970-1-1的毫秒数</li></ul></li><li><p>gc()</p><ul><li>运行垃圾回收机制</li></ul></li></ul><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h4 id="基本介绍-40"><a href="#基本介绍-40" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Arrays 里面包含了一系列静态方法，用于管理或操作数组(比如排序和搜索)</li></ul><h4 id="常用方法-9"><a href="#常用方法-9" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><p>toString：返回数组的字符串形式： Arrays.toString (arr) </p></li><li><p>sort：排序(自然排序和定制排序)： Arrays.sout(arr) </p></li><li><p>binarySearch：通过二分搜索法进行查找，必须是有排序的数组： int index &#x3D; Arrays.binarySearch (arr, 需要查找的数) </p></li><li><p>copyOf：数组元素的复制： Integer[] newArr &#x3D; Arrays.copyOf(arr, arr.length) </p></li><li><p>fill：数组元素的填充 Integer[] num &#x3D; new Integer[]{9,3,2} Arrays.fill (num, 99); </p></li><li><p>equals：比较两个数组元素内容是否完全一 boolean equals &#x3D; Arrays.equals(arr. arr2) </p></li><li><p>aslist：将一组值，转换成list List asList &#x3D; Arrays.asList(2,3,4,5,6,1)</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;1, 2, 90, 123, 567&#125;;</span><br><span class="line">// binarySearch 通过二分搜索法进行查找，要求必须排好</span><br><span class="line">// </span><br><span class="line">//1. 使用 binarySearch 二叉查找</span><br><span class="line">//2. 要求该数组是有序的. 如果该数组是无序的，不能使用binarySearch</span><br><span class="line">//3. 如果数组中不存在该元素，就返回 return -(low + 1);  // key not found.</span><br><span class="line">int index = Arrays.binarySearch(arr, 567);</span><br><span class="line">System.out.println(&quot;index=&quot; + index);</span><br><span class="line"></span><br><span class="line">//copyOf 数组元素的复制</span><br><span class="line">// </span><br><span class="line">//1. 从 arr 数组中，拷贝 arr.length个元素到 newArr数组中</span><br><span class="line">//2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null</span><br><span class="line">//3. 如果拷贝长度 &lt; 0 就抛出异常NegativeArraySizeException</span><br><span class="line">//4. 该方法的底层使用的是 System.arraycopy()</span><br><span class="line">Integer[] newArr = Arrays.copyOf(arr, arr.length);</span><br><span class="line">System.out.println(&quot;==拷贝执行完毕后==&quot;);</span><br><span class="line">System.out.println(Arrays.toString(newArr));</span><br><span class="line"></span><br><span class="line">//ill 数组元素的填充</span><br><span class="line">Integer[] num = new Integer[]&#123;9,3,2&#125;;</span><br><span class="line">//</span><br><span class="line">//1. 使用 99 去填充 num数组，可以理解成是替换原理的元素</span><br><span class="line">Arrays.fill(num, 99);</span><br><span class="line">System.out.println(&quot;==num数组填充后==&quot;);</span><br><span class="line">System.out.println(Arrays.toString(num));</span><br><span class="line"></span><br><span class="line">//equals 比较两个数组元素内容是否完全一致</span><br><span class="line">Integer[] arr2 = &#123;1, 2, 90, 123&#125;;</span><br><span class="line">//</span><br><span class="line">//1. 如果arr 和 arr2 数组的元素一样，则方法true;</span><br><span class="line">//2. 如果不是完全一样，就返回 false</span><br><span class="line">boolean equals = Arrays.equals(arr, arr2);</span><br><span class="line">System.out.println(&quot;equals=&quot; + equals);</span><br><span class="line"></span><br><span class="line">//asList 将一组值，转换成list</span><br><span class="line">//</span><br><span class="line">//1. asList方法，会将 (2,3,4,5,6,1)数据转成一个List集合</span><br><span class="line">//2. 返回的 asList 编译类型 List(接口)</span><br><span class="line">//3. asList 运行类型 java.util.Arrays#ArrayList, 是Arrays类的</span><br><span class="line">//   静态内部类 private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">//              implements RandomAccess, java.io.Serializable</span><br><span class="line">List asList = Arrays.asList(2,3,4,5,6,1);</span><br><span class="line">System.out.println(&quot;asList=&quot; + asList);</span><br><span class="line">System.out.println(&quot;asList的运行类型&quot; + asList.getClass());</span><br></pre></td></tr></table></figure><h3 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger BigDecimal"></a>BigInteger BigDecimal</h3><h4 id="基本介绍-41"><a href="#基本介绍-41" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>Biglnteger 适合保存比较大的整型 </p></li><li><p>BigDecimal 适合保存精度更高的浮点型（小数）</p></li></ul><h4 id="常用方法-10"><a href="#常用方法-10" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><p>add：加</p></li><li><p>subtract：减</p></li><li><p>multiply：乘</p></li><li><p>divide：除</p></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h2><h3 id="基本介绍-42"><a href="#基本介绍-42" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>可以动态保存任意多个对象</li><li>提供了一系列方便的操作对象的方法</li><li>使用集合添加、删除新元素的示意代码更简洁</li></ul><h3 id="集合框架体系⭐️"><a href="#集合框架体系⭐️" class="headerlink" title="集合框架体系⭐️"></a><strong>集合框架体系⭐️</strong></h3><h4 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a><strong>框架图</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071915652.png" alt="image-20221007191500475"></p><p>所有的集合框架都包含如下内容</p><ul><li>接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li><li>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap</li><li>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><p>除了集合，还定义了几个 Map 接口和类。Map 里存储的是键&#x2F;值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a><strong>Collection</strong></h3><h4 id="基本介绍-43"><a href="#基本介绍-43" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>Collection 实现子类可以存放多个元素，每个元素可以是 Object</p></li><li><p>Collection 的实现类，有些可以存放重复的元素，有些不可以</p></li><li><p>Collection 的实现类，有些是有序的(List)，有些不是有序(Set)</p></li><li><p>Collection 接口没有直接的实现子类，是通过它的子接口 Set 和 List 来实现的</p></li></ul><h4 id="接口常用方法"><a href="#接口常用方法" class="headerlink" title="接口常用方法"></a>接口常用方法</h4><ul><li><p>add：添加单个元素 </p></li><li><p>remove：删除指定元素 </p></li><li><p>contains：查找元素是否存在 </p></li><li><p>size：获取元素个数 </p></li><li><p>isEmpty：判断是否为空 </p></li><li><p>clear：清空 </p></li><li><p>addAll：添加多个元素 </p></li><li><p>containsAll：查找多个元素是否都存在 </p></li><li><p>removeAll：删除多个元素</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//        说明：以ArrayList实现类来演示</span><br><span class="line">List list = new ArrayList();</span><br><span class="line">//        add:添加单个元素</span><br><span class="line">        list.add(&quot;jack&quot;);</span><br><span class="line">        list.add(10);//list.add(new Integer(10))</span><br><span class="line">        list.add(true);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">//        remove:删除指定元素</span><br><span class="line">        //list.remove(0);//删除第一个元素</span><br><span class="line">        list.remove(true);//指定删除某个元素</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">//        contains:查找元素是否存在</span><br><span class="line">        System.out.println(list.contains(&quot;jack&quot;));//T</span><br><span class="line">//        size:获取元素个数</span><br><span class="line">        System.out.println(list.size());//2</span><br><span class="line">//        isEmpty:判断是否为空</span><br><span class="line">        System.out.println(list.isEmpty());//F</span><br><span class="line">//        clear:清空</span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">//        addAll:添加多个元素</span><br><span class="line">        ArrayList list2 = new ArrayList();</span><br><span class="line">        list2.add(&quot;红楼梦&quot;);</span><br><span class="line">        list2.add(&quot;三国演义&quot;);</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">//        containsAll:查找多个元素是否都存在</span><br><span class="line">        System.out.println(list.containsAll(list2));//T</span><br><span class="line">//        removeAll：删除多个元素</span><br><span class="line">        list.add(&quot;聊斋&quot;);</span><br><span class="line">        list.removeAll(list2);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);//[聊斋]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h3><h4 id="基本介绍-44"><a href="#基本介绍-44" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>List 集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</li><li>List 集合中的每个元素都有其对应的顺序索引，即支持索引</li><li>List 容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器元素</li><li>常用： ArrayList、LinkedList、Vector</li></ul><h4 id="常用方法-11"><a href="#常用方法-11" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>void add(int index, Object ele)：在index位置插入ele元素 </li><li>boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来 </li><li>Object get(int index)：获取指定index位置的元素 </li><li>int indexOf(Object obj)：返回obj在集合中首次出现的位置 </li><li>int lastindexOf(Object obj)：返回obj在当前集合中末次出现的位置 </li><li>Object remove(int index)：移除指定index位置的元素，井返回此元素 </li><li>Object set(int index, Object ele)：设置指定index位置的元素为ele，相当于是替换 </li><li>List sublist(int fromlndex, int tolndex)：返回从fromlndex到tolndex位置的子集合</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">        list.add(&quot;张三丰&quot;);</span><br><span class="line">        list.add(&quot;贾宝玉&quot;);</span><br><span class="line">//        void add(int index, Object ele):在index位置插入ele元素</span><br><span class="line">        //在index = 1的位置插入一个对象</span><br><span class="line">        list.add(1, &quot;韩顺平&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">//        boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span><br><span class="line">        List list2 = new ArrayList();</span><br><span class="line">        list2.add(&quot;jack&quot;);</span><br><span class="line">        list2.add(&quot;tom&quot;);</span><br><span class="line">        list.addAll(1, list2);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">//        Object get(int index):获取指定index位置的元素</span><br><span class="line"></span><br><span class="line">//        int indexOf(Object obj):返回obj在集合中首次出现的位置</span><br><span class="line">        System.out.println(list.indexOf(&quot;tom&quot;));//2</span><br><span class="line"></span><br><span class="line">//        int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span><br><span class="line">        list.add(&quot;韩顺平&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));</span><br><span class="line"></span><br><span class="line">//        Object remove(int index):移除指定index位置的元素，并返回此元素</span><br><span class="line">        list.remove(0);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">//        Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span><br><span class="line">        list.set(1, &quot;玛丽&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">//        List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span><br><span class="line">        // 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span><br><span class="line">        List returnlist = list.subList(0, 2);</span><br><span class="line">        System.out.println(&quot;returnlist=&quot; + returnlist);</span><br></pre></td></tr></table></figure><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="基本介绍-45"><a href="#基本介绍-45" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul><li>lterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素 </li><li>实现了 Collection 接口的集合都有一个 iterator() 方法，用以返回一个实现了 lterator 接口的对象，即可以返回一个迭代器 </li><li>lterator 仅用于遍历集合，lterator 本身并不存放对象 </li><li>在调用 it.next() 方法之前必须要调用 it.hasNext() 进行检测。若不调用，且下一条记录无效，直接调用 it.next() 会抛出 NoSuchElementException 异常</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionIterator &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Collection col = new ArrayList();</span><br><span class="line"></span><br><span class="line">        col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));</span><br><span class="line">        col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));</span><br><span class="line">        col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));</span><br><span class="line"></span><br><span class="line">        //System.out.println(&quot;col=&quot; + col);</span><br><span class="line">        //现在老师希望能够遍历 col集合</span><br><span class="line">        //1. 先得到 col 对应的 迭代器</span><br><span class="line">        Iterator iterator = col.iterator();</span><br><span class="line">        //2. 使用while循环遍历</span><br><span class="line">//        while (iterator.hasNext()) &#123;//判断是否还有数据</span><br><span class="line">//            //返回下一个元素，类型是Object</span><br><span class="line">//            Object obj = iterator.next();</span><br><span class="line">//            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line">//        &#125;</span><br><span class="line">      </span><br><span class="line">        //老师教大家一个快捷键，快速生成 while =&gt; itit</span><br><span class="line">        //显示所有的快捷键的的快捷键 ctrl + j</span><br><span class="line">      </span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //3. 当退出while循环后 , 这时iterator迭代器，指向最后的元素</span><br><span class="line">        //   iterator.next();//NoSuchElementException</span><br><span class="line">        //4. 如果希望再次遍历，需要重置我们的迭代器</span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println(&quot;===第二次遍历===&quot;);</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String author;</span><br><span class="line">    private double price;</span><br><span class="line"></span><br><span class="line">    public Book(String name, String author, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.author = author;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, author=&#x27;&quot; + author + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for增强循环"><a href="#for增强循环" class="headerlink" title="for增强循环"></a>for增强循环</h4><h5 id="基本介绍-46"><a href="#基本介绍-46" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li>增强 for 循环，可以代替 iteertor 迭代器，特点：增强 for 就是简化版的 iteraotr,本质一样，只能用于遍历集合或数组</li></ul><h5 id="基本语法-11"><a href="#基本语法-11" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型 元素名:集合名或数组名)&#123;</span><br><span class="line">访问元素;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="注意事项和细节-37"><a href="#注意事项和细节-37" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>允许所有元素<ul><li>包括 null 加入</li></ul></li><li>ArrayList 基本等同于 Vector,除了 ArrayList 是线程不安全的，但其执行效率高<ul><li>在多线程情况下，不建议使用 ArrayList</li></ul></li></ul><h5 id="底层结构和源码分析"><a href="#底层结构和源码分析" class="headerlink" title="底层结构和源码分析"></a><strong>底层结构和源码分析</strong></h5><ul><li>ArrayList 中维护了一个 Object 类型的数组 - elementData<ul><li>transient Object[] elementData;</li><li>transient 表示瞬间,短暂的，<strong>表示该属性不会被序列化</strong></li></ul></li><li>创建 ArrayList 对象时<ul><li>如果使用的是无参构造器，则初始 elementData 容量为0，第1次添加，则扩容 elementData 为10，如需要再次扩容，则扩容 elementData 为1.5倍 </li><li>如果使用的是指定大小的构造器，则初始 elementData 容量为指定大小，如果需要扩容，则直接扩容 elementData 为1.5倍</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102033297.png" alt="image-20221010203320092"></p><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102033618.png" alt="image-20221010203332438"></p><h4 id="Vector⭐️"><a href="#Vector⭐️" class="headerlink" title="Vector⭐️"></a>Vector⭐️</h4><h5 id="注意事项和细节-38"><a href="#注意事项和细节-38" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>Vector 底层是一个对象数组<ul><li>protected Object[] elementData;</li></ul></li><li>Vector 是线程同步的，即线程安全，Vector 类的操作方法带有 synchronized</li></ul><h5 id="底层机制和源码分析"><a href="#底层机制和源码分析" class="headerlink" title="底层机制和源码分析"></a>底层机制和源码分析</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Vector_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //无参构造器</span><br><span class="line">        //有参数的构造</span><br><span class="line">        Vector vector = new Vector(8);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector.add(100);</span><br><span class="line">        System.out.println(&quot;vector=&quot; + vector);</span><br><span class="line">        //老韩解读源码</span><br><span class="line">        //1. new Vector() 底层</span><br><span class="line">        /*</span><br><span class="line">            public Vector() &#123;</span><br><span class="line">                this(10);</span><br><span class="line">            &#125;</span><br><span class="line">         补充：如果是  Vector vector = new Vector(8);</span><br><span class="line">            走的方法:</span><br><span class="line">            public Vector(int initialCapacity) &#123;</span><br><span class="line">                this(initialCapacity, 0);</span><br><span class="line">            &#125;</span><br><span class="line">         2. vector.add(i)</span><br><span class="line">         2.1  //下面这个方法就添加数据到vector集合</span><br><span class="line">            public synchronized boolean add(E e) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                ensureCapacityHelper(elementCount + 1);</span><br><span class="line">                elementData[elementCount++] = e;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">          2.2  //确定是否需要扩容 条件 ： minCapacity - elementData.length&gt;0</span><br><span class="line">            private void ensureCapacityHelper(int minCapacity) &#123;</span><br><span class="line">                // overflow-conscious code</span><br><span class="line">                if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">                    grow(minCapacity);</span><br><span class="line">            &#125;</span><br><span class="line">          2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法</span><br><span class="line">              //newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">              //                             capacityIncrement : oldCapacity);</span><br><span class="line">              //就是扩容两倍.</span><br><span class="line">            private void grow(int minCapacity) &#123;</span><br><span class="line">                // overflow-conscious code</span><br><span class="line">                int oldCapacity = elementData.length;</span><br><span class="line">                int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                                 capacityIncrement : oldCapacity);</span><br><span class="line">                if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">                    newCapacity = minCapacity;</span><br><span class="line">                if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">                    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">                elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a><strong>ArrayList和Vector</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102035032.png" alt="image-20221010203556918"></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h4><h5 id="注意事项和细节-39"><a href="#注意事项和细节-39" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>LinkedList 底层实现了<strong>双向链表</strong>和<strong>双端队列</strong>特点</li><li>可以添加任意元素包括 null</li><li>线程不安全，没有实现同步</li></ul><h5 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h5><ul><li>Linkedlis t底层维护了一个双向链表 </li><li>Linkedlist 中维护了两个属性 first 和 last 分别指向首节点和尾节点 </li><li>每个节点（Node对象），里面又维护了 prev、next, item 三个属性，其中通过 prev 指向前一个，通过 next 指向后一个节点。最终实现双向链表 </li><li>所以 LinkedList 的元素的添加和删除，不是通过数组完成的，相对来说效率较高</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102038008.png" alt="image-20221010203815869"></p><h4 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h4><ul><li>如果我们改查的操作多，选择 ArrayList </li><li>如果我们增删的操作多，选择 LinkedList </li><li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择 ArrayList</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本介绍-47"><a href="#基本介绍-47" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>无序，没有索引</li><li>不允许重复元素，最多包含一个 null</li><li>JDK API 中 Set 接口的实现类有<img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102040344.png" alt="image-20221010204040225"></li></ul><h4 id="常用方法-12"><a href="#常用方法-12" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>add：添加单个元素 </li><li>remove：删除指定元素 </li><li>contains：查找元素是否存在 </li><li>size：获取元素个数 </li><li>isEmpty：判断是否为空 </li><li>clear：清空 </li><li>addAll：添加多个元素 </li><li>containsAll：查找多个元素是否都存在 </li><li>removeAll：删除多个元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class SetMethod &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //老韩解读</span><br><span class="line">        //1. 以Set 接口的实现类 HashSet 来讲解Set 接口的方法</span><br><span class="line">        //2. set 接口的实现类的对象(Set接口对象), 不能存放重复的元素, 可以添加一个null</span><br><span class="line">        //3. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)</span><br><span class="line">        //4. 注意：取出的顺序的顺序虽然不是添加的顺序，但是他的固定.</span><br><span class="line">        Set set = new HashSet();</span><br><span class="line">        set.add(&quot;john&quot;);</span><br><span class="line">        set.add(&quot;lucy&quot;);</span><br><span class="line">        set.add(&quot;john&quot;);//重复</span><br><span class="line">        set.add(&quot;jack&quot;);</span><br><span class="line">        set.add(&quot;hsp&quot;);</span><br><span class="line">        set.add(&quot;mary&quot;);</span><br><span class="line">        set.add(null);//</span><br><span class="line">        set.add(null);//再次添加null</span><br><span class="line">        for(int i = 0; i &lt;10;i ++) &#123;</span><br><span class="line">            System.out.println(&quot;set=&quot; + set);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //遍历</span><br><span class="line">        //方式1： 使用迭代器</span><br><span class="line">        System.out.println(&quot;=====使用迭代器====&quot;);</span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj =  iterator.next();</span><br><span class="line">            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set.remove(null);</span><br><span class="line"></span><br><span class="line">        //方式2: 增强for</span><br><span class="line">        System.out.println(&quot;=====增强for====&quot;);</span><br><span class="line"></span><br><span class="line">        for (Object o : set) &#123;</span><br><span class="line">            System.out.println(&quot;o=&quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">        //set 接口对象，不能通过索引来获取</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul><li>迭代器</li><li>增强for</li><li>不能使用索引方式获取（普通遍历循环)</li></ul><h4 id="HashSet⭐️"><a href="#HashSet⭐️" class="headerlink" title="HashSet⭐️"></a><strong>HashSet⭐️</strong></h4><h5 id="注意事项和细节-40"><a href="#注意事项和细节-40" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>Hashset 实现了 Set 接口</li><li>Hashset 实际上是 HashMap</li><li>可以存放 null 值，但是只能有一个 null</li><li>Hashset 不保证元素是有序的,取决于 hash 后，再确定索引的结果</li><li>不能有重复元素&#x2F;对象</li></ul><h5 id="底层机制和源码分析-1"><a href="#底层机制和源码分析-1" class="headerlink" title="底层机制和源码分析"></a>底层机制和源码分析</h5><ul><li>HashSet 底层是 HashMap</li><li>添加一个元素时，先得到 hash 值会转成索引值 </li><li>找到存储数据表 table，看这个素引位置是否己经存放的有元素如果没有，直接加入</li><li>如果有调用 equals 比较，如果相同，就放奔添加，如果不相同，则添加到最后 </li><li>在 Java8 中，如果一条链表的元素个数超过 TREEIFY THRESHOLD（默认是8），井且 table 的大小＞&#x3D; MIN TREEIFY CAPACITY（默认64)就会进行树化(红黑树）</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121922424.png" alt="image-20221012192234075"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class HashSetSource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        HashSet hashSet = new HashSet();</span><br><span class="line">        hashSet.add(&quot;java&quot;);//到此位置，第1次add分析完毕.</span><br><span class="line">        hashSet.add(&quot;php&quot;);//到此位置，第2次add分析完毕</span><br><span class="line">        hashSet.add(&quot;java&quot;);</span><br><span class="line">        System.out.println(&quot;set=&quot; + hashSet);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        HashSet 的源码解读</span><br><span class="line">        1. 执行 HashSet()</span><br><span class="line">            public HashSet() &#123;</span><br><span class="line">                map = new HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        2. 执行 add()</span><br><span class="line">           public boolean add(E e) &#123;//e = &quot;java&quot;</span><br><span class="line">                return map.put(e, PRESENT)==null;//(static) PRESENT = new Object();</span><br><span class="line">           &#125;</span><br><span class="line">         3.执行 put() , 该方法会执行 hash(key) 得到key对应的hash值 算法h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span><br><span class="line">             public V put(K key, V value) &#123;//key = &quot;java&quot; value = PRESENT 共享</span><br><span class="line">                return putVal(hash(key), key, value, false, true);</span><br><span class="line">            &#125;</span><br><span class="line">         4.执行 putVal</span><br><span class="line">         final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //定义了辅助变量</span><br><span class="line">                //table 就是 HashMap 的一个数组，类型是 Node[]</span><br><span class="line">                //if 语句表示如果当前table 是null, 或者 大小=0</span><br><span class="line">                //就是第一次扩容，到16个空间.</span><br><span class="line">                if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">                    n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">                //(1)根据key，得到hash 去计算该key应该存放到table表的哪个索引位置</span><br><span class="line">                //并把这个位置的对象，赋给 p</span><br><span class="line">                //(2)判断p 是否为null</span><br><span class="line">                //(2.1) 如果p 为null, 表示还没有存放元素, 就创建一个Node (key=&quot;java&quot;,value=PRESENT)</span><br><span class="line">                //(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)</span><br><span class="line"></span><br><span class="line">                if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">                    tab[i] = newNode(hash, key, value, null);</span><br><span class="line">                else &#123;</span><br><span class="line">                    //一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建</span><br><span class="line">                    Node&lt;K,V&gt; e; K k; //</span><br><span class="line">                    //如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样</span><br><span class="line">                    //并且满足 下面两个条件之一:</span><br><span class="line">                    //(1) 准备加入的key 和 p 指向的Node 结点的 key 是同一个对象</span><br><span class="line">                    //(2)  p 指向的Node 结点的 key 的equals() 和准备加入的key比较后相同</span><br><span class="line">                    //就不能加入</span><br><span class="line">                    if (p.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        e = p;</span><br><span class="line">                    //再判断 p 是不是一颗红黑树,</span><br><span class="line">                    //如果是一颗红黑树，就调用 putTreeVal , 来进行添加</span><br><span class="line">                    else if (p instanceof TreeNode)</span><br><span class="line">                        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">                    else &#123;//如果table对应索引位置，已经是一个链表, 就使用for循环比较</span><br><span class="line">                    </span><br><span class="line">                          //(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后</span><br><span class="line">                          //    注意在把元素添加到链表后，立即判断 该链表是否已经达到8个结点</span><br><span class="line">                          //    , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)</span><br><span class="line">                          //    注意，在转成红黑树时，要进行判断, 判断条件</span><br><span class="line">                          //    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))</span><br><span class="line">                          //            resize();</span><br><span class="line">                          //    如果上面条件成立，先table扩容.</span><br><span class="line">                          //    只有上面条件不成立时，才进行转成红黑树</span><br><span class="line">                          //(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接break</span><br><span class="line"></span><br><span class="line">                        for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                            if ((e = p.next) == null) &#123;</span><br><span class="line">                                p.next = newNode(hash, key, value, null);</span><br><span class="line">                                if (binCount &gt;= TREEIFY_THRESHOLD(8) - 1) // -1 for 1st</span><br><span class="line">                                    treeifyBin(tab, hash);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                                break;</span><br><span class="line">                            p = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e != null) &#123; // existing mapping for key</span><br><span class="line">                        V oldValue = e.value;</span><br><span class="line">                        if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                            e.value = value;</span><br><span class="line">                        afterNodeAccess(e);</span><br><span class="line">                        return oldValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ++modCount;</span><br><span class="line">                //size 就是我们每加入一个结点Node(k,v,h,next), size++</span><br><span class="line">                if (++size &gt; threshold)</span><br><span class="line">                    resize();//扩容</span><br><span class="line">                afterNodeInsertion(evict);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩容和红黑树机制"><a href="#扩容和红黑树机制" class="headerlink" title="扩容和红黑树机制"></a>扩容和红黑树机制</h4><ul><li><p>HashSet 底层 是HashMap</p></li><li><p>第一次添加时，table 数组扩容到 16，临界值(threshold)是 16*加载因子(loadFactor)是0.75&#x3D; 12</p></li><li><p>每加入一个节点，size 就会 ++，到达临界值就会扩容</p></li><li><p>如果 table 数组使用到了临界值 12,就会扩容到<code>16*2=32</code>,新的临界值就是32*0.75&#x3D;24，依次类推</p></li><li><p>在 Java8 中，如果一条链表的元素个数到达 TREEIFY_ THRESHOLD(默认是 8）井且table的大小＞&#x3D;MIN TREEIFY CAPACITY (默认64),就会进行树化(红黑树），否则仍然采用数组扩容机制</p></li></ul><p>●  </p><h4 id="去重机制对比"><a href="#去重机制对比" class="headerlink" title="去重机制对比"></a>去重机制对比</h4><ul><li><p>HashSet 去重机制:</p><ul><li>hashCode() + equals()，底层先通过存入对象，通过运算 hash 值得到对应的索引，如果 table 索引所在的位置没有数据就直接存放；如果有数据就进行 equals（注意重写情况）比较[遍历比较]，如果比较后，不相同就加入，否则就不加入</li></ul></li><li><p>TreeSet 的去重机制</p><ul><li>如果你传入了一个 Comparator 匿名对象，就使用实现的compare 去重，如果方法返回0,就是相同的元素&#x2F;数据，就不添加，如果你没有传入一个 Comparator 匿名对象，则以你添加的对象实现的 Compareable 接口的 compareTo 去重</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Homework06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet set = new HashSet();//ok</span><br><span class="line">        Person p1 = new Person(1001,&quot;AA&quot;);//ok</span><br><span class="line">        Person p2 = new Person(1002,&quot;BB&quot;);//ok</span><br><span class="line">        set.add(p1);//ok</span><br><span class="line">        set.add(p2);//ok</span><br><span class="line">        p1.name = &quot;CC&quot;;</span><br><span class="line">        set.remove(p1);</span><br><span class="line">        System.out.println(set);//2</span><br><span class="line">        set.add(new Person(1001,&quot;CC&quot;));</span><br><span class="line">        System.out.println(set);//3</span><br><span class="line">        set.add(new Person(1001,&quot;AA&quot;));</span><br><span class="line">        System.out.println(set);//4</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int id;</span><br><span class="line"></span><br><span class="line">    public Person(int id, String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        return id == person.id &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return Objects.hash(name, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, id=&quot; + id +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121922904.png" alt="image-20221012192205336"></p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><h5 id="注意事项和细节-41"><a href="#注意事项和细节-41" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li><p>LinkedHashset 是 Hashset 的子类 </p></li><li><p>LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个 数组＋双向链表 </p></li><li><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序(图)，这使得元素看起来是以插入顺序保存的 </p></li><li><p>LinkedHashSet 不允许添重复元素</p></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121916626.png" alt="image-20221012191625176"></p><h5 id="底层机制和源代码分析"><a href="#底层机制和源代码分析" class="headerlink" title="底层机制和源代码分析"></a>底层机制和源代码分析</h5><ul><li><p>LinkedHashSet 加入顺序和取出元素&#x2F;数据的顺序一致</p></li><li><p>LinkedHashSet 底层维护的是一个 LinkedHashMap (是HashMap的子类)</p></li><li><p>LinkedHashSet 底层结构 (数组table+双向链表)</p></li><li><p>添加第一次时，直接将 数组 table 扩容到 16 ,存放的结点类型是 LinkedHashMap$Entry</p></li><li><p>数组是 HashMap </p><ul><li><code>Node[]</code>存放的元素&#x2F;数据是 LinkedHashMap Entry 类型</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashSetSource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //分析一下LinkedHashSet的底层机制</span><br><span class="line">        Set set = new LinkedHashSet();</span><br><span class="line">        set.add(new String(&quot;AA&quot;));</span><br><span class="line">        set.add(456);</span><br><span class="line">        set.add(456);</span><br><span class="line">        set.add(new Customer(&quot;刘&quot;, 1001));</span><br><span class="line">        set.add(123);</span><br><span class="line">        set.add(&quot;HSP&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;set=&quot; + set);</span><br><span class="line">        </span><br><span class="line">        //1. LinkedHashSet 加入顺序和取出元素/数据的顺序一致</span><br><span class="line">        //2. LinkedHashSet 底层维护的是一个LinkedHashMap(是HashMap的子类)</span><br><span class="line">        //3. LinkedHashSet 底层结构 (数组table+双向链表)</span><br><span class="line">        //4. 添加第一次时，直接将 数组table 扩容到 16 ,存放的结点类型是 LinkedHashMap$Entry</span><br><span class="line">        //5. 数组是 HashMap$Node[] 存放的元素/数据是 LinkedHashMap$Entry类型</span><br><span class="line">        /*</span><br><span class="line">                //继承关系是在内部类完成.</span><br><span class="line">                static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; before, after;</span><br><span class="line">                    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">                        super(hash, key, value, next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Customer &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int no;</span><br><span class="line"></span><br><span class="line">    public Customer(String name, int no) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><h4 id="底层机制-1"><a href="#底层机制-1" class="headerlink" title="底层机制"></a>底层机制</h4><ul><li><p>TreeSet() 构造器需传入 Comparator 接口的匿名内部类，因为底层 Comparable&lt;? super K&gt; k &#x3D; (Comparator&lt;? super K&gt;) key; 若没有传入，则需要把传入的类实现Comparable 接口 </p></li><li><p>若按照 compare 方法比较 value 相同则无法加入 value</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class TreeSet_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //1. 当我们使用无参构造器，创建TreeSet时，默认按字母排序</span><br><span class="line">        //2. 老师希望添加的元素，按照字符串大小来排序</span><br><span class="line">        //3. 使用TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)</span><br><span class="line">        //   并指定排序规则</span><br><span class="line">        //4. 简单看看源码</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">        1. 构造器把传入的比较器对象，赋给了 TreeSet的底层的 TreeMap的属性this.comparator</span><br><span class="line"></span><br><span class="line">         public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">                this.comparator = comparator;</span><br><span class="line">            &#125;</span><br><span class="line">         2. 在 调用 treeSet.add(&quot;tom&quot;), 在底层会执行到</span><br><span class="line"></span><br><span class="line">             if (cpr != null) &#123;//cpr 就是我们的匿名内部类(对象)</span><br><span class="line">                do &#123;</span><br><span class="line">                    parent = t;</span><br><span class="line">                    //动态绑定到我们的匿名内部类(对象)compare</span><br><span class="line">                    cmp = cpr.compare(key, t.key);</span><br><span class="line">                    if (cmp &lt; 0)</span><br><span class="line">                        t = t.left;</span><br><span class="line">                    else if (cmp &gt; 0)</span><br><span class="line">                        t = t.right;</span><br><span class="line">                    else //如果相等，即返回0,这个Key就没有加入</span><br><span class="line">                        return t.setValue(value);</span><br><span class="line">                &#125; while (t != null);</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">//        TreeSet treeSet = new TreeSet();</span><br><span class="line">        TreeSet treeSet = new TreeSet(new Comparator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Object o1, Object o2) &#123;</span><br><span class="line">                //下面 调用String的 compareTo方法进行字符串大小比较</span><br><span class="line">                //如果老韩要求加入的元素，按照长度大小排序</span><br><span class="line">                //return ((String) o2).compareTo((String) o1);</span><br><span class="line">                return ((String) o1).length() - ((String) o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //添加数据.</span><br><span class="line">        treeSet.add(&quot;jack&quot;);</span><br><span class="line">        treeSet.add(&quot;tom&quot;);//3</span><br><span class="line">        treeSet.add(&quot;sp&quot;);</span><br><span class="line">        treeSet.add(&quot;a&quot;);</span><br><span class="line">        treeSet.add(&quot;abc&quot;);//3</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;treeSet=&quot; + treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h5 id="注意事项和细节-42"><a href="#注意事项和细节-42" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>Map 与 Collection 井列存在，用于保存具有<strong>映射关系</strong>的数据 </li><li>Map 中的 key 和 value 可以是任何引用类型的数据，会封装到HashMap$Node 对象中 </li><li>Map 中的 key 不允许重复，原因和 HashSet 一样 </li><li>Map 中的 value 可以重复 </li><li>Map 的 key 可以为 null，value 也可以为 null，key 为null 只有能有一个，value 为 null 可以为多个 </li><li>常用 String 类作为 Map 的 key </li><li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value </li><li>Map存放数据的 key-value 示意图，一对 k-y是放在一个Node中的，有因为Node 实现了 Entry 接口</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121915259.png" alt="image-20221012191518986"></p><h4 id="常用方法-13"><a href="#常用方法-13" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>put：添加 </li><li>remove：根据键删除映射关系 </li><li>get：根据键获取值 </li><li>size：获取元素个数 </li><li>isEmpty：判断个数是否为0 </li><li>clear：清除 </li><li>containskey：查找键是否存在</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class MapMethod &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //演示map接口常用方法</span><br><span class="line"></span><br><span class="line">        Map map = new HashMap();</span><br><span class="line">        map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));//OK</span><br><span class="line">        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);//替换-&gt; 一会分析源码</span><br><span class="line">        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);//OK</span><br><span class="line">        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);//OK</span><br><span class="line">        map.put(&quot;刘令博&quot;, null);//OK</span><br><span class="line">        map.put(null, &quot;刘亦菲&quot;);//OK</span><br><span class="line">        map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);//OK</span><br><span class="line">        map.put(&quot;hsp&quot;, &quot;hsp的老婆&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;map=&quot; + map);</span><br><span class="line"></span><br><span class="line">//        remove:根据键删除映射关系</span><br><span class="line">        map.remove(null);</span><br><span class="line">        System.out.println(&quot;map=&quot; + map);</span><br><span class="line">//        get：根据键获取值</span><br><span class="line">        Object val = map.get(&quot;鹿晗&quot;);</span><br><span class="line">        System.out.println(&quot;val=&quot; + val);</span><br><span class="line">//        size:获取元素个数</span><br><span class="line">        System.out.println(&quot;k-v=&quot; + map.size());</span><br><span class="line">//        isEmpty:判断个数是否为0</span><br><span class="line">        System.out.println(map.isEmpty());//F</span><br><span class="line">//        clear:清除k-v</span><br><span class="line">        //map.clear();</span><br><span class="line">        System.out.println(&quot;map=&quot; + map);</span><br><span class="line">//        containsKey:查找键是否存在</span><br><span class="line">        System.out.println(&quot;结果=&quot; + map.containsKey(&quot;hsp&quot;));//T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int num;</span><br><span class="line"></span><br><span class="line">    public Book(String name, int num) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历方式-1"><a href="#遍历方式-1" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul><li>先取出所有的 Key , 通过 Key 取出对应的 Value </li><li>把所有的 values 取出</li><li>通过 EntrySet 来获取 k-v</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class MapFor &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Map map = new HashMap();</span><br><span class="line">        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);</span><br><span class="line">        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);</span><br><span class="line">        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);</span><br><span class="line">        map.put(&quot;刘令博&quot;, null);</span><br><span class="line">        map.put(null, &quot;刘亦菲&quot;);</span><br><span class="line">        map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);</span><br><span class="line"></span><br><span class="line">        //第一组: 先取出 所有的Key , 通过Key 取出对应的Value</span><br><span class="line">        Set keyset = map.keySet();</span><br><span class="line">        //(1) 增强for</span><br><span class="line">        System.out.println(&quot;---第一种方式-------&quot;);</span><br><span class="line">        for (Object key : keyset) &#123;</span><br><span class="line">            System.out.println(key + &quot;-&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        //(2) 迭代器</span><br><span class="line">        System.out.println(&quot;----第二种方式--------&quot;);</span><br><span class="line">        Iterator iterator = keyset.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object key =  iterator.next();</span><br><span class="line">            System.out.println(key + &quot;-&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第二组: 把所有的values取出</span><br><span class="line">        Collection values = map.values();</span><br><span class="line">        //这里可以使用所有的Collections使用的遍历方法</span><br><span class="line">        //(1) 增强for</span><br><span class="line">        System.out.println(&quot;---取出所有的value 增强for----&quot;);</span><br><span class="line">        for (Object value : values) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">        //(2) 迭代器</span><br><span class="line">        System.out.println(&quot;---取出所有的value 迭代器----&quot;);</span><br><span class="line">        Iterator iterator2 = values.iterator();</span><br><span class="line">        while (iterator2.hasNext()) &#123;</span><br><span class="line">            Object value =  iterator2.next();</span><br><span class="line">            System.out.println(value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第三组: 通过EntrySet 来获取 k-v</span><br><span class="line">        Set entrySet = map.entrySet();// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span><br><span class="line">        //(1) 增强for</span><br><span class="line">        System.out.println(&quot;----使用EntrySet 的 for增强(第3种)----&quot;);</span><br><span class="line">        for (Object entry : entrySet) &#123;</span><br><span class="line">            //将entry 转成 Map.Entry</span><br><span class="line">            Map.Entry m = (Map.Entry) entry;</span><br><span class="line">            System.out.println(m.getKey() + &quot;-&quot; + m.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //(2) 迭代器</span><br><span class="line">        System.out.println(&quot;----使用EntrySet 的 迭代器(第4种)----&quot;);</span><br><span class="line">        Iterator iterator3 = entrySet.iterator();</span><br><span class="line">        while (iterator3.hasNext()) &#123;</span><br><span class="line">            Object entry =  iterator3.next();</span><br><span class="line">            //System.out.println(next.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span><br><span class="line">            //向下转型 Map.Entry</span><br><span class="line">            Map.Entry m = (Map.Entry) entry;</span><br><span class="line">            System.out.println(m.getKey() + &quot;-&quot; + m.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap⭐️"><a href="#HashMap⭐️" class="headerlink" title="HashMap⭐️"></a><strong>HashMap⭐️</strong></h4><h5 id="注意事项和细节-43"><a href="#注意事项和细节-43" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li><p>HashMap 是 Map 接口<strong>使用频率最高</strong>的实现类</p></li><li><p>Hashap 是以 key-value 对的方式来存储数据(HashMap$Node类型）</p></li><li><p>key 不能重复，但是值可以重复，允许使用 null 和 null 值</p></li><li><p>如果添加相同的 key，则会覆盖原来的 key-value ，等同于修改（key不会替换，val会替换）</p></li><li><p>与 HashSet 一样，不保证映射的顺序，因为底层是以 hash 表的方式来存储的(jdk8 的 hashMap 底层 数组＋链表＋红黑树）</p></li><li><p>HashMap 没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，没有 synchronized</p></li></ul><h5 id="底层机制和源码剖析"><a href="#底层机制和源码剖析" class="headerlink" title="底层机制和源码剖析"></a>底层机制和源码剖析</h5><ul><li><p>扩容机制和 Hashset 相同 </p></li><li><p>HashMap 底层维护了 Node 类型的数组 table，默认为 null </p></li><li><p>当创建对象时，将加载因子(loadfactor)初始化为0.75 </p></li><li><p>当添加 key-val 时，通过 key 的哈希值得到在 table 的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的 key 是否和准备加入的 key相等，如果相等，则直接替换 val：如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容 </p></li><li><p>第1次添加，则需要扩容 table 容量为16，临界值(threshold)为12 </p></li><li><p>以后再扩容，则需要扩容 table 容量为原来的2倍，临界值为原来的2倍,即24，依次类推 </p></li><li><p>在 Java8 中，如果一条链表的元素个数超过 TREEIFY THRESHOLD（默认是8），并且 table的大小＞&#x3D;MIN TREEIFY CAPACITY（默认64),就会进行树化（红黑树）</p></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121914684.png" alt="image-20221012191412331"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class HashMapSource1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap map = new HashMap();</span><br><span class="line">        map.put(&quot;java&quot;, 10);//ok</span><br><span class="line">        map.put(&quot;php&quot;, 10);//ok</span><br><span class="line">        map.put(&quot;java&quot;, 20);//替换value</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;map=&quot; + map);//</span><br><span class="line"></span><br><span class="line">        /*老韩解读HashMap的源码+图解</span><br><span class="line">        1. 执行构造器 new HashMap()</span><br><span class="line">           初始化加载因子 loadfactor = 0.75</span><br><span class="line">           HashMap$Node[] table = null</span><br><span class="line">        2. 执行put 调用 hash方法，计算 key的 hash值 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span><br><span class="line">            public V put(K key, V value) &#123;//K = &quot;java&quot; value = 10</span><br><span class="line">                return putVal(hash(key), key, value, false, true);</span><br><span class="line">            &#125;</span><br><span class="line">        3. 执行 putVal</span><br><span class="line">         final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//辅助变量</span><br><span class="line">                //如果底层的table 数组为null, 或者 length =0 , 就扩容到16</span><br><span class="line">                if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">                    n = (tab = resize()).length;</span><br><span class="line">                //取出hash值对应的table的索引位置的Node, 如果为null, 就直接把加入的k-v</span><br><span class="line">                //, 创建成一个 Node ,加入该位置即可</span><br><span class="line">                if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">                    tab[i] = newNode(hash, key, value, null);</span><br><span class="line">                else &#123;</span><br><span class="line">                    Node&lt;K,V&gt; e; K k;//辅助变量</span><br><span class="line">                // 如果table的索引位置的key的hash相同和新的key的hash值相同，</span><br><span class="line">                 // 并 满足(table现有的结点的key和准备添加的key是同一个对象  || equals返回真)</span><br><span class="line">                 // 就认为不能加入新的k-v</span><br><span class="line">                    if (p.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        e = p;</span><br><span class="line">                    else if (p instanceof TreeNode)//如果当前的table的已有的Node 是红黑树，就按照红黑树的方式处理</span><br><span class="line">                        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">                    else &#123;</span><br><span class="line">                        //如果找到的结点，后面是链表，就循环比较</span><br><span class="line">                        for (int binCount = 0; ; ++binCount) &#123;//死循环</span><br><span class="line">                            if ((e = p.next) == null) &#123;//如果整个链表，没有和他相同,就加到该链表的最后</span><br><span class="line">                                p.next = newNode(hash, key, value, null);</span><br><span class="line">                                //加入后，判断当前链表的个数，是否已经到8个，到8个，后</span><br><span class="line">                                //就调用 treeifyBin 方法进行红黑树的转换</span><br><span class="line">                                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                                    treeifyBin(tab, hash);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (e.hash == hash &amp;&amp; //如果在循环比较过程中，发现有相同,就break,就只是替换value</span><br><span class="line">                                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                                break;</span><br><span class="line">                            p = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e != null) &#123; // existing mapping for key</span><br><span class="line">                        V oldValue = e.value;</span><br><span class="line">                        if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                            e.value = value; //替换，key对应value</span><br><span class="line">                        afterNodeAccess(e);</span><br><span class="line">                        return oldValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ++modCount;//每增加一个Node ,就size++</span><br><span class="line">                if (++size &gt; threshold[12-24-48])//如size &gt; 临界值，就扩容</span><br><span class="line">                    resize();</span><br><span class="line">                afterNodeInsertion(evict);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">              5. 关于树化(转成红黑树)</span><br><span class="line">              //如果table 为null ,或者大小还没有到 64，暂时不树化，而是进行扩容.</span><br><span class="line">              //否则才会真正的树化 -&gt; 剪枝</span><br><span class="line">              final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">                int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">                if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">                    resize();</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><h5 id="注意事项和细节-44"><a href="#注意事项和细节-44" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li><p>存放的元素是键值对：即K-V</p></li><li><p>hashtable 的键和值都不能为 null， 否则会抛出NullPointerException</p></li><li><p>hashTable 使用方法基本上和 HashMap 一样</p></li><li><p>hashTable 是线程安全的(synchronized)，hashmap 是线程不安全的</p></li></ul><h5 id="底层机制-2"><a href="#底层机制-2" class="headerlink" title="底层机制"></a>底层机制</h5><ul><li><p>底层有数组 Hashtable$Entry[] 初始化大小为 11</p></li><li><p>临界值 threshold 8 &#x3D; 11 * 0.75</p></li><li><p>扩容: 按照自己的扩容机制来进行即可</p></li><li><p>执行 方法 addEntry(hash, key, value, index); 添加K-V 封装到Entry</p></li><li><p>当 if (count &gt;&#x3D; threshold) 满足时，就进行扩容</p></li><li><p>按照 int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;的大小扩容</p></li></ul><h5 id="Hashtable-和-HashMapd"><a href="#Hashtable-和-HashMapd" class="headerlink" title="Hashtable 和 HashMapd"></a>Hashtable 和 HashMapd</h5><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121912279.png" alt="image-20221012191218054"></p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><h5 id="底层机制和源码剖析-1"><a href="#底层机制和源码剖析-1" class="headerlink" title="底层机制和源码剖析"></a>底层机制和源码剖析</h5><ul><li>若按照 compare 方法比较 key 相同则无法加入 value 值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMap_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //使用默认的构造器，创建TreeMap, 是字母排序</span><br><span class="line">        /*</span><br><span class="line">            要求：按照传入的 k(String) 的大小进行排序</span><br><span class="line">         */</span><br><span class="line">//        TreeMap treeMap = new TreeMap();</span><br><span class="line">        TreeMap treeMap = new TreeMap(new Comparator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Object o1, Object o2) &#123;</span><br><span class="line">                //按照传入的 k(String) 的大小进行排序</span><br><span class="line">                //按照K(String) 的长度大小排序</span><br><span class="line">                //return ((String) o2).compareTo((String) o1);</span><br><span class="line">                return ((String) o2).length() - ((String) o1).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(&quot;jack&quot;, &quot;杰克&quot;);</span><br><span class="line">        treeMap.put(&quot;tom&quot;, &quot;汤姆&quot;);</span><br><span class="line">        treeMap.put(&quot;kristina&quot;, &quot;克瑞斯提诺&quot;);</span><br><span class="line">        treeMap.put(&quot;smith&quot;, &quot;斯密斯&quot;);</span><br><span class="line">        treeMap.put(&quot;hsp&quot;, &quot;韩顺平&quot;);//加入不了</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;treemap=&quot; + treeMap);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            解读源码：</span><br><span class="line">            1. 构造器. 把传入的实现了 Comparator接口的匿名内部类(对象)，传给给TreeMap的comparator</span><br><span class="line">             public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">                this.comparator = comparator;</span><br><span class="line">            &#125;</span><br><span class="line">            2. 调用put方法</span><br><span class="line">            2.1 第一次添加, 把k-v 封装到 Entry对象，放入root</span><br><span class="line">            Entry&lt;K,V&gt; t = root;</span><br><span class="line">            if (t == null) &#123;</span><br><span class="line">                compare(key, key); // type (and possibly null) check</span><br><span class="line"></span><br><span class="line">                root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">                size = 1;</span><br><span class="line">                modCount++;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            2.2 以后添加</span><br><span class="line">            Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">            if (cpr != null) &#123;</span><br><span class="line">                do &#123; //遍历所有的key , 给当前key找到适当位置</span><br><span class="line">                    parent = t;</span><br><span class="line">                    cmp = cpr.compare(key, t.key);//动态绑定到我们的匿名内部类的compare</span><br><span class="line">                    if (cmp &lt; 0)</span><br><span class="line">                        t = t.left;</span><br><span class="line">                    else if (cmp &gt; 0)</span><br><span class="line">                        t = t.right;</span><br><span class="line">                    else  //如果遍历过程中，发现准备添加Key 和当前已有的Key 相等，就不添加</span><br><span class="line">                        return t.setValue(value);</span><br><span class="line">                &#125; while (t != null);</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><h5 id="注意事项和细节-45"><a href="#注意事项和细节-45" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li><p>Properties 类继承 Hashtable 类，实现了 Map 接口，也是使用一种键值对的形式保存数据 </p></li><li><p>使用特点和 Hashtable 类似 </p></li><li><p>Properties 还可以用于 从xxx.properties 文件中，加载数据到 Properties 类对象井进行读取和修改 </p></li><li><p><strong>xxx.properties 文件通常作为配置文件</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Properties_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      </span><br><span class="line">        //1. Properties 继承  Hashtable</span><br><span class="line">        //2. 可以通过 k-v 存放数据，当然key 和 value 不能为 null</span><br><span class="line">        //增加</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        //properties.put(null, &quot;abc&quot;);//抛出 空指针异常</span><br><span class="line">        //properties.put(&quot;abc&quot;, null); //抛出 空指针异常</span><br><span class="line">        properties.put(&quot;john&quot;, 100);//k-v</span><br><span class="line">        properties.put(&quot;lucy&quot;, 100);</span><br><span class="line">        properties.put(&quot;lic&quot;, 100);</span><br><span class="line">        properties.put(&quot;lic&quot;, 88);//如果有相同的key ， value被替换</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line"></span><br><span class="line">        //通过k 获取对应值</span><br><span class="line">        System.out.println(properties.get(&quot;lic&quot;));//88</span><br><span class="line"></span><br><span class="line">        //删除</span><br><span class="line">        properties.remove(&quot;lic&quot;);</span><br><span class="line">        System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line"></span><br><span class="line">        //修改</span><br><span class="line">        properties.put(&quot;john&quot;, &quot;约翰&quot;);</span><br><span class="line">        System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><h4 id="基本介绍-48"><a href="#基本介绍-48" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>Collections 是一个操作 Set.List 和 Map 等集合的工具类</p></li><li><p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</p></li></ul><h4 id="常用方法-14"><a href="#常用方法-14" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h5><ul><li><p>reverse (List)：反转 List 中元素顺序</p></li><li><p>shuffle(List)：对 List 集合元素进行随机排序</p></li><li><p>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</p></li><li><p>sort(List, Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p></li><li><p>swap (List, int,int)：将指定 list 集合中的 i处元素和j处元素进行交换</p></li></ul><h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><ul><li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 </p></li><li><p>Object max(Collection, Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 </p></li><li><p>Object min(Collection) </p></li><li><p>Object min(Collection, Comparator) </p></li><li><p>int frequency(Collection, Object)：返回指定集合中指定元素的出现次数 </p></li><li><p>void copy(List dest, List src)：将src中的内容复制到dest中 </p></li><li><p>boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换 List 对象的所有旧值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class Collections_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //创建ArrayList 集合，用于测试.</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(&quot;tom&quot;);</span><br><span class="line">        list.add(&quot;smith&quot;);</span><br><span class="line">        list.add(&quot;king&quot;);</span><br><span class="line">        list.add(&quot;milan&quot;);</span><br><span class="line">        list.add(&quot;tom&quot;);</span><br><span class="line"></span><br><span class="line">//        reverse(List)：反转 List 中元素的顺序</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">//        shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">//        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">//            Collections.shuffle(list);</span><br><span class="line">//            System.out.println(&quot;list=&quot; + list);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//        sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(&quot;自然排序后&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">//        sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">        //我们希望按照 字符串的长度大小排序</span><br><span class="line">        Collections.sort(list, new Comparator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Object o1, Object o2) &#123;</span><br><span class="line">                //可以加入校验代码.</span><br><span class="line">                return ((String) o2).length() - ((String) o1).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;字符串长度大小排序=&quot; + list);</span><br><span class="line">//        swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br><span class="line"></span><br><span class="line">        //比如</span><br><span class="line">        Collections.swap(list, 0, 1);</span><br><span class="line">        System.out.println(&quot;交换后的情况&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">        //Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span><br><span class="line">        System.out.println(&quot;自然顺序最大元素=&quot; + Collections.max(list));</span><br><span class="line">        //Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span><br><span class="line">        //比如，我们要返回长度最大的元素</span><br><span class="line">        Object maxObject = Collections.max(list, new Comparator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Object o1, Object o2) &#123;</span><br><span class="line">                return ((String)o1).length() - ((String)o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;长度最大的元素=&quot; + maxObject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //Object min(Collection)</span><br><span class="line">        //Object min(Collection，Comparator)</span><br><span class="line">        //上面的两个方法，参考max即可</span><br><span class="line"></span><br><span class="line">        //int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span><br><span class="line">        System.out.println(&quot;tom出现的次数=&quot; + Collections.frequency(list, &quot;tom&quot;));</span><br><span class="line"></span><br><span class="line">        //void copy(List dest,List src)：将src中的内容复制到dest中</span><br><span class="line"></span><br><span class="line">        ArrayList dest = new ArrayList();</span><br><span class="line">        //为了完成一个完整拷贝，我们需要先给dest 赋值，大小和list.size()一样</span><br><span class="line">        for(int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            dest.add(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //拷贝</span><br><span class="line">        Collections.copy(dest, list);</span><br><span class="line">        System.out.println(&quot;dest=&quot; + dest);</span><br><span class="line"></span><br><span class="line">        //boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span><br><span class="line">        //如果list中，有tom 就替换成 汤姆</span><br><span class="line">        Collections.replaceAll(list, &quot;tom&quot;, &quot;汤姆&quot;);</span><br><span class="line">        System.out.println(&quot;list替换后=&quot; + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结⭐️⭐️"><a href="#总结⭐️⭐️" class="headerlink" title="总结⭐️⭐️"></a><strong>总结⭐️⭐️</strong></h3><h4 id="选择集合"><a href="#选择集合" class="headerlink" title="选择集合"></a>选择集合</h4><ul><li>先判断存储的类型（一组对象[单列]或一组键值对[双列]） </li><li>一组对象[单列]： Collection接口 <ul><li>允许重复：List<ul><li>增删多：LinkedList  [底层维护双向链表]</li><li>改查多：ArrayList  [底层維护 Object类型的可变数组]</li></ul></li><li>不允许重复：Set <ul><li>无序：HashSet  [底层是HashMap，维护了一个哈希表，即(数组＋链表＋红黑树)] </li><li>排序：Treeset  [] 插入和取出顺序一致：LinkedHashSet  [底层维护数组＋双向链表]</li></ul></li><li>一组键[值对双列]：Map </li><li>键无序：HashMap  [底层是：哈希表  jdk7：数组＋链表，jdk8:数组＋链表＋红黑树]</li><li>键排序：TreeMap  []</li><li>键插入和取出顺序一致：LinkedHashMap</li><li>读取文件 Propertie</li></ul></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="基本介绍-49"><a href="#基本介绍-49" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>泛型又称参数化类型（接收数据类型的数据类型，是 Jdk5.0 出现的新特性,解决数据类型的安全性问题</li><li>在类声明或实例化时只要指定好需要的具体的类型即可</li><li>Java 泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生 ClassCastException 异常。同时，代码更加简洁、健壮</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class GenericExercise02 &#123;</span><br><span class="line"></span><br><span class="line">    public MyDate(int year, int month, int day) &#123;</span><br><span class="line">        this.year = year;</span><br><span class="line">        this.month = month;</span><br><span class="line">        this.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getYear() &#123;</span><br><span class="line">        return year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setYear(int year) &#123;</span><br><span class="line">        this.year = year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMonth() &#123;</span><br><span class="line">        return month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMonth(int month) &#123;</span><br><span class="line">        this.month = month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDay() &#123;</span><br><span class="line">        return day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDay(int day) &#123;</span><br><span class="line">        this.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyDate&#123;&quot; +</span><br><span class="line">                &quot;year=&quot; + year +</span><br><span class="line">                &quot;, month=&quot; + month +</span><br><span class="line">                &quot;, day=&quot; + day +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(MyDate o) &#123;</span><br><span class="line">        int yearMinus = year - o.year;</span><br><span class="line">        if (yearMinus != 0) &#123;</span><br><span class="line">            return yearMinus;</span><br><span class="line">        &#125;</span><br><span class="line">        int monthMinus = month - o.month;</span><br><span class="line">        if (monthMinus != 0) &#123;</span><br><span class="line">            return monthMinus;</span><br><span class="line">        &#125;</span><br><span class="line">        return day - o.day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a><strong>自定义泛型</strong></h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><strong>泛型类</strong></h4><h5 id="基本语法-12"><a href="#基本语法-12" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名&lt;T,R...&gt;&#123;</span><br><span class="line">  成员;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意事项和细节-46"><a href="#注意事项和细节-46" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>普通成员可以使用泛型（属性、方法） </li><li>使用泛型的数组，不能初始化 </li><li>静态方法中不能使用类的泛型 </li><li>泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型） </li><li>如果在创建对象时，没有指定类型，默认为 Object</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class CustomGeneric_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //T=Double, R=String, M=Integer</span><br><span class="line">        Tiger&lt;Double,String,Integer&gt; g = new Tiger&lt;&gt;(&quot;john&quot;);</span><br><span class="line">        g.setT(10.9); //OK</span><br><span class="line">        //g.setT(&quot;yy&quot;); //错误，类型不对</span><br><span class="line">        System.out.println(g);</span><br><span class="line">        Tiger g2 = new Tiger(&quot;john~~&quot;);//OK T=Object R=Object M=Object</span><br><span class="line">        g2.setT(&quot;yy&quot;); //OK ,因为 T=Object &quot;yy&quot;=String 是Object子类</span><br><span class="line">        System.out.println(&quot;g2=&quot; + g2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//1. Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类</span><br><span class="line">//2, T, R, M 泛型的标识符, 一般是单个大写字母</span><br><span class="line">//3. 泛型标识符可以有多个.</span><br><span class="line">//4. 普通成员可以使用泛型 (属性、方法)</span><br><span class="line">//5. 使用泛型的数组，不能初始化</span><br><span class="line">//6. 静态方法中不能使用类的泛型</span><br><span class="line">class Tiger&lt;T, R, M&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    R r; //属性使用到泛型</span><br><span class="line">    M m;</span><br><span class="line">    T t;</span><br><span class="line">    //因为数组在new 不能确定T的类型，就无法在内存开空间</span><br><span class="line">    T[] ts;</span><br><span class="line"></span><br><span class="line">    public Tiger(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Tiger(R r, M m, T t) &#123;//构造器使用泛型</span><br><span class="line"></span><br><span class="line">        this.r = r;</span><br><span class="line">        this.m = m;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Tiger(String name, R r, M m, T t) &#123;//构造器使用泛型</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.r = r;</span><br><span class="line">        this.m = m;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //因为静态是和类相关的，在类加载时，对象还没有创建</span><br><span class="line">    //所以，如果静态方法和静态属性使用了泛型，JVM就无法完成初始化</span><br><span class="line">//    static R r2;</span><br><span class="line">//    public static void m1(M m) &#123;</span><br><span class="line">//</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    //方法使用泛型</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public R getR() &#123;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setR(R r) &#123;//方法使用到泛型</span><br><span class="line">        this.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public M getM() &#123;//返回类型可以使用泛型.</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setM(M m) &#123;</span><br><span class="line">        this.m = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Tiger&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, r=&quot; + r +</span><br><span class="line">                &quot;, m=&quot; + m +</span><br><span class="line">                &quot;, t=&quot; + t +</span><br><span class="line">                &quot;, ts=&quot; + Arrays.toString(ts) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a><strong>泛型接口</strong></h4><h5 id="基本语法-13"><a href="#基本语法-13" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&lt;T,R...&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="注意事项和细节-47"><a href="#注意事项和细节-47" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>静态成员不能使用泛型 </li><li>泛型接口的类型，在继承接口或者实现接口时确定 </li><li>没有指定类型，默认为 Object</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class CustomInterfaceGeneric &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  泛型接口使用的说明</span><br><span class="line"> *  1. 接口中，静态成员也不能使用泛型</span><br><span class="line"> *  2. 泛型接口的类型, 在继承接口或者实现接口时确定</span><br><span class="line"> *  3. 没有指定类型，默认为Object</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//在继承接口 指定泛型接口的类型</span><br><span class="line">interface IA extends IUsb&lt;String, Double&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//当我们去实现IA接口时，因为IA在继承IUsu 接口时，指定了U 为String R为Double</span><br><span class="line">//，在实现IUsu接口的方法时，使用String替换U, 是Double替换R</span><br><span class="line">class AA implements IA &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double get(String s) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void hi(Double aDouble) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(Double r1, Double r2, String u1, String u2) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现接口时，直接指定泛型接口的类型</span><br><span class="line">//给U 指定Integer 给 R 指定了 Float</span><br><span class="line">//所以，当我们实现IUsb方法时，会使用Integer替换U, 使用Float替换R</span><br><span class="line">class BB implements IUsb&lt;Integer, Float&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Float get(Integer integer) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hi(Float aFloat) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(Float r1, Float r2, Integer u1, Integer u2) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//没有指定类型，默认为Object</span><br><span class="line">//建议直接写成 IUsb&lt;Object,Object&gt;</span><br><span class="line">class CC implements IUsb &#123; //等价 class CC implements IUsb&lt;Object,Object&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object get(Object o) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void hi(Object o) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(Object r1, Object r2, Object u1, Object u2) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IUsb&lt;U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    int n = 10;</span><br><span class="line">    //U name; 不能这样使用</span><br><span class="line"></span><br><span class="line">    //普通方法中，可以使用接口泛型</span><br><span class="line">    R get(U u);</span><br><span class="line"></span><br><span class="line">    void hi(R r);</span><br><span class="line"></span><br><span class="line">    void run(R r1, R r2, U u1, U u2);</span><br><span class="line"></span><br><span class="line">    //在jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型</span><br><span class="line">    default R method(U u) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a><strong>泛型方法</strong></h4><h5 id="基本语法-14"><a href="#基本语法-14" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符&lt;T,R...&gt;返回类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="注意事项和细节-48"><a href="#注意事项和细节-48" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li>泛型方法，可以定义在普通类中，也可以定义在泛型类中 </li><li>当泛型方法被调用时，类型会确定 </li><li>public void eat(E e) {}, 修饰符后没有&lt;T,R..＞, eat 方法不是泛型方法，而是使用了泛型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class CustomMethodGeneric &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Car car = new Car();</span><br><span class="line">        car.fly(&quot;宝马&quot;, 100);//当调用方法时，传入参数，编译器，就会确定类型</span><br><span class="line">        System.out.println(&quot;=======&quot;);</span><br><span class="line">        car.fly(300, 100.1);//当调用方法时，传入参数，编译器，就会确定类型</span><br><span class="line"></span><br><span class="line">        //测试</span><br><span class="line">        //T-&gt;String, R-&gt; ArrayList</span><br><span class="line">        Fish&lt;String, ArrayList&gt; fish = new Fish&lt;&gt;();</span><br><span class="line">        fish.hello(new ArrayList(), 11.3f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//泛型方法，可以定义在普通类中, 也可以定义在泛型类中</span><br><span class="line">class Car &#123;//普通类</span><br><span class="line"></span><br><span class="line">    public void run() &#123;//普通方法</span><br><span class="line">    &#125;</span><br><span class="line">    //说明 泛型方法</span><br><span class="line">    //1. &lt;T,R&gt; 就是泛型</span><br><span class="line">    //2. 是提供给 fly使用的</span><br><span class="line">    public &lt;T, R&gt; void fly(T t, R r) &#123;//泛型方法</span><br><span class="line">        System.out.println(t.getClass());//String</span><br><span class="line">        System.out.println(r.getClass());//Integer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fish&lt;T, R&gt; &#123;//泛型类</span><br><span class="line">    public void run() &#123;//普通方法</span><br><span class="line">    &#125;</span><br><span class="line">    public&lt;U,M&gt; void eat(U u, M m) &#123;//泛型方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //说明</span><br><span class="line">    //1. 下面hi方法不是泛型方法</span><br><span class="line">    //2. 是hi方法使用了类声明的 泛型</span><br><span class="line">    public void hi(T t) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</span><br><span class="line">    public&lt;K&gt; void hello(R r, K k) &#123;</span><br><span class="line">        System.out.println(r.getClass());//ArrayList</span><br><span class="line">        System.out.println(k.getClass());//Float</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型继承和通配符"><a href="#泛型继承和通配符" class="headerlink" title="泛型继承和通配符"></a><strong>泛型继承和通配符</strong></h3><h4 id="注意事项和细节-49"><a href="#注意事项和细节-49" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li><strong>泛型不具备继承性</strong> </li><li>支持任意泛型类型 </li><li>支持 A 类以及 A 类的子类，规定了泛型的上限 </li><li>支持 A 类以及 A 类的父类，不限于直接父类，规定了泛型的下限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public class GenericExtends &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Object o = new String(&quot;xx&quot;);</span><br><span class="line"></span><br><span class="line">        //泛型没有继承性</span><br><span class="line">        //List&lt;Object&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        //举例说明下面三个方法的使用</span><br><span class="line">        List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;AA&gt; list3 = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;BB&gt; list4 = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;CC&gt; list5 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //如果是 List&lt;?&gt; c ，可以接受任意的泛型类型</span><br><span class="line">        printCollection1(list1);</span><br><span class="line">        printCollection1(list2);</span><br><span class="line">        printCollection1(list3);</span><br><span class="line">        printCollection1(list4);</span><br><span class="line">        printCollection1(list5);</span><br><span class="line"></span><br><span class="line">        //List&lt;? extends AA&gt; c： 表示 上限，可以接受 AA或者AA子类</span><br><span class="line">//        printCollection2(list1);//×</span><br><span class="line">//        printCollection2(list2);//×</span><br><span class="line">        printCollection2(list3);//√</span><br><span class="line">        printCollection2(list4);//√</span><br><span class="line">        printCollection2(list5);//√</span><br><span class="line"></span><br><span class="line">        //List&lt;? super AA&gt; c: 支持AA类以及AA类的父类，不限于直接父类</span><br><span class="line">        printCollection3(list1);//√</span><br><span class="line">        //printCollection3(list2);//×</span><br><span class="line">        printCollection3(list3);//√</span><br><span class="line">        //printCollection3(list4);//×</span><br><span class="line">        //printCollection3(list5);//×</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //冒泡排序</span><br><span class="line"></span><br><span class="line">        //插入排序</span><br><span class="line"></span><br><span class="line">        //....</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // ? extends AA 表示 上限，可以接受 AA或者AA子类</span><br><span class="line">    public static void printCollection2(List&lt;? extends AA&gt; c) &#123;</span><br><span class="line">        for (Object object : c) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受</span><br><span class="line">    public static void printCollection1(List&lt;?&gt; c) &#123;</span><br><span class="line">        for (Object object : c) &#123; // 通配符，取出时，就是Object</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // ? super 子类类名AA:支持AA类以及AA类的父类，不限于直接父类，</span><br><span class="line">    //规定了泛型的下限</span><br><span class="line">    public static void printCollection3(List&lt;? super AA&gt; c) &#123;</span><br><span class="line">        for (Object object : c) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BB extends AA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CC extends BB &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HomeWork01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testList() &#123;</span><br><span class="line">         DAO&lt;User&gt; dao = new DAO&lt;User&gt;();</span><br><span class="line">         dao.save(&quot;001&quot;,new User(1,10,&quot;jack&quot;));</span><br><span class="line">         dao.save(&quot;002&quot;,new User(2,11,&quot;tom&quot;));</span><br><span class="line">         dao.save(&quot;003&quot;,new User(3,12,&quot;mike&quot;));</span><br><span class="line">        List&lt;User&gt; list = dao.list();</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        dao.update(&quot;002&quot;,new User(2,14,&quot;faker&quot;));</span><br><span class="line">        List&lt;User&gt; list1 = dao.list();</span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        dao.delete(&quot;001&quot;);</span><br><span class="line">        List&lt;User&gt; list2 = dao.list();</span><br><span class="line">        System.out.println(list2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GUI-可忽略"><a href="#GUI-可忽略" class="headerlink" title="GUI(可忽略)"></a>GUI(可忽略)</h2><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><h4 id="绘图原理"><a href="#绘图原理" class="headerlink" title="绘图原理"></a>绘图原理</h4><ul><li><p>Component 类提供了两个和绘图相关最重要的方法 </p><ul><li>paint(Graphics g)绘制组件的外观</li><li>repaint()刷新组件的外观</li></ul></li><li><p>当组件第一次在屏幕显示的时候,程序会自动的调用 paint0 方法来绘制组件，在以下情况 paintQ 将会被调用： </p></li><li><p>窗口最小化,再最大化</p></li><li><p>窗口的大小发生变化</p></li><li><p>repaint函数被调用</p></li></ul><h4 id="Graphics类"><a href="#Graphics类" class="headerlink" title="Graphics类"></a>Graphics类</h4><ul><li><p>画直线 drawLine(int x1,int yl,int x2,int y2)</p></li><li><p>画矩形边框 drawRect(int x, int y, int width, int height)</p></li><li><p>画椭圆边框 drawOval(int x, int y, int width, int height)</p></li><li><p>填充矩形fillRect(int x, int y, int width, int height)</p></li><li><p>填充椭园 fillOval(int x, int y. int width, int height)</p></li><li><p>画图片 drawlmage(Image img, int x, int y, …)</p></li><li><p>画字符串 drawString(String str, int x, inty)</p></li><li><p>设置画笔的字体 setFont (Font font)</p></li><li><p>设置画笔的颜色 setColor(Color c)</p></li></ul><h3 id="事件控制"><a href="#事件控制" class="headerlink" title="事件控制"></a>事件控制</h3><h4 id="基本介绍-50"><a href="#基本介绍-50" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>java 事件处理是采取“委派事件模型”。当事件发生时,产生事件的对象,会把此”信息”传递给”事件的监听者” 处理，这里所说的”信息”实际上就是 java.awt.event 事件类库里某个类所创建的对象，把它称为”事件的对象“</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121549216.png" alt="image-20221012154913040"></p><h4 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h4><ul><li>事件源<ul><li>事件源是一个产生事件的对象，比如按钮，窗口等</li></ul></li><li>事件<ul><li>事件就是承载事件源状态改变时的对象，比如当键盘事件、鼠标事件、窗口事件等等，会生成一个事件对象，该对家保存着当前事件很多信息，比如KeyEvent 对象有含有被按下键的Gode值。</li><li>java.awt.event包 和javax.swing.event包中定义了各种事 件类型</li></ul></li><li>事件类型：</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121548482.png" alt="image-20221012154837298"></p><ul><li>事件监听噐号接口<ul><li>当事件源产生一个事件，可以传送给事件监听者处理Interfaces </li><li>事件监听者本质是一个类，该类实现了某个事件监听器接口比如前面我们案例中的 MyPanle 就是一个类，它实现了 KeyListener 接口，它就可以作为一个事件监听者，对接受到的事件进行处理 </li><li>事件监听器接口有多种，不同的事件监听器接口可以监听不同的事件 一个类可以实现多个监听接口 </li><li>这些接口在 java.awt.event 包和 javax.swing.event包中定义，列出常用的事件监听器接口，查看 jdk 文档聚集了</li></ul></li></ul><h2 id="线程-基础"><a href="#线程-基础" class="headerlink" title="线程(基础)"></a>线程(基础)</h2><h3 id="基本介绍-51"><a href="#基本介绍-51" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li><p>线程由进程创建的，是进程的一个实体</p></li><li><p>一个进程可以拥有多个线程</p></li><li><p>单线程：同一个时刻，只允许执行一个线程</p></li><li><p>多线程：同一个时刻，可以执行多个线程</p></li><li><p>并发：同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉</p></li><li><p>并行：同一个时刻，多个任务同时执行，多核 cpu 可以实现并行</p></li></ul><h3 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h3><h4 id="继承-Thread"><a href="#继承-Thread" class="headerlink" title="继承 Thread"></a>继承 Thread</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Thread01 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //创建Cat对象，可以当做线程使用</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line"></span><br><span class="line">        //源码</span><br><span class="line">        /*</span><br><span class="line">            (1)</span><br><span class="line">            public synchronized void start() &#123;</span><br><span class="line">                start0();</span><br><span class="line">            &#125;</span><br><span class="line">            (2)</span><br><span class="line">            //start0() 是本地方法，是JVM调用, 底层是c/c++实现</span><br><span class="line">            //真正实现多线程的效果，是start0(), 而不是 run</span><br><span class="line">            private native void start0();</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        cat.start();//启动线程-&gt; 最终会执行cat的run方法</span><br><span class="line"></span><br><span class="line">        //cat.run();//run方法就是一个普通的方法, 没有真正的启动一个线程，就会把run方法执行完毕，才向下执行</span><br><span class="line">        //说明: 当main线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行</span><br><span class="line">        //这时 主线程和子线程是交替执行..</span><br><span class="line">        System.out.println(&quot;主线程继续执行&quot; + Thread.currentThread().getName());//名字main</span><br><span class="line">        for(int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">            System.out.println(&quot;主线程 i=&quot; + i);</span><br><span class="line">            //让主线程休眠</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//1. 当一个类继承了 Thread 类， 该类就可以当做线程使用</span><br><span class="line">//2. 我们会重写 run方法，写上自己的业务代码</span><br><span class="line">//3. run Thread 类 实现了 Runnable 接口的run方法</span><br><span class="line">/*</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Cat extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    int times = 0;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;//重写run方法，写上自己的业务逻辑</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //该线程每隔1秒。在控制台输出 “喵喵, 我是小猫咪”</span><br><span class="line">            System.out.println(&quot;喵喵, 我是小猫咪&quot; + (++times) + &quot; 线程名=&quot; + Thread.currentThread().getName());</span><br><span class="line">            //让该线程休眠1秒 ctrl+alt+t</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if(times == 80) &#123;</span><br><span class="line">                break;//当times 到80, 退出while, 这时线程也就退出..</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-Runnable"><a href="#实现-Runnable" class="headerlink" title="实现 Runnable"></a><strong>实现 Runnable</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Thread02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        //dog.start(); 这里不能调用start</span><br><span class="line">        //创建了Thread对象，把 dog对象(实现Runnable),放入Thread</span><br><span class="line">        Thread thread = new Thread(dog);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">//        Tiger tiger = new Tiger();//实现了 Runnable</span><br><span class="line">//        ThreadProxy threadProxy = new ThreadProxy(tiger);</span><br><span class="line">//        threadProxy.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tiger extends Animal implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;老虎嗷嗷叫....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程代理类 , 模拟了一个极简的Thread类</span><br><span class="line">class ThreadProxy implements Runnable &#123;//你可以把Proxy类当做 ThreadProxy</span><br><span class="line"></span><br><span class="line">    private Runnable target = null;//属性，类型是 Runnable</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            target.run();//动态绑定（运行类型Tiger）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ThreadProxy(Runnable target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        start0();//这个方法时真正实现多线程方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start0() &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog implements Runnable &#123; //通过实现Runnable接口，开发线程</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123; //普通方法</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;小狗汪汪叫..hi&quot; + (++count) + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            //休眠1秒</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (count == 10) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比-2"><a href="#对比-2" class="headerlink" title="对比"></a>对比</h4><ul><li>java 的设计来看，通过继承 Thread 或者实现 Runnable 接口来创建线程本质上没有区别,从 jdk 帮助文档我们可以看到Thread 类 本身就实现了 Runnable 接口</li><li>实现 Runnable 接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制</li></ul><h4 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a><strong>线程退出</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadExit_ &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        //如果希望main线程去控制t1 线程的终止, 必须可以修改 loop</span><br><span class="line">        //让t1 退出run方法，从而终止 t1线程 -&gt; 通知方式</span><br><span class="line"></span><br><span class="line">        //让主线程休眠 10 秒，再通知 t1线程退出</span><br><span class="line">        System.out.println(&quot;main线程休眠10s...&quot;);</span><br><span class="line">        Thread.sleep(10 * 1000);</span><br><span class="line">        t1.setLoop(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T extends Thread &#123;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    //设置一个控制变量</span><br><span class="line">    private boolean loop = true;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (loop) &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);// 让当前线程休眠50ms</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;T 运行中....&quot; + (++count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLoop(boolean loop) &#123;</span><br><span class="line">        this.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代理模式模拟"><a href="#代理模式模拟" class="headerlink" title="代理模式模拟"></a><strong>代理模式模拟</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class Thread02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        //dog.start(); 这里不能调用start</span><br><span class="line">        //创建了Thread对象，把 dog对象(实现Runnable),放入Thread</span><br><span class="line">        Thread thread = new Thread(dog);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">//        Tiger tiger = new Tiger();//实现了 Runnable</span><br><span class="line">//        ThreadProxy threadProxy = new ThreadProxy(tiger);</span><br><span class="line">//        threadProxy.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tiger extends Animal implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;老虎嗷嗷叫....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程代理类 , 模拟了一个极简的Thread类</span><br><span class="line">class ThreadProxy implements Runnable &#123;//你可以把Proxy类当做 ThreadProxy</span><br><span class="line"></span><br><span class="line">    private Runnable target = null;//属性，类型是 Runnable</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            target.run();//动态绑定（运行类型Tiger）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ThreadProxy(Runnable target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        start0();//这个方法时真正实现多线程方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start0() &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog implements Runnable &#123; //通过实现Runnable接口，开发线程</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123; //普通方法</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;小狗汪汪叫..hi&quot; + (++count) + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            //休眠1秒</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (count == 10) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a><strong>线程方法</strong></h3><h4 id="常用方法1"><a href="#常用方法1" class="headerlink" title="常用方法1"></a><strong>常用方法1</strong></h4><ul><li>setName：设置线程名称，使之与参数 name 相同 </li><li>getName：返回该线程的名称 </li><li>start：使该线程开始执行;Java 虚拟机底层调用该线程start0方法 </li><li>run ：调用线程对象 run 方法 </li><li>setPriority：更改线程的优先级 </li><li>getPriority：获取线程的优先级 </li><li>sleep：在指定的毫秒数内让当前正在执行的线程休眠（暂停执行) </li><li>interrupt：中断线程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadMethod01 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //测试相关的方法</span><br><span class="line">        T t = new T();</span><br><span class="line">        t.setName(&quot;老韩&quot;);</span><br><span class="line">        t.setPriority(Thread.MIN_PRIORITY);//1</span><br><span class="line">        t.start();//启动子线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //主线程打印5 hi ,然后我就中断 子线程的休眠</span><br><span class="line">        for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;hi &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(t.getName() + &quot; 线程的优先级 =&quot; + t.getPriority());//1</span><br><span class="line"></span><br><span class="line">        t.interrupt();//当执行到这里，就会中断 t线程的休眠.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T extends Thread &#123; //自定义的线程类</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                //Thread.currentThread().getName() 获取当前线程的名称</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;  吃包子~~~~&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 休眠中~~~&quot;);</span><br><span class="line">                Thread.sleep(20000);//20秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                //当该线程执行到一个interrupt 方法时，就会catch 一个 异常, 可以加入自己的业务代码</span><br><span class="line">                //InterruptedException 是捕获到一个中断异常.</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;被 interrupt了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项和细节</p><ul><li>start：底层会创建新的线程，调用 run，run 就是一个简单的方法调用，不会启动新线程</li><li>interrupt：中断线程，但并没有真正的结束线程，所以一般用于中断正在休眠线程</li><li>sleep：线程的静态方法，使当前线程休眠</li></ul><h4 id="常用方法2"><a href="#常用方法2" class="headerlink" title="常用方法2"></a>常用方法2</h4><ul><li>yield：线程的礼让。让出 Cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功 </li><li>join：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadMethod02 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        T2 t2 = new T2();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;主线程(小弟) 吃了 &quot; + i  + &quot; 包子&quot;);</span><br><span class="line">            if(i == 5) &#123;</span><br><span class="line">                System.out.println(&quot;主线程(小弟) 让 子线程(老大) 先吃&quot;);</span><br><span class="line">                //join, 线程插队</span><br><span class="line">                //t2.join();// 这里相当于让t2 线程先执行完毕</span><br><span class="line">                Thread.yield();//礼让，不一定成功..</span><br><span class="line">                System.out.println(&quot;线程(老大) 吃完了 主线程(小弟) 接着吃..&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T2 extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);//休眠1秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;子线程(老大) 吃了 &quot; + i +  &quot; 包子&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h4><ul><li>用户线程：也叫工作线程，当线程的任务执行完或通知方式结束 </li><li>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束 setDaemon(True) </li><li>常见的守护线程：垃圾回收机制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadMethod03 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyDaemonThread myDaemonThread = new MyDaemonThread();</span><br><span class="line">        //如果我们希望当main线程结束后，子线程自动结束</span><br><span class="line">        //只需将子线程设为守护线程即可</span><br><span class="line">        myDaemonThread.setDaemon(true);</span><br><span class="line">        myDaemonThread.start();</span><br><span class="line"></span><br><span class="line">        for( int i = 1; i &lt;= 10; i++) &#123;//main线程</span><br><span class="line">            System.out.println(&quot;辛苦的工作...&quot;);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyDaemonThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (; ; ) &#123;//无限循环</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);//休眠1000毫秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;快乐聊天，哈哈哈~~~&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h4><ul><li>周期图</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121923354.png" alt="image-20221012192356174"></p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a><strong>Synchronized</strong></h4><h5 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a><strong>线程同步机制</strong></h5><ul><li>线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</li></ul><h5 id="基本语法-15"><a href="#基本语法-15" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同步代码块</span><br><span class="line">synchronized(对象) &#123; // 得到对象的锁，才能操作同步代码</span><br><span class="line">  需要被同步代码；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同步方法</span><br><span class="line">public synchronized void m(String name)&#123;</span><br><span class="line">  需要被同步代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class SellTicket &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        SellTicket03 sellTicket03 = new SellTicket03();</span><br><span class="line">        new Thread(sellTicket03).start();//第1个线程-窗口</span><br><span class="line">        new Thread(sellTicket03).start();//第2个线程-窗口</span><br><span class="line">        new Thread(sellTicket03).start();//第3个线程-窗口</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现接口方式, 使用synchronized实现线程同步</span><br><span class="line">class SellTicket03 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    private boolean loop = true;//控制run方法变量</span><br><span class="line">    Object object = new Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //同步方法（静态的）的锁为当前类本身</span><br><span class="line">    //老韩解读</span><br><span class="line">    //1. public synchronized static void m1() &#123;&#125; 锁是加在 SellTicket03.class</span><br><span class="line">    //2. 如果在静态方法中，实现一个同步代码块.</span><br><span class="line">    /*</span><br><span class="line">        synchronized (SellTicket03.class) &#123;</span><br><span class="line">            System.out.println(&quot;m2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">     */</span><br><span class="line">    public synchronized static void m1() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static  void m2() &#123;</span><br><span class="line">        synchronized (SellTicket03.class) &#123;</span><br><span class="line">            System.out.println(&quot;m2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //老韩说明</span><br><span class="line">    //1. public synchronized void sell() &#123;&#125; 就是一个同步方法</span><br><span class="line">    //2. 这时锁在 this对象</span><br><span class="line">    //3. 也可以在代码块上写 synchronize ,同步代码块, 互斥锁还是在this对象</span><br><span class="line">    public /*synchronized*/ void sell() &#123; //同步方法, 在同一时刻， 只能有一个线程来执行sell方法</span><br><span class="line"></span><br><span class="line">        synchronized (/*this*/ object) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                loop = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (loop) &#123;</span><br><span class="line"></span><br><span class="line">            sell();//sell方法是一共同步方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥锁⭐️"><a href="#互斥锁⭐️" class="headerlink" title="互斥锁⭐️"></a>互斥锁⭐️</h4><h5 id="基本介绍-52"><a href="#基本介绍-52" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li><p>Java 语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性</p></li><li><p>每个对象都对应于一个可称为“互斥锁〞 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</p></li><li><p>关键字 synchronized 来与对象的互斥锁联系。当某个对象用synchronized 修饰时表明该<strong>对象在任一时刻只能由一个线程访问</strong></p></li><li><p>同步的局限性：导致程序的执行效率要降低</p></li><li><p>同步方法（非静态的）的锁可以是 this，也可以是其他对象（要求是同一个对象）</p></li><li><p>同步方法（静态的）的锁为当前类本身</p></li></ul><h5 id="注意事项和细节-50"><a href="#注意事项和细节-50" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul><li><p>同步方法如果没有使用 static 修饰：默认锁对象为 this </p></li><li><p>如果方法使用 static 修饰，默认锁对象：当前类.class </p></li><li><p>实现的落地步骤</p><ul><li><p>需要先分析上锁的代码 </p></li><li><p>选择同步代码块或同步方法 </p></li><li><p>要求多个线程的锁对象为同一个即可</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLock_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //模拟死锁现象</span><br><span class="line">        DeadLockDemo A = new DeadLockDemo(true);</span><br><span class="line">        A.setName(&quot;A线程&quot;);</span><br><span class="line">        DeadLockDemo B = new DeadLockDemo(false);</span><br><span class="line">        B.setName(&quot;B线程&quot;);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//线程</span><br><span class="line">class DeadLockDemo extends Thread &#123;</span><br><span class="line">    static Object o1 = new Object();// 保证多线程，共享一个对象,这里使用static</span><br><span class="line">    static Object o2 = new Object();</span><br><span class="line">    boolean flag;</span><br><span class="line"></span><br><span class="line">    public DeadLockDemo(boolean flag) &#123;//构造器</span><br><span class="line">        this.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        //下面业务逻辑的分析</span><br><span class="line">        //1. 如果flag 为 T, 线程A 就会先得到/持有 o1 对象锁, 然后尝试去获取 o2 对象锁</span><br><span class="line">        //2. 如果线程A 得不到 o2 对象锁，就会Blocked</span><br><span class="line">        //3. 如果flag 为 F, 线程B 就会先得到/持有 o2 对象锁, 然后尝试去获取 o1 对象锁</span><br><span class="line">        //4. 如果线程B 得不到 o1 对象锁，就会Blocked</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            synchronized (o1) &#123;//对象互斥锁, 下面就是同步代码</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 进入1&quot;);</span><br><span class="line">                synchronized (o2) &#123; // 这里获得li对象的监视权</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; 进入2&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            synchronized (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 进入3&quot;);</span><br><span class="line">                synchronized (o1) &#123; // 这里获得li对象的监视权</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; 进入4&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="基本介绍-53"><a href="#基本介绍-53" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li>多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生</li></ul><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><ul><li><p>当前线程的同步方法、同步代码块执行结束</p></li><li><p>当前线程在同步代码块、同步方法中遇到 break、return</p></li><li><p>当前线程在同步代码块、同步方法中出现了未处理的 Error 或Exception，导致异常结束</p></li><li><p>当前线程在同步代码块、同步方法中执行了线程对象的 wait()方法，当前线程暂停，井释放锁</p></li></ul><h5 id="不释放锁"><a href="#不释放锁" class="headerlink" title="不释放锁"></a>不释放锁</h5><ul><li><p>线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行</p></li><li><p>线程执行同步代码块时，其他线程调用了该线程的 suspend()方法将该线程挂起</p></li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>文件是保存数据的地方</li></ul><h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><h5 id="基本介绍-54"><a href="#基本介绍-54" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li>输入流：数据从数据源(文件)到程序(内存)的路径 </li><li>输出流：数据从程序(内存)到数据源(文件)的路径</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121932957.png" alt="image-20221012193205775"></p><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><ul><li>new File(String pathname) &#x2F;&#x2F;根据文件路径构建 </li><li>new File(File parent,String child) &#x2F;&#x2F;根据父目录文件+子路径构建 </li><li>new File(String parent,String child) &#x2F;&#x2F;根据父目录+子路径构建</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">ublic class FileCreate &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方式1 new File(String pathname)</span><br><span class="line">    @Test</span><br><span class="line">    public void create01() &#123;</span><br><span class="line">        String filePath = &quot;/Users/henghengzhu/Downloads/代码/news1.txt&quot;;</span><br><span class="line">        File file = new File(filePath);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            System.out.println(&quot;文件创建成功&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //方式2 new File(File parent,String child) //根据父目录文件+子路径构建</span><br><span class="line">    @Test</span><br><span class="line">    public  void create02() &#123;</span><br><span class="line">        File parentFile = new File(&quot;/Users/henghengzhu/Downloads/代码&quot;);</span><br><span class="line">        String fileName = &quot;news2.txt&quot;;</span><br><span class="line">        //这里的file对象，在java程序中，只是一个对象</span><br><span class="line">        //只有执行了createNewFile 方法，才会真正的，在磁盘创建该文件</span><br><span class="line">        File file = new File(parentFile, fileName);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            System.out.println(&quot;创建成功~&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方式3 new File(String parent,String child) //根据父目录+子路径构建</span><br><span class="line">    @Test</span><br><span class="line">    public void create03() &#123;</span><br><span class="line">        //String parentPath = &quot;e:\\&quot;;</span><br><span class="line">        String parentPath = &quot;/Users/henghengzhu/Downloads/&quot;;</span><br><span class="line">        String fileName = &quot;news3.txt&quot;;</span><br><span class="line">        File file = new File(parentPath, fileName);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            System.out.println(&quot;创建成功~&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用方法-15"><a href="#常用方法-15" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>file.getName() </li><li>file.getAbsolutePath() </li><li>file.getParent() </li><li>file.exists() </li><li>file.isFile() </li><li>file.isFile() </li><li>isDirectory()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void info() &#123;</span><br><span class="line">        //先创建文件对象</span><br><span class="line">        File file = new File(&quot;e:\\news1.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //调用相应的方法，得到对应信息</span><br><span class="line">        System.out.println(&quot;文件名字=&quot; + file.getName());</span><br><span class="line">        //getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory</span><br><span class="line">        System.out.println(&quot;文件绝对路径=&quot; + file.getAbsolutePath());</span><br><span class="line">        System.out.println(&quot;文件父级目录=&quot; + file.getParent());</span><br><span class="line">        System.out.println(&quot;文件大小(字节)=&quot; + file.length());</span><br><span class="line">        System.out.println(&quot;文件是否存在=&quot; + file.exists());//T</span><br><span class="line">        System.out.println(&quot;是不是一个文件=&quot; + file.isFile());//T</span><br><span class="line">        System.out.println(&quot;是不是一个目录=&quot; + file.isDirectory());//F</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="IO流原理及分类"><a href="#IO流原理及分类" class="headerlink" title="IO流原理及分类"></a>IO流原理及分类</h3><h4 id="基本介绍-55"><a href="#基本介绍-55" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术是非常实用的技术，用于处理数据传输 </p></li><li><p>Java 程序中，对于数据的输入&#x2F;输出操作以”流(stream)”的方式进行 </p></li><li><p>java.io 包下提供了各种”流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据 </p></li><li><p>输入 input：读取外部数据（磁盛、光盘等存储设备的数据）到程序（内存）中 </p></li><li><p>输出 output：将程序（内存）数据输出到磁盘、光盘等存储设备中</p></li></ul><h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ul><li><p>按操作数据单位不同分为：字节流(8 bit)，字符流(按字符） </p></li><li><p>按数据流的流向不同分为：输入流，输出流 </p></li><li><p>按流的角色的不同分为：节点流，处理流&#x2F;包装流</p></li></ul><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><h4 id="基本介绍-56"><a href="#基本介绍-56" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>节点流可以从一个特定的数据源读写数据，如 FileReader、FileWriter </p></li><li><p>处理流(也叫包装流)是 “连接〞在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如 BufferedReader、BufferedWriter</p></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121938872.png" alt="image-20221012193841639"></p><h4 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h4><ul><li><strong>节点流是底层流&#x2F;低级流,直接跟数据源相接</strong></li><li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供重方便的方法来完成输入输出</li><li>处理流(也叫包装流)对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</li><li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用重加灵活方便</li></ul><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a><strong>模拟</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BufferedReader_ bufferedReader_ = new BufferedReader_(new FileReader_());</span><br><span class="line">        bufferedReader_.readFiles(10);</span><br><span class="line">        BufferedReader_ bufferedReader_2 = new BufferedReader_(new StringReader_());</span><br><span class="line">        bufferedReader_2.readString(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入流⭐️"><a href="#输入流⭐️" class="headerlink" title="输入流⭐️"></a>输入流⭐️</h3><h4 id="基本介绍-57"><a href="#基本介绍-57" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121941447.png" alt="image-20221012194132269"></p><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><h6 id="常用方法-16"><a href="#常用方法-16" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h6><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121942186.png" alt="image-20221012194227880"></p><h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class FileInputStream_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 演示读取文件...</span><br><span class="line">     * 单个字节的读取，效率比较低</span><br><span class="line">     * -&gt; 使用 read(byte[] b)</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void readFile01() &#123;</span><br><span class="line">        String filePath = &quot;e:\\hello.txt&quot;;</span><br><span class="line">        int readData = 0;</span><br><span class="line">        FileInputStream fileInputStream = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建 FileInputStream 对象，用于读取 文件</span><br><span class="line">            fileInputStream = new FileInputStream(filePath);</span><br><span class="line">            //从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。</span><br><span class="line">            //如果返回-1 , 表示读取完毕</span><br><span class="line">            while ((readData = fileInputStream.read()) != -1) &#123;</span><br><span class="line">                System.out.print((char)readData);//转成char显示</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //关闭文件流，释放资源.</span><br><span class="line">            try &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用 read(byte[] b) 读取文件，提高效率</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void readFile02() &#123;</span><br><span class="line">        String filePath = &quot;e:\\hello.txt&quot;;</span><br><span class="line">        //字节数组</span><br><span class="line">        byte[] buf = new byte[8]; //一次读取8个字节.</span><br><span class="line">        int readLen = 0;</span><br><span class="line">        FileInputStream fileInputStream = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建 FileInputStream 对象，用于读取 文件</span><br><span class="line">            fileInputStream = new FileInputStream(filePath);</span><br><span class="line">            //从该输入流读取最多b.length字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。</span><br><span class="line">            //如果返回-1 , 表示读取完毕</span><br><span class="line">            //如果读取正常, 返回实际读取的字节数</span><br><span class="line">            while ((readLen = fileInputStream.read(buf)) != -1) &#123;</span><br><span class="line">                System.out.print(new String(buf, 0, readLen));//显示</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //关闭文件流，释放资源.</span><br><span class="line">            try &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a><strong>BufferedInputStream</strong></h5><h6 id="基本介绍-58"><a href="#基本介绍-58" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h6><ul><li>Bufferedlnputstream 是字节流在创建 Bufferedlnputstream 时，会创建一个内部缓沖区数组</li></ul><h5 id="常用方法-17"><a href="#常用方法-17" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h5><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121944974.png" alt="image-20221012194425661"></p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedCopy02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//        String srcFilePath = &quot;e:\\Koala.jpg&quot;;</span><br><span class="line">//        String destFilePath = &quot;e:\\hsp.jpg&quot;;</span><br><span class="line">//        String srcFilePath = &quot;e:\\0245_韩顺平零基础学Java_引出this.avi&quot;;</span><br><span class="line">//        String destFilePath = &quot;e:\\hsp.avi&quot;;</span><br><span class="line">        String srcFilePath = &quot;e:\\a.java&quot;;</span><br><span class="line">        String destFilePath = &quot;e:\\a3.java&quot;;</span><br><span class="line"></span><br><span class="line">        //创建BufferedOutputStream对象BufferedInputStream对象</span><br><span class="line">        BufferedInputStream bis = null;</span><br><span class="line">        BufferedOutputStream bos = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //因为 FileInputStream  是 InputStream 子类</span><br><span class="line">            bis = new BufferedInputStream(new FileInputStream(srcFilePath));</span><br><span class="line">            bos = new BufferedOutputStream(new FileOutputStream(destFilePath));</span><br><span class="line"></span><br><span class="line">            //循环的读取文件，并写入到 destFilePath</span><br><span class="line">            byte[] buff = new byte[1024];</span><br><span class="line">            int readLen = 0;</span><br><span class="line">            //当返回 -1 时，就表示文件读取完毕</span><br><span class="line">            while ((readLen = bis.read(buff)) != -1) &#123;</span><br><span class="line">                bos.write(buff, 0, readLen);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;文件拷贝完毕~~~&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">            //关闭流 , 关闭外层的处理流即可，底层会去关闭节点流</span><br><span class="line">            try &#123;</span><br><span class="line">                if(bis != null) &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if(bos != null) &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a><strong>ObjectInputStream</strong></h5><h6 id="基本介绍-59"><a href="#基本介绍-59" class="headerlink" title="基本介绍"></a>基本介绍</h6><ul><li>Objectlnputstream 提供反序列化功能</li><li>反序列化就是在恢复数据时，恢复数据的值和数据类型</li><li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：Serializable 和 Externalizable</li></ul><h6 id="例"><a href="#例" class="headerlink" title="例"></a><strong>例</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectInputStream_ &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        //指定反序列化的文件</span><br><span class="line">        String filePath = &quot;e:\\data.dat&quot;;</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath));</span><br><span class="line"></span><br><span class="line">        //解读</span><br><span class="line">        //1. 读取(反序列化)的顺序需要和你保存数据(序列化)的顺序一致</span><br><span class="line">        //2. 否则会出现异常</span><br><span class="line"></span><br><span class="line">        System.out.println(ois.readInt());</span><br><span class="line">        System.out.println(ois.readBoolean());</span><br><span class="line"></span><br><span class="line">        System.out.println(ois.readChar());</span><br><span class="line">        System.out.println(ois.readDouble());</span><br><span class="line">        System.out.println(ois.readUTF());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //dog 的编译类型是 Object , dog 的运行类型是 Dog</span><br><span class="line">        Object dog = ois.readObject();</span><br><span class="line">        System.out.println(&quot;运行类型=&quot; + dog.getClass());</span><br><span class="line">        System.out.println(&quot;dog信息=&quot; + dog);//底层 Object -&gt; Dog</span><br><span class="line"></span><br><span class="line">        //这里是特别重要的细节:</span><br><span class="line"></span><br><span class="line">        //1. 如果我们希望调用Dog的方法, 需要向下转型</span><br><span class="line">        //2. 需要我们将Dog类的定义，放在到可以引用的位置</span><br><span class="line">        Dog dog2 = (Dog)dog;</span><br><span class="line">        System.out.println(dog2.getName()); //旺财..</span><br><span class="line"></span><br><span class="line">        //关闭流, 关闭外层流即可，底层会关闭 FileInputStream 流</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a><strong>Reader</strong></h4><h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a><strong>FileReader</strong></h5><h6 id="常用方法-18"><a href="#常用方法-18" class="headerlink" title="常用方法"></a>常用方法</h6><ul><li>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</li><li>read(char)：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li></ul><h6 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a><strong>方法使用</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class FileReader_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 单个字符读取文件</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void readFile01() &#123;</span><br><span class="line">        String filePath = &quot;e:\\story.txt&quot;;</span><br><span class="line">        FileReader fileReader = null;</span><br><span class="line">        int data = 0;</span><br><span class="line">        //1. 创建FileReader对象</span><br><span class="line">        try &#123;</span><br><span class="line">            fileReader = new FileReader(filePath);</span><br><span class="line">            //循环读取 使用read, 单个字符读取</span><br><span class="line">            while ((data = fileReader.read()) != -1) &#123;</span><br><span class="line">                System.out.print((char) data);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fileReader != null) &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 字符数组读取文件</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void readFile02() &#123;</span><br><span class="line">        System.out.println(&quot;~~~readFile02 ~~~&quot;);</span><br><span class="line">        String filePath = &quot;e:\\story.txt&quot;;</span><br><span class="line">        FileReader fileReader = null;</span><br><span class="line"></span><br><span class="line">        int readLen = 0;</span><br><span class="line">        char[] buf = new char[8];</span><br><span class="line">        //1. 创建FileReader对象</span><br><span class="line">        try &#123;</span><br><span class="line">            fileReader = new FileReader(filePath);</span><br><span class="line">            //循环读取 使用read(buf), 返回的是实际读取到的字符数</span><br><span class="line">            //如果返回-1, 说明到文件结束</span><br><span class="line">            while ((readLen = fileReader.read(buf)) != -1) &#123;</span><br><span class="line">                System.out.print(new String(buf, 0, readLen));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fileReader != null) &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a><strong>BufferedReader</strong></h5><p><strong>例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedReader_ &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        String filePath = &quot;e:\\a.java&quot;;</span><br><span class="line">        //创建bufferedReader</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));</span><br><span class="line">        //读取</span><br><span class="line">        String line; //按行读取, 效率高</span><br><span class="line">        //说明</span><br><span class="line">        //1. bufferedReader.readLine() 是按行读取文件</span><br><span class="line">        //2. 当返回null 时，表示文件读取完毕</span><br><span class="line">        while ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流</span><br><span class="line">        //FileReader。</span><br><span class="line">        /*</span><br><span class="line">            public void close() throws IOException &#123;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    if (in == null)</span><br><span class="line">                        return;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        in.close();//in 就是我们传入的 new FileReader(filePath), 关闭了.</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        in = null;</span><br><span class="line">                        cb = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h5><h6 id="基本介绍-60"><a href="#基本介绍-60" class="headerlink" title="基本介绍"></a>基本介绍</h6><ul><li><p>InputStreamReader：Reader 的子类，可以将 lnputStream(字节流)包装成 Reader(字符流） </p></li><li><p>当处理纯文本数据时，如果使用宇符流效率重高，井且可以有效解決中文问题，所以建议字节流转换成字符流</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class InputStreamReader_ &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        String filePath = &quot;e:\\a.txt&quot;;</span><br><span class="line">        //解读</span><br><span class="line">        //1. 把 FileInputStream 转成 InputStreamReader</span><br><span class="line">        //2. 指定编码 gbk</span><br><span class="line">        //InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;);</span><br><span class="line">        //3. 把 InputStreamReader 传入 BufferedReader</span><br><span class="line">        //BufferedReader br = new BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">        //将2 和 3 合在一起</span><br><span class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(</span><br><span class="line">                                                    new FileInputStream(filePath), &quot;gbk&quot;));</span><br><span class="line"></span><br><span class="line">        //4. 读取</span><br><span class="line">        String s = br.readLine();</span><br><span class="line">        System.out.println(&quot;读取内容=&quot; + s);</span><br><span class="line">        //5. 关闭外层流</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出流⭐️"><a href="#输出流⭐️" class="headerlink" title="输出流⭐️"></a><strong>输出流⭐️</strong></h3><h4 id="基本介绍-61"><a href="#基本介绍-61" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121951748.png" alt="image-20221012195159558"></p><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a><strong>OutputStream</strong></h4><h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a><strong>FileOutputStream</strong></h5><h6 id="常用方法-19"><a href="#常用方法-19" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h6><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121952093.png" alt="image-20221012195257747"></p><h6 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class FileOutputStream01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 演示使用FileOutputStream 将数据写到文件中,</span><br><span class="line">     * 如果该文件不存在，则创建该文件</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void writeFile() &#123;</span><br><span class="line"></span><br><span class="line">        //创建 FileOutputStream对象</span><br><span class="line">        String filePath = &quot;e:\\a.txt&quot;;</span><br><span class="line">        FileOutputStream fileOutputStream = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //得到 FileOutputStream对象</span><br><span class="line">            //说明</span><br><span class="line">            //1. new FileOutputStream(filePath) 创建方式，当写入内容是，会覆盖原来的内容</span><br><span class="line">            //2. new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面</span><br><span class="line">            fileOutputStream = new FileOutputStream(filePath, true);</span><br><span class="line">            //写入一个字节</span><br><span class="line">            //fileOutputStream.write(&#x27;H&#x27;);//</span><br><span class="line">            //写入字符串</span><br><span class="line">            String str = &quot;hsp,world!&quot;;</span><br><span class="line">            //str.getBytes() 可以把 字符串-&gt; 字节数组</span><br><span class="line">            //fileOutputStream.write(str.getBytes());</span><br><span class="line">            /*</span><br><span class="line">            write(byte[] b, int off, int len) 将 len字节从位于偏移量 off的指定字节数组写入此文件输出流</span><br><span class="line">             */</span><br><span class="line">            fileOutputStream.write(str.getBytes(), 0, 3);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a><strong>BufferedOutputStream</strong></h5><h6 id="基本介绍-62"><a href="#基本介绍-62" class="headerlink" title="基本介绍"></a>基本介绍</h6><ul><li>BufferedOutputstream 是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层 系统</li></ul><p><strong>常用方法</strong></p><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210121954691.png" alt="image-20221012195402429"></p><p><strong>例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedCopy02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//        String srcFilePath = &quot;e:\\Koala.jpg&quot;;</span><br><span class="line">//        String destFilePath = &quot;e:\\hsp.jpg&quot;;</span><br><span class="line">//        String srcFilePath = &quot;e:\\0245_韩顺平零基础学Java_引出this.avi&quot;;</span><br><span class="line">//        String destFilePath = &quot;e:\\hsp.avi&quot;;</span><br><span class="line">        String srcFilePath = &quot;e:\\a.java&quot;;</span><br><span class="line">        String destFilePath = &quot;e:\\a3.java&quot;;</span><br><span class="line"></span><br><span class="line">        //创建BufferedOutputStream对象BufferedInputStream对象</span><br><span class="line">        BufferedInputStream bis = null;</span><br><span class="line">        BufferedOutputStream bos = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //因为 FileInputStream  是 InputStream 子类</span><br><span class="line">            bis = new BufferedInputStream(new FileInputStream(srcFilePath));</span><br><span class="line">            bos = new BufferedOutputStream(new FileOutputStream(destFilePath));</span><br><span class="line"></span><br><span class="line">            //循环的读取文件，并写入到 destFilePath</span><br><span class="line">            byte[] buff = new byte[1024];</span><br><span class="line">            int readLen = 0;</span><br><span class="line">            //当返回 -1 时，就表示文件读取完毕</span><br><span class="line">            while ((readLen = bis.read(buff)) != -1) &#123;</span><br><span class="line">                bos.write(buff, 0, readLen);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;文件拷贝完毕~~~&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">            //关闭流 , 关闭外层的处理流即可，底层会去关闭节点流</span><br><span class="line">            try &#123;</span><br><span class="line">                if(bis != null) &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if(bos != null) &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a><strong>ObjectOutputStream</strong></h5><h6 id="基本介绍-63"><a href="#基本介绍-63" class="headerlink" title="基本介绍"></a>基本介绍</h6><ul><li>Objectoutputstream 提供序列化功能 </li><li>序列化就是在保存数据时，保存数据的值和数据类型 </li><li>列化就是在恢复数据时，恢复数据的值和数据类型 </li><li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：Serializable 和 Externalizable</li></ul><h6 id="例-1"><a href="#例-1" class="headerlink" title="例"></a><strong>例</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectOutStream_ &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存</span><br><span class="line">        String filePath = &quot;e:\\data.dat&quot;;</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));</span><br><span class="line"></span><br><span class="line">        //序列化数据到 e:\data.dat</span><br><span class="line">        oos.writeInt(100);// int -&gt; Integer (实现了 Serializable)</span><br><span class="line">        oos.writeBoolean(true);// boolean -&gt; Boolean (实现了 Serializable)</span><br><span class="line">        oos.writeChar(&#x27;a&#x27;);// char -&gt; Character (实现了 Serializable)</span><br><span class="line">        oos.writeDouble(9.5);// double -&gt; Double (实现了 Serializable)</span><br><span class="line">        oos.writeUTF(&quot;韩顺平教育&quot;);//String</span><br><span class="line">        //保存一个dog对象</span><br><span class="line">        oos.writeObject(new Dog(&quot;旺财&quot;, 10, &quot;日本&quot;, &quot;白色&quot;));</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(&quot;数据保存完毕(序列化形式)&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="注意事项和细节-51"><a href="#注意事项和细节-51" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h6><ul><li>读写顺序要一致</li><li>要求实现序列化或反序列化对象，需要实现 Serializable<br>序列化的类中建议添加 SerialVersionUID，为了提高版本兼容性</li><li>序列化对象时，默认将里面所有属性都进行序列化，但除了static 或 transient 修饰的成员</li><li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li><li>序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也己经默认实现了序列化</li></ul><h5 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a><strong>PrintStream</strong></h5><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class PrintStream_ &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line">        //在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器</span><br><span class="line">        /*</span><br><span class="line">             public void print(String s) &#123;</span><br><span class="line">                if (s == null) &#123;</span><br><span class="line">                    s = &quot;null&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                write(s);</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">        out.print(&quot;john, hello&quot;);</span><br><span class="line">        //因为print底层使用的是write , 所以我们可以直接调用write进行打印/输出</span><br><span class="line">        out.write(&quot;韩顺平,你好&quot;.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        //我们可以去修改打印流输出的位置/设备</span><br><span class="line">        //1. 输出修改成到 &quot;e:\\f1.txt&quot;</span><br><span class="line">        //2. &quot;hello, 韩顺平教育~&quot; 就会输出到 e:\f1.txt</span><br><span class="line">        //3. public static void setOut(PrintStream out) &#123;</span><br><span class="line">        //        checkIO();</span><br><span class="line">        //        setOut0(out); // native 方法，修改了out</span><br><span class="line">        //   &#125;</span><br><span class="line">        System.setOut(new PrintStream(&quot;e:\\f1.txt&quot;));</span><br><span class="line">        System.out.println(&quot;hello, 韩顺平教育~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5><h6 id="常用方法-20"><a href="#常用方法-20" class="headerlink" title="常用方法"></a>常用方法</h6><ul><li>new File Writer (File&#x2F;String)：覆盖模式，相当于流的指针在首端</li><li>new FileWriter (File&#x2F;String.true)：追加模式，相当于流的指针在尾端</li><li>write(int)：写入单个字符</li><li>write(char[])：写入指定数组</li><li>write(char[],off len)：写入指定数组的指定部分</li><li>write (string)：写入整个字符律</li><li>write(string,off,len)：写入字符串的指定部分</li></ul><h6 id="方法使用-1"><a href="#方法使用-1" class="headerlink" title="方法使用"></a><strong>方法使用</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class FileWriter_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String filePath = &quot;e:\\note.txt&quot;;</span><br><span class="line">        //创建FileWriter对象</span><br><span class="line">        FileWriter fileWriter = null;</span><br><span class="line">        char[] chars = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            fileWriter = new FileWriter(filePath);//默认是覆盖写入</span><br><span class="line">//            3) write(int):写入单个字符</span><br><span class="line">            fileWriter.write(&#x27;H&#x27;);</span><br><span class="line">//            4) write(char[]):写入指定数组</span><br><span class="line">            fileWriter.write(chars);</span><br><span class="line">//            5) write(char[],off,len):写入指定数组的指定部分</span><br><span class="line">            fileWriter.write(&quot;韩顺平教育&quot;.toCharArray(), 0, 3);</span><br><span class="line">//            6) write（string）：写入整个字符串</span><br><span class="line">            fileWriter.write(&quot; 你好北京~&quot;);</span><br><span class="line">            fileWriter.write(&quot;风雨之后，定见彩虹&quot;);</span><br><span class="line">//            7) write(string,off,len):写入字符串的指定部分</span><br><span class="line">            fileWriter.write(&quot;上海天津&quot;, 0, 2);</span><br><span class="line">            //在数据量大的情况下，可以使用循环操作.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">            //对应FileWriter , 一定要关闭流，或者flush才能真正的把数据写入到文件</span><br><span class="line">            //老韩看源码就知道原因.</span><br><span class="line">            /*</span><br><span class="line">                看看代码</span><br><span class="line">                private void writeBytes() throws IOException &#123;</span><br><span class="line">        this.bb.flip();</span><br><span class="line">        int var1 = this.bb.limit();</span><br><span class="line">        int var2 = this.bb.position();</span><br><span class="line"></span><br><span class="line">        assert var2 &lt;= var1;</span><br><span class="line"></span><br><span class="line">        int var3 = var2 &lt;= var1 ? var1 - var2 : 0;</span><br><span class="line">        if (var3 &gt; 0) &#123;</span><br><span class="line">            if (this.ch != null) &#123;</span><br><span class="line">                assert this.ch.write(this.bb) == var3 : var3;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.out.write(this.bb.array(), this.bb.arrayOffset() + var2, var3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.bb.clear();</span><br><span class="line">    &#125;</span><br><span class="line">             */</span><br><span class="line">            try &#123;</span><br><span class="line">                //fileWriter.flush();</span><br><span class="line">                //关闭文件流，等价 flush() + 关闭</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;程序结束...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a><strong>文件拷贝</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class FileCopy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //完成 文件拷贝，将 e:\\Koala.jpg 拷贝 c:\\</span><br><span class="line">        //思路分析</span><br><span class="line">        //1. 创建文件的输入流 , 将文件读入到程序</span><br><span class="line">        //2. 创建文件的输出流， 将读取到的文件数据，写入到指定的文件.</span><br><span class="line">        String srcFilePath = &quot;e:\\Koala.jpg&quot;;</span><br><span class="line">        String destFilePath = &quot;e:\\Koala3.jpg&quot;;</span><br><span class="line">        FileInputStream fileInputStream = null;</span><br><span class="line">        FileOutputStream fileOutputStream = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            fileInputStream = new FileInputStream(srcFilePath);</span><br><span class="line">            fileOutputStream = new FileOutputStream(destFilePath);</span><br><span class="line">            //定义一个字节数组,提高读取效果</span><br><span class="line">            byte[] buf = new byte[1024];</span><br><span class="line">            int readLen = 0;</span><br><span class="line">            while ((readLen = fileInputStream.read(buf)) != -1) &#123;</span><br><span class="line">                //读取到后，就写入到文件 通过 fileOutputStream</span><br><span class="line">                //即，是一边读，一边写</span><br><span class="line">                fileOutputStream.write(buf, 0, readLen);//一定要使用这个方法</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;拷贝ok~&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //关闭输入流和输出流，释放资源</span><br><span class="line">                if (fileInputStream != null) &#123;</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (fileOutputStream != null) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li>FileWriter 使用后，必须要关闭(close)或刷新(flush），否则写入不到指定的文件</li></ul><h5 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a><strong>BufferedWriter</strong></h5><p><strong>例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedWriter_ &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String filePath = &quot;e:\\ok.txt&quot;;</span><br><span class="line">        //创建BufferedWriter</span><br><span class="line">        //说明:</span><br><span class="line">        //1. new FileWriter(filePath, true) 表示以追加的方式写入</span><br><span class="line">        //2. new FileWriter(filePath) , 表示以覆盖的方式写入</span><br><span class="line">        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath));</span><br><span class="line">        bufferedWriter.write(&quot;hello, 韩顺平教育!&quot;);</span><br><span class="line">        bufferedWriter.newLine();//插入一个和系统相关的换行</span><br><span class="line">        bufferedWriter.write(&quot;hello2, 韩顺平教育!&quot;);</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">        bufferedWriter.write(&quot;hello3, 韩顺平教育!&quot;);</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line"></span><br><span class="line">        //说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="文件拷贝-1"><a href="#文件拷贝-1" class="headerlink" title="文件拷贝"></a><strong>文件拷贝</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedCopy_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //1. BufferedReader 和 BufferedWriter 是安装字符操作</span><br><span class="line">        //2. 不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏</span><br><span class="line">        //BufferedInputStream</span><br><span class="line">        //BufferedOutputStream</span><br><span class="line">        String srcFilePath = &quot;e:\\a.java&quot;;</span><br><span class="line">        String destFilePath = &quot;e:\\a2.java&quot;;</span><br><span class="line">//        String srcFilePath = &quot;e:\\0245_韩顺平零基础学Java_引出this.avi&quot;;</span><br><span class="line">//        String destFilePath = &quot;e:\\a2韩顺平.avi&quot;;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line">        String line;</span><br><span class="line">        try &#123;</span><br><span class="line">            br = new BufferedReader(new FileReader(srcFilePath));</span><br><span class="line">            bw = new BufferedWriter(new FileWriter(destFilePath));</span><br><span class="line"></span><br><span class="line">            //说明: readLine 读取一行内容，但是没有换行</span><br><span class="line">            while ((line = br.readLine()) != null) &#123;</span><br><span class="line">                //每读取一行，就写入</span><br><span class="line">                bw.write(line);</span><br><span class="line">                //插入一个换行</span><br><span class="line">                bw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;拷贝完毕...&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //关闭流</span><br><span class="line">            try &#123;</span><br><span class="line">                if(br != null) &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if(bw != null) &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a><strong>OutputStreamWriter</strong></h5><h6 id="基本介绍-64"><a href="#基本介绍-64" class="headerlink" title="基本介绍"></a>基本介绍</h6><ul><li>OutputStreamWriter：Writer的子类，实现将Outputstream(字节流)包装成 Writer(字符流)</li><li>当处理纯文本数据时，如果使用宇符流效率重高，井且可以有效解決中文问题，所以建议格字节流转快成字符流</li><li>可以在使用时指定编码格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class OutputStreamWriter_ &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String filePath = &quot;e:\\hsp.txt&quot;;</span><br><span class="line">        String charSet = &quot;utf-8&quot;;</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(filePath), charSet);</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line">        bw.write(&quot;hi, 韩顺平教育&quot;);</span><br><span class="line">        bw.close();</span><br><span class="line">        System.out.println(&quot;按照 &quot; + charSet + &quot; 保存文件成功~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PrintWrite"><a href="#PrintWrite" class="headerlink" title="PrintWrite"></a><strong>PrintWrite</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class PrintWriter_ &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        //PrintWriter printWriter = new PrintWriter(System.out);</span><br><span class="line">        PrintWriter printWriter = new PrintWriter(new FileWriter(&quot;e:\\f2.txt&quot;));</span><br><span class="line">        printWriter.print(&quot;hi, 北京你好~~~~&quot;);</span><br><span class="line">        printWriter.close();//flush + 关闭流, 才会将数据写入到文件..</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Properties-1"><a href="#Properties-1" class="headerlink" title="Properties"></a><strong>Properties</strong></h3><h4 id="基本介绍-65"><a href="#基本介绍-65" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>专门用于读号配置文件的集合类配置文件的格式：键&#x3D;值 </li><li>键值对不需要有空格，值不需要用引号一起来 </li><li>默认类型是 String</li></ul><h4 id="常用方法-21"><a href="#常用方法-21" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>load：加载配置文件的键值对到Properties对象</li><li>list：将数据显示到指定设备</li><li>getProperty (key)：根据键获取值</li><li>setProperty(key value)：设置键值对到Properties对象</li><li>store：将Properties中的键值对存储到配置文件，在idea 中，保存信息到配置文件，如果含有中文，会存储为unicode码</li></ul><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a><strong>读取</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Properties02 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //使用Properties 类来读取mysql.properties 文件</span><br><span class="line"></span><br><span class="line">        //1. 创建Properties 对象</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        //2. 加载指定配置文件</span><br><span class="line">        properties.load(new FileReader(&quot;src\\mysql.properties&quot;));</span><br><span class="line">        //3. 把k-v显示控制台</span><br><span class="line">        properties.list(System.out);</span><br><span class="line">        //4. 根据key 获取对应的值</span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String pwd = properties.getProperty(&quot;pwd&quot;);</span><br><span class="line">        System.out.println(&quot;用户名=&quot; + user);</span><br><span class="line">        System.out.println(&quot;密码是=&quot; + pwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Properties03 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //使用Properties 类来创建 配置文件, 修改配置文件内容</span><br><span class="line"></span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        //创建</span><br><span class="line">        //1.如果该文件没有key 就是创建</span><br><span class="line">        //2.如果该文件有key ,就是修改</span><br><span class="line">        /*</span><br><span class="line">            Properties 父类是 Hashtable ， 底层就是Hashtable 核心方法</span><br><span class="line">            public synchronized V put(K key, V value) &#123;</span><br><span class="line">                // Make sure the value is not null</span><br><span class="line">                if (value == null) &#123;</span><br><span class="line">                    throw new NullPointerException();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Makes sure the key is not already in the hashtable.</span><br><span class="line">                Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">                int hash = key.hashCode();</span><br><span class="line">                int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">                for(; entry != null ; entry = entry.next) &#123;</span><br><span class="line">                    if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                        V old = entry.value;</span><br><span class="line">                        entry.value = value;//如果key 存在，就替换</span><br><span class="line">                        return old;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                addEntry(hash, key, value, index);//如果是新k, 就addEntry</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">        properties.setProperty(&quot;charset&quot;, &quot;utf8&quot;);</span><br><span class="line">        properties.setProperty(&quot;user&quot;, &quot;汤姆&quot;);//注意保存时，是中文的 unicode码值</span><br><span class="line">        properties.setProperty(&quot;pwd&quot;, &quot;888888&quot;);</span><br><span class="line"></span><br><span class="line">        //将k-v 存储文件中即可</span><br><span class="line">        properties.store(new FileOutputStream(&quot;src\\mysql2.properties&quot;), null);</span><br><span class="line">        System.out.println(&quot;保存配置文件成功~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a><strong>网络基础</strong></h3><h4 id="ip-地址"><a href="#ip-地址" class="headerlink" title="ip 地址"></a>ip 地址</h4><ul><li>用于唯一标识网络中的每台计算机&#x2F;主机</li><li>查看ip地址：ipconfig</li><li>ip地址的表示形式：点分十进制 xx.xx.xx.xx</li><li>每一个十进制数的范围：0~255</li><li>ip地址的组成&#x3D;网络地址＋主机地址，比如：192.168.16.69</li><li>ilPv6是互联网工程任务组设计的用于替代1PV4的下一代IP协议</li></ul><h4 id="ipv4地址分类"><a href="#ipv4地址分类" class="headerlink" title="ipv4地址分类"></a><strong>ipv4地址分类</strong></h4><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210122014234.png" alt="image-20221012201430884"></p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><ul><li>将 ip 地址映射成域名</li></ul><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><ul><li><p>用于标识计算机上某个特定的网络程序</p></li><li><p>表示形式：以整数形式，范围0~65535</p></li><li><p>0~1024己经被占用，比如ssh 22,ftp 21, smtp 25 http 80</p></li><li><p>常见的网络程序端口号： tomcat :8080 mysql:3306 oracle:1521 sqlserver:1433</p></li></ul><h4 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h4><ul><li>TCP&#x2F;IP (Transmission Control Protocol&#x2F;Internet Protocol的简写，中文译名为传输控制协议&#x2F;因特网互联协议，又叫网络通讯协议，这个协议是internet最基本的协议，internet国际互联网络的基础就是由网络层的IP协议和传输层的TCP协议组成的</li></ul><h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h5><ul><li><p>使用 TCP 协议前，须先建立 TCP 连接，形成传输数据通道</p></li><li><p>传输前，采用”三次握手”方式，是可靠的</p></li><li><p>TCP 协议进行通信的两个应用进程：客户端、服务端</p></li><li><p>在连接中可进行大数据量的传输</p></li><li><p>传输完毕，需释放已建立的连接，效率低</p></li></ul><h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><ul><li><p>格数据源、目的封装成数据包，不需要建立连接</p></li><li><p>每个数据报的大小限制在64K内</p></li><li><p>因无需连接，故是不可靠的</p></li><li><p>发送数据结束时无需释放资源(因为不是面向连接的)，速度快</p></li></ul><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a><strong>InetAddress</strong></h3><h4 id="常用方法-22"><a href="#常用方法-22" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>获取本机 InetAddress 对象 getLocalHost </li><li>根据指定主机名&#x2F;域名获取 ip 地址对象 getByName </li><li>获取 InetAddress 对象的主机名 getHostName </li><li>获取 InetAddress 对象的地址 getHostAddress</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class API_ &#123;</span><br><span class="line">    public static void main(String[] args) throws UnknownHostException &#123;</span><br><span class="line"></span><br><span class="line">        //1. 获取本机的InetAddress 对象</span><br><span class="line">        InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(localHost);//DESKTOP-S4MP84S/192.168.12.1</span><br><span class="line"></span><br><span class="line">        //2. 根据指定主机名 获取 InetAddress对象</span><br><span class="line">        InetAddress host1 = InetAddress.getByName(&quot;DESKTOP-S4MP84S&quot;);</span><br><span class="line">        System.out.println(&quot;host1=&quot; + host1);//DESKTOP-S4MP84S/192.168.12.1</span><br><span class="line"></span><br><span class="line">        //3. 根据域名返回 InetAddress对象, 比如 www.baidu.com 对应</span><br><span class="line">        InetAddress host2 = InetAddress.getByName(&quot;www.baidu.com&quot;);</span><br><span class="line">        System.out.println(&quot;host2=&quot; + host2);//www.baidu.com / 110.242.68.4</span><br><span class="line"></span><br><span class="line">        //4. 通过 InetAddress 对象，获取对应的地址</span><br><span class="line">        String hostAddress = host2.getHostAddress();//IP 110.242.68.4</span><br><span class="line">        System.out.println(&quot;host2 对应的ip = &quot; + hostAddress);//110.242.68.4</span><br><span class="line"></span><br><span class="line">        //5. 通过 InetAddress 对象，获取对应的主机名/或者的域名</span><br><span class="line">        String hostName = host2.getHostName();</span><br><span class="line">        System.out.println(&quot;host2对应的主机名/域名=&quot; + hostName); // www.baidu.com</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a><strong>Socket</strong></h3><h4 id="基本介绍-66"><a href="#基本介绍-66" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>通信的两端都要有 Socket，是两台机器间通信的端点</li><li>Socket 允许程序把网络连接当成一个流，数据在两个 Socket 间通过 IO 传输</li><li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li></ul><h3 id="TCP编程⭐️"><a href="#TCP编程⭐️" class="headerlink" title="TCP编程⭐️"></a><strong>TCP编程⭐️</strong></h3><h4 id="TCP网络通信编程"><a href="#TCP网络通信编程" class="headerlink" title="TCP网络通信编程"></a>TCP网络通信编程</h4><ul><li>基于客户端——服务端的网络通信 </li><li>底层使用TCP&#x2F;IP协议 </li><li>基于Socket的TCP编程</li></ul><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class SocketTCP03Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //思路</span><br><span class="line">        //1. 在本机 的9999端口监听, 等待连接</span><br><span class="line">        //   细节: 要求在本机没有其它服务在监听9999</span><br><span class="line">        //   细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发]</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(9999);</span><br><span class="line">        System.out.println(&quot;服务端，在9999端口监听，等待连接..&quot;);</span><br><span class="line">        //2. 当没有客户端连接9999端口时，程序会 阻塞, 等待连接</span><br><span class="line">        //   如果有客户端连接，则会返回Socket对象，程序继续</span><br><span class="line"></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;服务端 socket =&quot; + socket.getClass());</span><br><span class="line">        </span><br><span class="line">        //3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">      </span><br><span class="line">        //4. IO读取, 使用字符流, 老师使用 InputStreamReader 将 inputStream 转成字符流</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">        String s = bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);//输出</span><br><span class="line"></span><br><span class="line">        //5. 获取socket相关联的输出流</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        //   使用字符输出流的方式回复信息</span><br><span class="line">        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));</span><br><span class="line">        bufferedWriter.write(&quot;hello client 字符流&quot;);</span><br><span class="line">        bufferedWriter.newLine();// 插入一个换行符，表示回复内容的结束</span><br><span class="line">        bufferedWriter.flush();//注意需要手动的flush</span><br><span class="line"></span><br><span class="line">        //6.关闭流和socket</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();//关闭</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class SocketTCP03Client &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //思路</span><br><span class="line">        //1. 连接服务端 (ip , 端口）</span><br><span class="line">        //解读: 连接本机的 9999端口, 如果连接成功，返回Socket对象</span><br><span class="line">        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);</span><br><span class="line">        System.out.println(&quot;客户端 socket返回=&quot; + socket.getClass());</span><br><span class="line">      </span><br><span class="line">        //2. 连接上后，生成Socket, 通过socket.getOutputStream()</span><br><span class="line">        //   得到 和 socket对象关联的输出流对象</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">      </span><br><span class="line">        //3. 通过输出流，写入数据到 数据通道, 使用字符流</span><br><span class="line">        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));</span><br><span class="line">        bufferedWriter.write(&quot;hello, server 字符流&quot;);</span><br><span class="line">        bufferedWriter.newLine();//插入一个换行符，表示写入的内容结束, 注意，要求对方使用readLine()!!!!</span><br><span class="line">        bufferedWriter.flush();// 如果使用的字符流，需要手动刷新，否则数据不会写入数据通道</span><br><span class="line"></span><br><span class="line">        //4. 获取和socket关联的输入流. 读取数据(字符)，并显示</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">        String s = bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        //5. 关闭流对象和socket, 必须关闭</span><br><span class="line">        bufferedReader.close();//关闭外层流</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(&quot;客户端退出.....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片拷贝"><a href="#图片拷贝" class="headerlink" title="图片拷贝"></a><strong>图片拷贝</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class TCPFileUploadServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //1. 服务端在本机监听8888端口</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(8888);</span><br><span class="line">        System.out.println(&quot;服务端在8888端口监听....&quot;);</span><br><span class="line">        //2. 等待连接</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        //3. 读取客户端发送的数据</span><br><span class="line">        //   通过Socket得到输入流</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());</span><br><span class="line">        byte[] bytes = StreamUtils.streamToByteArray(bis);</span><br><span class="line">      </span><br><span class="line">        //4. 将得到 bytes 数组，写入到指定的路径，就得到一个文件了</span><br><span class="line">        String destFilePath = &quot;src\\abc.mp4&quot;;</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFilePath));</span><br><span class="line">        bos.write(bytes);</span><br><span class="line">        bos.close();</span><br><span class="line"></span><br><span class="line">        // 向客户端回复 &quot;收到图片&quot;</span><br><span class="line">        // 通过socket 获取到输出流(字符)</span><br><span class="line">        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">        writer.write(&quot;收到图片&quot;);</span><br><span class="line">        writer.flush();//把内容刷新到数据通道</span><br><span class="line">        socket.shutdownOutput();//设置写入结束标记</span><br><span class="line"></span><br><span class="line">        //关闭其他资源</span><br><span class="line">        writer.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="音乐拷贝"><a href="#音乐拷贝" class="headerlink" title="音乐拷贝"></a><strong>音乐拷贝</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Homework03Server &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //1 监听 9999端口</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(9999);</span><br><span class="line">        //2.等待客户端连接</span><br><span class="line">        System.out.println(&quot;服务端，在9999端口监听，等待下载文件&quot;);</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        //3.读取 客户端发送要下载的文件名</span><br><span class="line">        //  这里老师使用了while读取文件名，时考虑将来客户端发送的数据较大的情况</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        byte[] b = new byte[1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        String downLoadFileName = &quot;&quot;;</span><br><span class="line">        while ((len = inputStream.read(b)) != -1) &#123;</span><br><span class="line">            downLoadFileName += new String(b, 0 , len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;客户端希望下载文件名=&quot; + downLoadFileName);</span><br><span class="line"></span><br><span class="line">        //老师在服务器上有两个文件, 无名.mp3 高山流水.mp3</span><br><span class="line">        //如果客户下载的是 高山流水 我们就返回该文件，否则一律返回 无名.mp3</span><br><span class="line"></span><br><span class="line">        String resFileName = &quot;&quot;;</span><br><span class="line">        if(&quot;高山流水&quot;.equals(downLoadFileName)) &#123;</span><br><span class="line">            resFileName = &quot;src\\高山流水.mp3&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            resFileName = &quot;src\\无名.mp3&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4. 创建一个输入流，读取文件</span><br><span class="line">        BufferedInputStream bis =</span><br><span class="line">                new BufferedInputStream(new FileInputStream(resFileName));</span><br><span class="line"></span><br><span class="line">        //5. 使用工具类StreamUtils ，读取文件到一个字节数组</span><br><span class="line"></span><br><span class="line">        byte[] bytes = StreamUtils.streamToByteArray(bis);</span><br><span class="line">        //6. 得到Socket关联的输出流</span><br><span class="line">        BufferedOutputStream bos =</span><br><span class="line">                new BufferedOutputStream(socket.getOutputStream());</span><br><span class="line">        //7. 写入到数据通道，返回给客户端</span><br><span class="line">        bos.write(bytes);</span><br><span class="line">        socket.shutdownOutput();//很关键.</span><br><span class="line"></span><br><span class="line">        //8 关闭相关的资源</span><br><span class="line">        bis.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">        System.out.println(&quot;服务端退出...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="netstat指令"><a href="#netstat指令" class="headerlink" title="netstat指令"></a>netstat指令</h4><ul><li>netstat-an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况</li><li>netstat -an l more 可以分页显示</li><li>要求在dos控制台下执行</li></ul><h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a><strong>UDP编程</strong></h3><h4 id="基本介绍-67"><a href="#基本介绍-67" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序</p></li><li><p>UDP 数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达</p></li><li><p>DatagramPacket 对象封装了 UDP 数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</p></li><li><p>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接</p></li></ul><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ul><li><p>核心的两个类&#x2F;对象 Datagramsocket与DatagramPacket </p></li><li><p>建立发送端，接收端 </p></li><li><p>建立数据包 </p></li><li><p>调用 DatagramSocket 的发送、接收方法 </p></li><li><p>关网 DatagramSocket</p></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210122022727.png" alt="image-20221012202259378"></p><h4 id="注意事项和细节-52"><a href="#注意事项和细节-52" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul><li>没有明确的服务端和客户端，演变成数据的发送端和接收端</li><li>接收数据和发送数据是通过 DatagramSocket 对象完成</li><li>将数据封装到 DatagramPacket 对象&#x2F; 装包</li><li>当接收到 DatagramPacket 对象，需要进行拆包，取出数据<br>eDatagramSocket 可以指定在哪个端口接收数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class UDPReceiverA &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //1. 创建一个 DatagramSocket 对象，准备在9999接收数据</span><br><span class="line">        DatagramSocket socket = new DatagramSocket(9999);</span><br><span class="line">        //2. 构建一个 DatagramPacket 对象，准备接收数据</span><br><span class="line">        //   在前面讲解UDP 协议时，老师说过一个数据包最大 64k</span><br><span class="line">        byte[] buf = new byte[1024];</span><br><span class="line">        DatagramPacket packet = new DatagramPacket(buf, buf.length);</span><br><span class="line">        //3. 调用 接收方法, 将通过网络传输的 DatagramPacket 对象</span><br><span class="line">        //   填充到 packet对象</span><br><span class="line">        //老师提示: 当有数据包发送到 本机的9999端口时，就会接收到数据</span><br><span class="line">        //   如果没有数据包发送到 本机的9999端口, 就会阻塞等待.</span><br><span class="line">        System.out.println(&quot;接收端A 等待接收数据..&quot;);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        //4. 可以把packet 进行拆包，取出数据，并显示.</span><br><span class="line">        int length = packet.getLength();//实际接收到的数据字节长度</span><br><span class="line">        byte[] data = packet.getData();//接收到数据</span><br><span class="line">        String s = new String(data, 0, length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //===回复信息给B端</span><br><span class="line">        //将需要发送的数据，封装到 DatagramPacket对象</span><br><span class="line">        data = &quot;好的, 明天见&quot;.getBytes();</span><br><span class="line">        //说明: 封装的 DatagramPacket对象 data 内容字节数组 , data.length , 主机(IP) , 端口</span><br><span class="line">        packet =</span><br><span class="line">                new DatagramPacket(data, data.length, InetAddress.getByName(&quot;192.168.12.1&quot;), 9998);</span><br><span class="line"></span><br><span class="line">        socket.send(packet);//发送</span><br><span class="line"></span><br><span class="line">        //5. 关闭资源</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(&quot;A端退出...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h2><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a><strong>反射机制</strong></h3><h4 id="基本介绍-68"><a href="#基本介绍-68" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>反射机制允许程序在执行期借助子 Reflection API 取得任何类的内部信息(比如成员变量，构造器，成员方法等等），并能操作对象的属性及方法 </li><li>加载完类之后，在堆中就产生了一个 Class 类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为：反射</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210122024596.png" alt="image-20221012202431282"></p><h3 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a>反射相关类</h3><ul><li>java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象</li><li>java.lang.reflect.Method: 代表该类的方法</li><li>java.lang.reflect.Field：代表类的成员变量</li><li>java.lang.reflect.Constructor：代表类的构造方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Reflection01 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //1. 使用Properties 类, 可以读写配置文件</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(new FileInputStream(&quot;src\\re.properties&quot;));</span><br><span class="line">        String classfullpath = properties.get(&quot;classfullpath&quot;).toString();//&quot;com.hspedu.Cat&quot;</span><br><span class="line">        String methodName = properties.get(&quot;method&quot;).toString();//&quot;hi&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //2. 使用反射机制解决</span><br><span class="line">        //(1) 加载类, 返回Class类型的对象cls</span><br><span class="line">        Class cls = Class.forName(classfullpath);</span><br><span class="line">        //(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        System.out.println(&quot;o的运行类型=&quot; + o.getClass()); //运行类型</span><br><span class="line">        //(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot;  的方法对象</span><br><span class="line">        //    即：在反射中，可以把方法视为对象（万物皆对象）</span><br><span class="line">        Method method1 = cls.getMethod(methodName);</span><br><span class="line">        //(4) 通过method1 调用方法: 即通过方法对象来实现调用方法</span><br><span class="line">        System.out.println(&quot;=============================&quot;);</span><br><span class="line">        method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)</span><br><span class="line"></span><br><span class="line">        //java.lang.reflect.Field: 代表类的成员变量, Field对象表示某个类的成员变量</span><br><span class="line">        //得到name字段</span><br><span class="line">        //getField不能得到私有的属性</span><br><span class="line">        Field nameField = cls.getField(&quot;age&quot;); //</span><br><span class="line">        System.out.println(nameField.get(o)); // 传统写法 对象.成员变量 , 反射 :  成员变量对象.get(对象)</span><br><span class="line"></span><br><span class="line">        //java.lang.reflect.Constructor: 代表类的构造方法, Constructor对象表示构造器</span><br><span class="line">        Constructor constructor = cls.getConstructor(); //()中可以指定构造器参数类型, 返回无参构造器</span><br><span class="line">        System.out.println(constructor);//Cat()</span><br><span class="line"></span><br><span class="line">        Constructor constructor2 = cls.getConstructor(String.class); //这里传入的 String.class 就是String类的Class对象</span><br><span class="line">        System.out.println(constructor2);//Cat(String name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a><strong>Class类</strong></h3><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210122025885.png" alt="image-20221012202550648"></p><h4 id="基本介绍-69"><a href="#基本介绍-69" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Class 也是类，因此也继承 Object 类</li><li>Class 类对象不是 new 出来的，而是系统创建的</li><li>类的 Class 类对象，在内存中只有一份，且只加载一次</li><li>每个类的实例都会记录它属于哪个 Class 实例生成</li><li>通过 Class 可以完整地得到一个类的完整结构，通过一系列 API</li><li>Class 对象是存放在堆的</li><li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据(包括 方法代码，变量名，方法名，访问权限等等）</li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210122027470.png" alt="image-20221012202752201"></p><h4 id="Class类对象获取"><a href="#Class类对象获取" class="headerlink" title="Class类对象获取"></a>Class类对象获取</h4><ul><li>前提：已知一个类的全类名，且该类在类路径下，可通过 Class类的静态方法 forName()获取 Class cls1 &#x3D; Class.forName(“java.lang.Cat” ) 应用场景：多用于配置文件，读取类全路径，加载类 </li><li>前提：若已知具体的类，通过类的 class 获取，该方式最为安全可靠，程序性能最高 Class cls2 &#x3D; Cat.class 应用场景：多用于参数传递，比如通过反射得到对应构造器对象 </li><li>前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象 Class class &#x3D; 对象.getClass(); 应用场景：通过创建好的对象，获取Class对象 </li><li>其他方式(类加载器) ClassLoader cl &#x3D; 对象.getClass().getClassLoader(); Class class4 &#x3D; cl.loadClass(“类的全类名”); </li><li>基本数据(int, char boolean,float,double.byte.long,short) Class cls &#x3D; 基本数据类型.class </li><li>基本数据类型对应的包装类，可以通过.type 得到Class类对象 Class cls &#x3D; 包装类.TYPE</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class GetClass_ &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        //1. Class.forName</span><br><span class="line">        String classAllPath = &quot;com.hspedu.Car&quot;; //通过读取配置文件获取</span><br><span class="line">        Class&lt;?&gt; cls1 = Class.forName(classAllPath);</span><br><span class="line">        System.out.println(cls1);</span><br><span class="line"></span><br><span class="line">        //2. 类名.class , 应用场景: 用于参数传递</span><br><span class="line">        Class cls2 = Car.class;</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line"></span><br><span class="line">        //3. 对象.getClass(), 应用场景，有对象实例</span><br><span class="line">        Car car = new Car();</span><br><span class="line">        Class cls3 = car.getClass();</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">        //4. 通过类加载器【4种】来获取到类的Class对象</span><br><span class="line">        //(1)先得到类加载器 car</span><br><span class="line">        ClassLoader classLoader = car.getClass().getClassLoader();</span><br><span class="line">        //(2)通过类加载器得到Class对象</span><br><span class="line">        Class cls4 = classLoader.loadClass(classAllPath);</span><br><span class="line">        System.out.println(cls4);</span><br><span class="line"></span><br><span class="line">        //cls1 , cls2 , cls3 , cls4 其实是同一个对象</span><br><span class="line">        System.out.println(cls1.hashCode());</span><br><span class="line">        System.out.println(cls2.hashCode());</span><br><span class="line">        System.out.println(cls3.hashCode());</span><br><span class="line">        System.out.println(cls4.hashCode());</span><br><span class="line"></span><br><span class="line">        //5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到Class类对象</span><br><span class="line">        Class&lt;Integer&gt; integerClass = int.class;</span><br><span class="line">        Class&lt;Character&gt; characterClass = char.class;</span><br><span class="line">        Class&lt;Boolean&gt; booleanClass = boolean.class;</span><br><span class="line">        System.out.println(integerClass);//int</span><br><span class="line"></span><br><span class="line">        //6. 基本数据类型对应的包装类，可以通过 .TYPE 得到Class类对象</span><br><span class="line">        Class&lt;Integer&gt; type1 = Integer.TYPE;</span><br><span class="line">        Class&lt;Character&gt; type2 = Character.TYPE; //其它包装类BOOLEAN, DOUBLE, LONG,BYTE等待</span><br><span class="line">        System.out.println(type1);</span><br><span class="line"></span><br><span class="line">        System.out.println(integerClass.hashCode());//?</span><br><span class="line">        System.out.println(type1.hashCode());//?</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有Class对象的类型"><a href="#有Class对象的类型" class="headerlink" title="有Class对象的类型"></a>有Class对象的类型</h4><ul><li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类 </li><li>interface :接口 </li><li>数组 </li><li>enum：枚举 </li><li>annotation ：注解 </li><li>基本数据类型 </li><li>void</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a><strong>类加载</strong></h3><h4 id="基本介绍-70"><a href="#基本介绍-70" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>反射机制是 java 实现动态语言的关键，也就是通过反射实现类动态加载</p></li><li><p>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</p></li><li><p>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</p></li></ul><h4 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h4><ul><li><p>当创建对象时 (new）&#x2F;&#x2F;静态加载</p></li><li><p>当子类被加载时，父类也加载 &#x2F;&#x2F;静态加载</p></li><li><p>调用类中的静态成员时 &#x2F;&#x2F;静态加载</p></li><li><p>通过反射 &#x2F;&#x2F;动态加载</p></li></ul><h5 id="过程图"><a href="#过程图" class="headerlink" title="过程图"></a><strong>过程图</strong></h5><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210122031245.png" alt="image-20221012203115908"></p><h4 id="各个阶段任务"><a href="#各个阶段任务" class="headerlink" title="各个阶段任务"></a><strong>各个阶段任务</strong></h4><h5 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h5><ul><li>JVM 在该阶段的主要目的是将字节码从不同的数据源（可能是class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 java.lang.Class 对象</li></ul><h5 id="连接阶段——验证"><a href="#连接阶段——验证" class="headerlink" title="连接阶段——验证"></a>连接阶段——验证</h5><ul><li><p>目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p></li><li><p>包括：文件格式验证(是否以魔数 oxcafebabe开头)、元数据验证、字节码验证和符号引用验证</p></li><li><p>可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，缩短虛拟机类加载的时间</p></li></ul><h5 id="连接阶段——准备"><a href="#连接阶段——准备" class="headerlink" title="连接阶段——准备"></a>连接阶段——准备</h5><ul><li>JVM 会在该阶段对静态变量，分配内存井初始化（对应数据类型的默认初始值如0、OL、null false 等），这些变量所使用的内存都将在方法区中进行分配</li></ul><h5 id="连接阶段——解析"><a href="#连接阶段——解析" class="headerlink" title="连接阶段——解析"></a>连接阶段——解析</h5><ul><li>虛拟机将常量池内的符号引用替换为直接引用的过程</li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li><p>到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行<code>&lt;clinit&gt;() </code>方法的过程 </p></li><li><p><code>&lt;clinit&gt;() </code>方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句， 井进行合井 </p></li><li><p>虚拟机会保证一个类的 <code>&lt;Clinit&gt;()</code> 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code> &lt;Clinit&gt;()</code> 方其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;Clinit&gt;</code> ()方法完毕</p></li></ul><h3 id="反射获取类的结构信息"><a href="#反射获取类的结构信息" class="headerlink" title="反射获取类的结构信息"></a><strong>反射获取类的结构信息</strong></h3><h4 id="第一组Class类方法"><a href="#第一组Class类方法" class="headerlink" title="第一组Class类方法"></a>第一组Class类方法</h4><ul><li>getName<ul><li>获取全类名</li></ul></li><li>getSimpleName<ul><li>获取简单类名</li></ul></li><li>getFields:<ul><li>获取所有 public 修饰的属性，包含本类以及父类的</li></ul></li><li>getDeclaredFields<ul><li>获取本类中所有属性</li></ul></li><li>getMethods<ul><li>获取所有 public 修饰的方法，包含本类以及父类的</li></ul></li><li>getDeclaredMethods<ul><li>获取本类中所有方法</li></ul></li><li>getConstructors<ul><li>获取所有 public 修饰的构造器，包含本类</li></ul></li><li>getDeclaredConstructors<ul><li>获取本类中所有构造器</li></ul></li><li>getPackage<ul><li>lPackage 形式返回 包信息</li></ul></li><li>getSuperClass<ul><li>以 Class 形式返回父类信息</li></ul></li><li>getlnterfaces<ul><li>以 Class[] 形式返回接口信息</li></ul></li><li>getAnnotations<ul><li>以Annotation[] 形式返回注解信息</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//第一组方法API</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">class Person extends A implements IA, IB &#123;</span><br><span class="line">    //属性</span><br><span class="line">    public String name;</span><br><span class="line">    protected static int age; // 4 + 8 = 12</span><br><span class="line">    String job;</span><br><span class="line">    private double sal;</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //私有的</span><br><span class="line">    private Person(String name, int age) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方法</span><br><span class="line">    public void m1(String name, int age, double sal) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String m2() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void m3() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void m4() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二组Field类方法"><a href="#第二组Field类方法" class="headerlink" title="第二组Field类方法"></a>第二组Field类方法</h4><ul><li>getModifiers<ul><li>以 int 形式返回修饰符 <ul><li>public 是 1</li><li>private 是 2 </li><li>protected 是 4</li><li>static是8</li><li>final是 16</li></ul></li></ul></li><li>getType<ul><li>以 Class 形式返回类型</li></ul></li><li>getName<ul><li>返回属性名</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//得到Class对象</span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(&quot;com.hspedu.reflection.Person&quot;);</span><br><span class="line">        //getDeclaredFields:获取本类中所有属性</span><br><span class="line">        //规定 说明: 默认修饰符 是0 ， public  是1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        for (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(&quot;本类中所有属性=&quot; + declaredField.getName()</span><br><span class="line">                    + &quot; 该属性的修饰符值=&quot; + declaredField.getModifiers()</span><br></pre></td></tr></table></figure><h4 id="第三组Method类方法"><a href="#第三组Method类方法" class="headerlink" title="第三组Method类方法"></a>第三组Method类方法</h4><ul><li><p>getModifiers</p><ul><li><p>以 int 形式返回修饰符 </p><ul><li><p>public 是 1</p></li><li><p>private 是 2 </p></li><li><p>protected 是 4</p></li><li><p>static是8</p></li><li><p>final是 16</p></li></ul></li></ul></li><li><p>getName</p><ul><li>返回方法名</li></ul></li><li><p>getParameterTypes</p><ul><li>以 Class[] 返回参数类型数组</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//getMethods:获取所有public修饰的方法，包含本类以及父类的</span><br><span class="line">        Method[] methods = personCls.getMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            System.out.println(&quot;本类以及父类的方法=&quot; + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        //getDeclaredMethods:获取本类中所有方法</span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        for (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(&quot;本类中所有方法=&quot; + declaredMethod.getName());</span><br></pre></td></tr></table></figure><h4 id="第四组Constructor类方法"><a href="#第四组Constructor类方法" class="headerlink" title="第四组Constructor类方法"></a>第四组Constructor类方法</h4><ul><li>getModifiers<ul><li>以 int 形式返回修饰符</li></ul></li><li>getName<ul><li>返回构造器名</li></ul></li><li>getParameterTypes<ul><li>以 Class[]返回参数类型数组</li></ul></li></ul><h3 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a><strong>通过反射创建对象</strong></h3><h4 id="Class相关方法"><a href="#Class相关方法" class="headerlink" title="Class相关方法"></a>Class相关方法</h4><ul><li><p>newlnstance</p><ul><li>调用类中的无参构造器，获取对应类的对象</li></ul></li><li><p>getConstructor(Class.…clazz)</p><ul><li>根据参数列表，获取对应的 public 构造器对象</li></ul></li><li><p>getDecalared Constructor(Class..clazz)</p><ul><li>根据参数列表，获取对应的所有构造器对象</li></ul></li></ul><h4 id="Constructor类相关方法"><a href="#Constructor类相关方法" class="headerlink" title="Constructor类相关方法"></a>Constructor类相关方法</h4><ul><li><p>SetAccessible</p><ul><li>暴破</li></ul></li><li><p>newlnstance(Obiect…obj)</p><ul><li>调用构造器</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ReflecCreateInstance &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        //1. 先获取到User类的Class对象</span><br><span class="line">        Class&lt;?&gt; userClass = Class.forName(&quot;com.hspedu.reflection.User&quot;);</span><br><span class="line">        //2. 通过public的无参构造器创建实例</span><br><span class="line">        Object o = userClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        //3. 通过public的有参构造器创建实例</span><br><span class="line">        /*</span><br><span class="line">            constructor 对象就是</span><br><span class="line">            public User(String name) &#123;//public的有参构造器</span><br><span class="line">                this.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">        //3.1 先得到对应构造器</span><br><span class="line">        Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);</span><br><span class="line">        //3.2 创建实例，并传入实参</span><br><span class="line">        Object hsp = constructor.newInstance(&quot;hsp&quot;);</span><br><span class="line">        System.out.println(&quot;hsp=&quot; + hsp);</span><br><span class="line">        //4. 通过非public的有参构造器创建实例</span><br><span class="line">        //4.1 得到private的构造器对象</span><br><span class="line">        Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(int.class, String.class);</span><br><span class="line">        //4.2 创建实例</span><br><span class="line">        //暴破【暴力破解】 , 使用反射可以访问private构造器/方法/属性, 反射面前，都是纸老虎</span><br><span class="line">        constructor1.setAccessible(true);</span><br><span class="line">        Object user2 = constructor1.newInstance(100, &quot;张三丰&quot;);</span><br><span class="line">        System.out.println(&quot;user2=&quot; + user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123; //User类</span><br><span class="line">    private int age = 10;</span><br><span class="line">    private String name = &quot;韩顺平教育&quot;;</span><br><span class="line"></span><br><span class="line">    public User() &#123;//无参 public</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name) &#123;//public的有参构造器</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private User(int age, String name) &#123;//private 有参构造器</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过反射访问类"><a href="#通过反射访问类" class="headerlink" title="通过反射访问类"></a>通过反射访问类</h3><h4 id="通过反射访问类中属性"><a href="#通过反射访问类中属性" class="headerlink" title="通过反射访问类中属性"></a>通过反射访问类中属性</h4><ul><li>根据属性名获取Field对象 Field f&#x3D;  class对象.getDeclaredField(属性名); </li><li>暴破：f.setAccessible(true); </li><li>访问: f.set(o,值); System.out.print(f.get(o)); </li><li>如果是静态属性，则set和get中的参数o，可以写成null</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ReflecAccessProperty &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        //1. 得到Student类对应的 Class对象</span><br><span class="line">        Class&lt;?&gt; stuClass = Class.forName(&quot;com.hspedu.reflection.Student&quot;);</span><br><span class="line">        //2. 创建对象</span><br><span class="line">        Object o = stuClass.newInstance();//o 的运行类型就是Student</span><br><span class="line">        System.out.println(o.getClass());//Student</span><br><span class="line">        //3. 使用反射得到age 属性对象</span><br><span class="line">        Field age = stuClass.getField(&quot;age&quot;);</span><br><span class="line">        age.set(o, 88);//通过反射来操作属性</span><br><span class="line">        System.out.println(o);//</span><br><span class="line">        System.out.println(age.get(o));//返回age属性的值</span><br><span class="line"></span><br><span class="line">        //4. 使用反射操作name 属性</span><br><span class="line">        Field name = stuClass.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        //对name 进行暴破, 可以操作private 属性</span><br><span class="line">        name.setAccessible(true);</span><br><span class="line">        //name.set(o, &quot;老韩&quot;);</span><br><span class="line">        name.set(null, &quot;老韩~&quot;);//因为name是static属性，因此 o 也可以写出null</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(name.get(o)); //获取属性值</span><br><span class="line">        System.out.println(name.get(null));//获取属性值, 要求name是static</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student &#123;//类</span><br><span class="line">    public int age;</span><br><span class="line">    private static String name;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;//构造器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过反射访问类中方法"><a href="#通过反射访问类中方法" class="headerlink" title="通过反射访问类中方法"></a><strong>通过反射访问类中方法</strong></h4><ul><li>根据方法名和参数列表获取 Method 方法对象：Method m: clazz.getDeclaredMethod(方法名，xx.class); </li><li>获取对象：Object o&#x3D;class.newlnstance();</li><li>暴破：o.setAccessible(true); </li><li>访问：Object returnValue &#x3D;m.invoke(o,实参列表)：可以写成null </li><li>注意：如果是静态方法，则invoke的参数o，可以写成null</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class ReflecAccessMethod &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        //1. 得到Boss类对应的Class对象</span><br><span class="line">        Class&lt;?&gt; bossCls = Class.forName(&quot;com.hspedu.reflection.Boss&quot;);</span><br><span class="line">        //2. 创建对象</span><br><span class="line">        Object o = bossCls.newInstance();</span><br><span class="line">        //3. 调用public的hi方法</span><br><span class="line">        //Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK</span><br><span class="line">        //3.1 得到hi方法对象</span><br><span class="line">        Method hi = bossCls.getDeclaredMethod(&quot;hi&quot;, String.class);//OK</span><br><span class="line">        //3.2 调用</span><br><span class="line">        hi.invoke(o, &quot;韩顺平教育~&quot;);</span><br><span class="line"></span><br><span class="line">        //4. 调用private static 方法</span><br><span class="line">        //4.1 得到 say 方法对象</span><br><span class="line">        Method say = bossCls.getDeclaredMethod(&quot;say&quot;, int.class, String.class, char.class);</span><br><span class="line">        //4.2 因为say方法是private, 所以需要暴破，原理和前面讲的构造器和属性一样</span><br><span class="line">        say.setAccessible(true);</span><br><span class="line">        System.out.println(say.invoke(o, 100, &quot;张三&quot;, &#x27;男&#x27;));</span><br><span class="line">        //4.3 因为say方法是static的，还可以这样调用 ，可以传入null</span><br><span class="line">        System.out.println(say.invoke(null, 200, &quot;李四&quot;, &#x27;女&#x27;));</span><br><span class="line"></span><br><span class="line">        //5. 在反射中，如果方法有返回值，统一返回Object , 但是他运行类型和方法定义的返回类型一致</span><br><span class="line">        Object reVal = say.invoke(null, 300, &quot;王五&quot;, &#x27;男&#x27;);</span><br><span class="line">        System.out.println(&quot;reVal 的运行类型=&quot; + reVal.getClass());//String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //在演示一个返回的案例</span><br><span class="line">        Method m1 = bossCls.getDeclaredMethod(&quot;m1&quot;);</span><br><span class="line">        Object reVal2 = m1.invoke(o);</span><br><span class="line">        System.out.println(&quot;reVal2的运行类型=&quot; + reVal2.getClass());//Monster</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Monster &#123;&#125;</span><br><span class="line">class Boss &#123;//类</span><br><span class="line">    public int age;</span><br><span class="line">    private static String name;</span><br><span class="line"></span><br><span class="line">    public Boss() &#123;//构造器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Monster m1() &#123;</span><br><span class="line">        return new Monster();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String say(int n, String s, char c) &#123;//静态方法</span><br><span class="line">        return n + &quot; &quot; + s + &quot; &quot; + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hi(String s) &#123;//普通public方法</span><br><span class="line">        System.out.println(&quot;hi &quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射性能优化"><a href="#反射性能优化" class="headerlink" title="反射性能优化"></a><strong>反射性能优化</strong></h3><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：可以动态的创建和使用对象(也是框架底层孩心)，使用灵活，没有反射机制，框架技术就失去底层支撑 </li><li>缺点：使用反射基本是解释执行，对执行速度有影响</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class Reflection02 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        //Field</span><br><span class="line">        //Method</span><br><span class="line">        //Constructor</span><br><span class="line">        m1();</span><br><span class="line">        m2();</span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //传统方法来调用hi</span><br><span class="line">    public static void m1() &#123;</span><br><span class="line"></span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; 90; i++) &#123;</span><br><span class="line">            cat.hi();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;m1() 耗时=&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //反射机制调用方法hi</span><br><span class="line">    public static void m2() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        Class cls = Class.forName(&quot;com.hspedu.Cat&quot;);</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        Method hi = cls.getMethod(&quot;hi&quot;);</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; 900000000; i++) &#123;</span><br><span class="line">            hi.invoke(o);//反射调用方法</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;m2() 耗时=&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //反射调用优化 + 关闭访问检查</span><br><span class="line"></span><br><span class="line">    public static void m3() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        Class cls = Class.forName(&quot;com.hspedu.Cat&quot;);</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        Method hi = cls.getMethod(&quot;hi&quot;);</span><br><span class="line">        hi.setAccessible(true);//在反射调用方法时，取消访问检查</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; 900000000; i++) &#123;</span><br><span class="line">            hi.invoke(o);//反射调用方法</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;m3() 耗时=&quot; + (end - start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="关闭访问检查"><a href="#关闭访问检查" class="headerlink" title="关闭访问检查"></a>关闭访问检查</h4><ul><li>Method 和 Field、Constructor 对象都有setAccessible()方法</li><li>setAccessible 作用是启动和禁用访问安全检查的开关</li><li>参数值为 true 表示 反射的对象在使用时取消访问检查，提高反射的效率。参数值为 false 则表示反射的对象执行访问检查</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DTD</title>
      <link href="/2022/09/25/DTD/"/>
      <url>/2022/09/25/DTD/</url>
      
        <content type="html"><![CDATA[<h4 id="DTD-简介"><a href="#DTD-简介" class="headerlink" title="DTD 简介"></a>DTD 简介</h4><ul><li>DTD(文档类型定义)的作用是定义 XML 文档的合法构建模块</li><li>可以被声明于 XML 的文档中，也可作为一个外部引用</li><li>为什么使用的 DTD<ul><li>使得每个 XML 文件均可携带一个有关自身格式的描述</li><li>方便团队配合，用定义的 DTD 的的标准 来交换数据</li><li>也可以验证外部或自己的数据</li></ul></li></ul><h4 id="DTD-使用"><a href="#DTD-使用" class="headerlink" title="DTD 使用"></a>DTD 使用</h4><ul><li><p>内部的 DOCTYPE 声明</p><ul><li><code>&lt;!DOCTYPE root-element [element-declarations]&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*!DOCTYPE note (第十行)定义此文档是 note 类型的文档。</span><br><span class="line">*!ELEMENT note (第十一行)定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;</span><br><span class="line">*!ELEMENT to (第十二行)定义 to 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line">*!ELEMENT from (第十三行)定义 from 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line">*!ELEMENT heading (第十四行)定义 heading 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line">*!ELEMENT body (第十五行)定义 body 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部的文档声明</p><ul><li><code>&lt;DOCTYPE root-element SYSTEM &quot;filename&quot;</code></li></ul></li></ul><h4 id="DTD-XML-d构建模块"><a href="#DTD-XML-d构建模块" class="headerlink" title="DTD -XML d构建模块"></a>DTD -XML d构建模块</h4><ul><li><p>XML 和 HTML 文档的主要的构建模块是元素标签</p></li><li><p>均有一下简单的构建模块构成</p><ul><li><p>元素</p><ul><li>XML 和 HTML 文档的主要构建模块</li></ul></li><li><p>属性</p><ul><li><p>可提供有关元素的额外信息</p></li><li><p>总是以名称&#x2F;值的形式成对出现</p></li></ul></li><li><p>实体</p><ul><li>用来定义普通文本的变量。实体引用是对实体的引用</li><li>如 &amp;lt 被 XML 解析器解析成 字符 &lt;</li></ul></li><li><p>PCDATA</p><ul><li>是会被解析器解析的文本。这些文本将被解析器检查实体以及标记</li></ul></li><li><p>CDATA</p><ul><li>不会被解析器解析的文本</li></ul></li></ul></li></ul><h4 id="DTD-元素"><a href="#DTD-元素" class="headerlink" title="DTD -元素"></a>DTD -元素</h4><ul><li><p>在 DTD 中，元素通过元素声明来进行声明</p></li><li><p>语法</p><ul><li><p>声明一个元素</p><ul><li><code>&lt;!ELEMENT element-name category&gt;</code> 或者 <code>&lt;!ELEMENT element-name(element-content)</code></li></ul></li><li><p>空元素</p><ul><li><code>&lt;!ELEMENT element-name EMPTY&gt;</code></li></ul></li><li><p>只有 PCDATA 的元素</p><ul><li><code>&lt;!ELEMENT elemet-name(#PCDATA)&gt;</code></li></ul></li><li><p>带有任何内容的元素</p><ul><li><code>&lt;!ELEMENT element-name ANY&gt;</code></li></ul></li><li><p>带有子元素（序列）的元素，带有一个或多个子元素的元素通过圆括号中的子元素名进行声明</p><ul><li><code>&lt;!ELEMENT element-name (child1)&gt;</code> 或 <code>&lt;!ELEMENT element-name (child1,child2,...)&gt;</code></li></ul></li><li><p>声明只出现一次的异常</p><ul><li><code>&lt;!ELEMENT element-name (child-name)&gt;</code></li></ul></li><li><p>声明最少出现一次的元素</p><ul><li><code>&lt;!ELEMENT element-name (child-name+)&gt;</code></li></ul></li><li><p>声明出现零次或多次的元素</p><ul><li><code>&lt;!ELEMENT element-name (child-name*)&gt;</code></li></ul></li><li><p>声明出现零次或一次的元素</p><ul><li><code>&lt;!ELEMENT element-name (child-name?)&gt;</code></li></ul></li><li><p>声明”非…&#x2F;即…”类型的内容</p><ul><li><code>&lt;!ELEMENT note (to,from,header,(message|body))&gt;</code></li></ul></li><li><p>声明混合型的内容</p><ul><li>例子声明了：”note” 元素可包含出现零次或多次的 PCDATA、”to”、”from”、”header” 或者 “message”</li><li><code>&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</code></li></ul></li></ul></li></ul><h4 id="DTD-属性"><a href="#DTD-属性" class="headerlink" title="DTD -属性"></a>DTD -属性</h4><ul><li><p>在 DTD 中，属性通过 ATTLIST 声明来进行声明</p></li><li><p>语法</p><ul><li><code>&lt;!ATTLTST element-name attribute-name attribute-type attribute-value</code></li></ul></li><li><p>属性类型的选项</p></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>CDATA</td><td>值为字符数据 (character data)</td></tr><tr><td>(<em>en1</em>|<em>en2</em>|..)</td><td>此值是枚举列表中的一个值</td></tr><tr><td>ID</td><td>值为唯一的 id</td></tr><tr><td>IDREF</td><td>值为另外一个元素的 id</td></tr><tr><td>IDREFS</td><td>值为其他 id 的列表</td></tr><tr><td>NMTOKEN</td><td>值为合法的 XML 名称</td></tr><tr><td>NMTOKENS</td><td>值为合法的 XML 名称的列表</td></tr><tr><td>ENTITY</td><td>值是一个实体</td></tr><tr><td>ENTITIES</td><td>值是一个实体列表</td></tr><tr><td>NOTATION</td><td>此值是符号的名称</td></tr><tr><td>xml:</td><td>值是一个预定义的 XML 值</td></tr></tbody></table><ul><li><strong>属性值</strong>选项</li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>#REQUIRED</td><td>属性值是必需的</td></tr><tr><td>#IMPLIED</td><td>属性不是必需的</td></tr><tr><td>#FIXED value</td><td>属性值是固定的</td></tr></tbody></table><ul><li><p>#REQUIRED</p><ul><li><code>&lt;!ATTLIST element-name attribute-name attribute-type #REQUIRED&gt;</code></li></ul></li><li><p>#IMPLIED</p><ul><li><code>&lt;!ATTLIST element-name attribute-name attribute-type #IMPLIED&gt;</code></li></ul></li><li><p>FIXED</p><ul><li><code>&lt;!ATTLIST element-name attribute-name attribute-type #FIXED &quot;value&quot;&gt;</code></li></ul></li><li><p>列举属性值</p><ul><li>属性值为一系列固定的合法值之一，请使用列举属性值</li><li><code>&lt;!ATTLIST element-name attribute-name (en1|en2|..) default-value&gt;</code></li></ul></li></ul><h4 id="DTD-实体"><a href="#DTD-实体" class="headerlink" title="DTD -实体"></a>DTD -实体</h4><ul><li><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量</p><ul><li>实体引用是对实体的引用</li><li>实体可在内部或外部进行声明</li></ul></li><li><p>一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)</p></li><li></li><li><p>一个内部实体声明</p><ul><li><code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DTD 实例:</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML 实例：</span><br><span class="line"></span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><ul><li>一个外部实体声明<ul><li><code>&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DTD 实例:</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML example:</span><br><span class="line"></span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h4 id="DTD-验证"><a href="#DTD-验证" class="headerlink" title="DTD 验证"></a>DTD 验证</h4><ul><li>可根据某个 DTD 来验证您的 XML</li></ul><h4 id="DTD-总结"><a href="#DTD-总结" class="headerlink" title="DTD 总结"></a>DTD 总结</h4><ul><li>如何描述 XML 文档的结构。</li><li>如何使用 DTD 来定义一个 XML 文档的合法元素，以及如何在 XML 内部或者作为一个外部引用来声明 DTD</li><li>学习了如何为 XML 文档声明合法的元素、属性、实体以及 CDATA 部分。</li><li>了如何根据某个 DTD 来验证一个 XML 文档</li></ul>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> XML </tag>
            
            <tag> DTD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="/2022/09/25/Servlet/"/>
      <url>/2022/09/25/Servlet/</url>
      
        <content type="html"><![CDATA[<h3 id="Servlet-简介"><a href="#Servlet-简介" class="headerlink" title="Servlet 简介"></a>Servlet 简介</h3><ul><li>Java Servlet 是运行在 <strong>Web 服务器</strong>或<strong>应用服务器</strong>上的程序</li><li>它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层</li><li>使用 Servlet，可以收集来自网页<strong>表单</strong>的用户输入，<strong>呈现</strong>来自<strong>数据库</strong>或者其他源的记录，还可以<strong>动态</strong>创建网页</li><li>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，有以下几点优点<ul><li>性能好</li><li>Servlet 在 Web服务器地址空间执行。没必要再创建一个单独的进程来处理每个客户端的请求</li><li>独立于平台</li><li>更安全</li><li>Java 类库的全部功能对 Servlet 都是可用的<ul><li>通过 <strong>sockets</strong> 和 <strong>RMI(<strong>Remote Method Invocation</strong>)</strong> 机制与 applets、数据库或其他软件进行交互</li></ul></li></ul></li></ul><h3 id="Servlet-框架图"><a href="#Servlet-框架图" class="headerlink" title="Servlet 框架图"></a>Servlet 框架图</h3><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202209241337018.png" alt="image-20220924133725981"></p><h3 id="Servlet-任务"><a href="#Servlet-任务" class="headerlink" title="Servlet 任务"></a>Servlet 任务</h3><ul><li>读取客户端(浏览器)发送的显示的数据<ul><li>这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单</li></ul></li><li>读取客户端(浏览器)发送的隐式 HTTP 请求数据<ul><li>这包括 cookies、媒体类型和浏览器能理解的压缩格式等等</li></ul></li><li>处理数据并生成结果<ul><li>这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应</li></ul></li><li>发送显示的数据(文档)到客户端(浏览器)<ul><li>该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等</li></ul></li><li>发送隐式的 HTTP 响应到客户端(浏览器)<ul><li>这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务</li></ul></li></ul><h3 id="Servlet-包及其创建"><a href="#Servlet-包及其创建" class="headerlink" title="Servlet 包及其创建"></a>Servlet 包及其创建</h3><ul><li><p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类</p></li><li><p>Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 Java 企业版的标准组成部分</p></li><li><p>Servlet 创建的三种方式</p><ul><li><p><strong>实现 Servlet 接口</strong></p></li><li><p><strong>继承 GenericServlet 类</strong></p></li><li><p><strong>继承 HttpServlet 方法</strong></p><ul><li>重写 doPost() 和 doGet() 方法</li><li>经常用的方法</li></ul></li></ul></li></ul><p>注释(三者之间的关系)：对于一个 Servlet 类，我们日常最常用的方法是继承自 HttpServlet 类，提供了 Http 相关的方法，HttpServlet 扩展了 GenericServlet 类，而 GenericServlet 类又实现了 Servlet 类和 ServletConfig 类</p><h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><p>被定义从创建知道毁灭的整个过程</p><ul><li>Servlet 初始化后调用 init() 方法<ul><li>被设置只被调用一次，在第一次创建 Servlet 是被调用</li><li>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void init() throws ServletException &#123;</span><br><span class="line">  // 初始化代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Servlet 调用 service() 方法来处理用户端的请求</p><ul><li><p>是执行认为的主要方法</p></li><li><p>Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端</p></li><li><p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void service(ServletRequest request, </span><br><span class="line">                    ServletResponse response) </span><br><span class="line">      throws ServletException, IOException&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doGet() 方法<ul><li>GET 请求来自于一个 URL 的正常请求，或者来自于一个<em><strong>未指定</strong></em> METHOD 的 HTML 表单，它由 doGet() 方法处理</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void doGet(HttpServletRequest request,</span><br><span class="line">                  HttpServletResponse response)</span><br><span class="line">    throws ServletException, IOException &#123;</span><br><span class="line">    // Servlet 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doPost() 方法<ul><li>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void doPost(HttpServletRequest request,</span><br><span class="line">                   HttpServletResponse response)</span><br><span class="line">    throws ServletException, IOException &#123;</span><br><span class="line">    // Servlet 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Servlet 销毁前调用 destroy() 方法<ul><li>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void destroy() &#123;</span><br><span class="line">  // 终止化代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>最后由 JVM(java虚拟机) 的垃圾回收器进行垃圾回收</p></li><li><p>框架图</p><ul><li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器</li><li>Servlet 容器在调用 service() 方法之前加载 Servlet</li><li>然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 servlet() 方法</li><li><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202209241414588.png" alt="image-20220924141427525"></li></ul></li></ul><h3 id="Servlet-实例"><a href="#Servlet-实例" class="headerlink" title="Servlet 实例"></a>Servlet 实例</h3><ul><li>Servlet 是服务 HTTP 请求并实现 javax.servlet.Servlet 接口的 Java 类。</li><li>Web开发人员通常编写 Servlet 来扩展 javax.serlet.http.HTTPServlet 接口的抽象类专门用来处理 HTTP 请求</li><li>示例</li></ul><h3 id="Servlet-表单数据"><a href="#Servlet-表单数据" class="headerlink" title="Servlet 表单数据"></a>Servlet 表单数据</h3><ul><li>浏览器将信息传递到 Web 服务器的两种方法</li></ul><h4 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h4><ul><li>GET 方法向页面请求发送已编码的用户信息</li><li>页面和已编码的信息中间用？字符分割<ul><li>例如<code>http://www.xinye.com/hi?key1=value1&amp;key2=value2</code></li></ul></li><li>GET方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏里。<ul><li>如果传递的是密码和其他敏感信息，请不要使用 GET 方法</li><li>请求字符串最多只能有 1024 个字符串</li><li>通过 QUERY_STRING 头传递和访问</li></ul></li><li>Servlet 使用 doGet()方法处理这类型的请求</li></ul><h4 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h4><ul><li>POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不上把信息作为 URL 中？字符后的文本进行发送，而是把这些信息作为一个单独的信息。</li><li>消息以标准输出的形式传到后台程序，可以进行解析和使用这些标准输出</li><li>Servlet 使用 doPost()方法来处理这种类型的请求</li></ul><h4 id="使用-Servlet-读取表单的数据"><a href="#使用-Servlet-读取表单的数据" class="headerlink" title="使用 Servlet 读取表单的数据"></a>使用 Servlet 读取表单的数据</h4><ul><li>Servlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析<ul><li><code>getParameter()</code><ul><li>调用<code>request.getParameter()</code>的方法来获取表单参数的值</li></ul></li><li><code>getParameterValues()</code><ul><li>如果参数出现一次以上，则会调用该方法，并返回多个值，例如复选框</li></ul></li><li><code>getParameterNames()</code><ul><li>如果你想要得到当前请求中的所有参数的完成列表，则调用该方法</li></ul></li></ul></li></ul><p>注释：<code>request.getParameter(String name)</code> 是获取相应名的数据，如果有重复的名，则返回第一个值，接受一般变量，如 text 类型;</p><p><code>request.getParameterValues(String name)</code>是获取如 checkbox类(名字相同，但值有多个)的数据，接受数组变量，如checkbox类型</p><h3 id="Servlet-客户端-HTTP-请求"><a href="#Servlet-客户端-HTTP-请求" class="headerlink" title="Servlet 客户端 HTTP 请求"></a>Servlet 客户端 HTTP 请求</h3><ul><li>当浏览器请求网页时，他会向 Web 服务器发送特定信息，这些信息不能被直接读取，因为这些信息时作为 HTTP 请求的头的一部分进行传输的。</li></ul><h4 id="读取-HTTP-头的方法"><a href="#读取-HTTP-头的方法" class="headerlink" title="读取 HTTP 头的方法"></a>读取 HTTP 头的方法</h4><ul><li>可以在Servlet 程序中读取 HTTP 头，这些方法通过 HTTPServletRequest对象可用</li></ul><table><thead><tr><th>序号</th><th>方法及其描述</th></tr></thead><tbody><tr><td>1</td><td><strong>Cookie[] getCookies()</strong> &#x2F;&#x2F;返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</td></tr><tr><td>2</td><td><strong>Enumeration getAttributeNames()</strong> &#x2F;&#x2F;返回一个枚举，包含提供给该请求可用的属性名称。</td></tr><tr><td>3</td><td><strong>Enumeration getHeaderNames()</strong> &#x2F;&#x2F;返回一个枚举，包含在该请求中包含的所有的头名。</td></tr><tr><td>4</td><td><strong>Enumeration getParameterNames()</strong> &#x2F;&#x2F;返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。</td></tr><tr><td>5</td><td><strong>HttpSession getSession()</strong> &#x2F;&#x2F;返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。</td></tr><tr><td>6</td><td><strong>HttpSession getSession(boolean create)</strong> &#x2F;&#x2F;返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。</td></tr><tr><td>7</td><td><strong>Locale getLocale()</strong> &#x2F;&#x2F;基于 Accept-Language 头，返回客户端接受内容的首选的区域设置。</td></tr><tr><td>8</td><td><strong>Object getAttribute(String name)</strong> &#x2F;&#x2F;以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。</td></tr><tr><td>9</td><td><strong>ServletInputStream getInputStream()</strong> &#x2F;&#x2F;使用 ServletInputStream，以二进制数据形式检索请求的主体。</td></tr><tr><td>10</td><td><strong>String getAuthType()</strong> &#x2F;&#x2F;返回用于保护 Servlet 的身份验证方案的名称，例如，”BASIC” 或 “SSL”，如果JSP没有受到保护则返回 null。</td></tr><tr><td>11</td><td><strong>String getCharacterEncoding()</strong> &#x2F;&#x2F;返回请求主体中使用的字符编码的名称。</td></tr><tr><td>12</td><td><strong>String getContentType()</strong>&#x2F;&#x2F;返回请求主体的 MIME 类型，如果不知道类型则返回 null。</td></tr><tr><td>13</td><td><strong>String getContextPath()</strong> &#x2F;&#x2F;返回指示请求上下文的请求 URI 部分。</td></tr><tr><td>14</td><td><strong>String getHeader(String name)</strong> &#x2F;&#x2F;以字符串形式返回指定的请求头的值。</td></tr><tr><td>15</td><td><strong>String getMethod()</strong> &#x2F;&#x2F;返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</td></tr><tr><td>16</td><td><strong>String getParameter(String name)</strong> &#x2F;&#x2F;以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</td></tr><tr><td>17</td><td><strong>String getPathInfo()</strong> &#x2F;&#x2F;请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。</td></tr><tr><td>18</td><td><strong>String getProtocol()</strong> &#x2F;&#x2F;返回请求协议的名称和版本。</td></tr><tr><td>19</td><td><strong>String getQueryString()</strong> &#x2F;&#x2F;返回包含在路径后的请求 URL 中的查询字符串。</td></tr><tr><td>20</td><td><strong>String getRemoteAddr()</strong> &#x2F;&#x2F;返回发送请求的客户端的互联网协议（IP）地址。</td></tr><tr><td>21</td><td><strong>String getRemoteHost()</strong> &#x2F;&#x2F;返回发送请求的客户端的完全限定名称。</td></tr><tr><td>22</td><td><strong>String getRemoteUser()</strong> &#x2F;&#x2F;如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。</td></tr><tr><td>23</td><td><strong>String getRequestURI()</strong> &#x2F;&#x2F;从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。</td></tr><tr><td>24</td><td><strong>String getRequestedSessionId()</strong> &#x2F;&#x2F;返回由客户端指定的 session 会话 ID。</td></tr><tr><td>25</td><td><strong>String getServletPath()</strong> &#x2F;&#x2F;返回调用 JSP 的请求的 URL 的一部分。</td></tr><tr><td>26</td><td><strong>String[] getParameterValues(String name)</strong> &#x2F;&#x2F;返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。</td></tr><tr><td>27</td><td><strong>boolean isSecure()</strong> &#x2F;&#x2F;返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。</td></tr><tr><td>28</td><td><strong>int getContentLength()</strong> &#x2F;&#x2F;以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。</td></tr><tr><td>29</td><td><strong>int getIntHeader(String name)</strong> &#x2F;&#x2F;返回指定的请求头的值为一个 int 值。</td></tr><tr><td>30</td><td><strong>int getServerPort()</strong> &#x2F;&#x2F;返回接收到这个请求的端口号。</td></tr><tr><td>31</td><td><strong>int getParameterMap()</strong> &#x2F;&#x2F;将参数封装成 Map 类型。</td></tr></tbody></table><ul><li>HTTP Header 请求实例<ul><li>实例使用 HttpServletRequest 的 <strong>getHeaderNames()</strong> 方法读取 HTTP 头信息。该方法返回一个枚举，包含与当前的 HTTP 请求相关的头信息</li><li>一旦我们有一个枚举，我们可以以标准方式循环枚举，使用 <em>hasMoreElements()</em> 方法来确定何时停止，使用 <em>nextElement()</em> 方法来获取每个参数的名称</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//导入必需的 java 库</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/DisplayHeader&quot;)</span><br><span class="line"></span><br><span class="line">//扩展 HttpServlet 类</span><br><span class="line">public class DisplayHeader extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    // 处理 GET 方法请求的方法</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;HTTP Header 请求实例&quot;;</span><br><span class="line">        String docType =</span><br><span class="line">            &quot;&lt;!DOCTYPE html&gt; \n&quot;;</span><br><span class="line">            out.println(docType +</span><br><span class="line">            &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;table width=\&quot;100%\&quot; border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;th&gt;Header 名称&lt;/th&gt;&lt;th&gt;Header 值&lt;/th&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;/tr&gt;\n&quot;);</span><br><span class="line"></span><br><span class="line">        Enumeration headerNames = request.getHeaderNames();</span><br><span class="line"></span><br><span class="line">        while(headerNames.hasMoreElements()) &#123;</span><br><span class="line">            String paramName = (String)headerNames.nextElement();</span><br><span class="line">            out.print(&quot;&lt;tr&gt;&lt;td&gt;&quot; + paramName + &quot;&lt;/td&gt;\n&quot;);</span><br><span class="line">            String paramValue = request.getHeader(paramName);</span><br><span class="line">            out.println(&quot;&lt;td&gt; &quot; + paramValue + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(&quot;&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理 POST 方法请求的方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//对于的web.xml配置</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app&gt;  </span><br><span class="line">  &lt;servlet&gt;  </span><br><span class="line">    &lt;!-- 类名 --&gt;  </span><br><span class="line">    &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;!-- 所在的包 --&gt;  </span><br><span class="line">    &lt;servlet-class&gt;com.runoob.test.DisplayHeader&lt;/servlet-class&gt;  </span><br><span class="line">  &lt;/servlet&gt;  </span><br><span class="line">  &lt;servlet-mapping&gt;  </span><br><span class="line">    &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;!-- 访问的网址 --&gt;  </span><br><span class="line">    &lt;url-pattern&gt;/TomcatTest/DisplayHeader&lt;/url-pattern&gt;  </span><br><span class="line">  &lt;/servlet-mapping&gt;  </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h3 id="Servlet-服务器-HTTP-响应"><a href="#Servlet-服务器-HTTP-响应" class="headerlink" title="Servlet 服务器 HTTP 响应"></a>Servlet 服务器 HTTP 响应</h3><ul><li>当一个 Web 服务器响应一个 HTTP 请求时，响应通常包括一个状态行、一些响应报头、一个空行和文档</li></ul><h4 id="设置-HTTP-响应报头的方法"><a href="#设置-HTTP-响应报头的方法" class="headerlink" title="设置 HTTP 响应报头的方法"></a>设置 HTTP 响应报头的方法</h4><ul><li>下面的方法可用于在 Servlet 程序中设置 HTTP 响应报头</li><li>这些方法通过 <em>HttpServletResponse</em> 对象可用</li></ul><table><thead><tr><th>序号</th><th>方法以及描述</th></tr></thead><tbody><tr><td>1</td><td><strong>String encodeRedirectURL(String url)</strong> &#x2F;&#x2F;为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td></tr><tr><td>2</td><td><strong>String encodeURL(String url)</strong> &#x2F;&#x2F;对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td></tr><tr><td>3</td><td><strong>boolean containsHeader(String name)</strong> &#x2F;&#x2F;返回一个布尔值，指示是否已经设置已命名的响应报头。</td></tr><tr><td>4</td><td><strong>boolean isCommitted()</strong> &#x2F;&#x2F;返回一个布尔值，指示响应是否已经提交。</td></tr><tr><td>5</td><td><strong>void addCookie(Cookie cookie)</strong> &#x2F;&#x2F;把指定的 cookie 添加到响应。</td></tr><tr><td>6</td><td><strong>void addDateHeader(String name, long date)</strong> &#x2F;&#x2F;添加一个带有给定的名称和日期值的响应报头。</td></tr><tr><td>7</td><td><strong>void addHeader(String name, String value)</strong> &#x2F;&#x2F;添加一个带有给定的名称和值的响应报头。</td></tr><tr><td>8</td><td><strong>void addIntHeader(String name, int value)</strong> &#x2F;&#x2F;添加一个带有给定的名称和整数值的响应报头。</td></tr><tr><td>9</td><td><strong>void flushBuffer()</strong> &#x2F;&#x2F;强制任何在缓冲区中的内容被写入到客户端。</td></tr><tr><td>10</td><td><strong>void reset()</strong> &#x2F;&#x2F;清除缓冲区中存在的任何数据，包括状态码和头。</td></tr><tr><td>11</td><td><strong>void resetBuffer()</strong> &#x2F;&#x2F;清除响应中基础缓冲区的内容，不清除状态码和头。</td></tr><tr><td>12</td><td><strong>void sendError(int sc)</strong> &#x2F;&#x2F;使用指定的状态码发送错误响应到客户端，并清除缓冲区。</td></tr><tr><td>13</td><td><strong>void sendError(int sc, String msg)</strong> &#x2F;&#x2F;使用指定的状态发送错误响应到客户端。</td></tr><tr><td>14</td><td><strong>void sendRedirect(String location)</strong> &#x2F;&#x2F;使用指定的重定向位置 URL 发送临时重定向响应到客户端。</td></tr><tr><td>15</td><td><strong>void setBufferSize(int size)</strong> &#x2F;&#x2F;为响应主体设置首选的缓冲区大小。</td></tr><tr><td>16</td><td><strong>void setCharacterEncoding(String charset)</strong> &#x2F;&#x2F;设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。</td></tr><tr><td>17</td><td><strong>void setContentLength(int len)</strong> &#x2F;&#x2F;设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头。</td></tr><tr><td>18</td><td><strong>void setContentType(String type)</strong> &#x2F;&#x2F;如果响应还未被提交，设置被发送到客户端的响应的内容类型。</td></tr><tr><td>19</td><td><strong>void setDateHeader(String name, long date)</strong> &#x2F;&#x2F;设置一个带有给定的名称和日期值的响应报头。</td></tr><tr><td>20</td><td><strong>void setHeader(String name, String value)</strong> &#x2F;&#x2F;设置一个带有给定的名称和值的响应报头。</td></tr><tr><td>21</td><td><strong>void setIntHeader(String name, int value)</strong> &#x2F;&#x2F;设置一个带有给定的名称和整数值的响应报头。</td></tr><tr><td>22</td><td><strong>void setLocale(Locale loc)</strong> &#x2F;&#x2F;如果响应还未被提交，设置响应的区域。</td></tr><tr><td>23</td><td><strong>void setStatus(int sc)</strong> &#x2F;&#x2F;为该响应设置状态码。</td></tr></tbody></table><ul><li>HTTP Header 响应实例<ul><li>前面的实例中看到 setContentType() 方法，下面的实例也使用了同样的方法，此外，我们会用 <strong>setIntHeader()</strong> 方法来设置 <strong>Refresh</strong> 头</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//导入必需的 java 库</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/Refresh&quot;)</span><br><span class="line"></span><br><span class="line">//扩展 HttpServlet 类</span><br><span class="line">public class Refresh extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    // 处理 GET 方法请求的方法</span><br><span class="line">      public void doGet(HttpServletRequest request,</span><br><span class="line">                        HttpServletResponse response)</span><br><span class="line">                throws ServletException, IOException</span><br><span class="line">      &#123;</span><br><span class="line">          // 设置刷新自动加载时间为 5 秒</span><br><span class="line">          response.setIntHeader(&quot;Refresh&quot;, 5);</span><br><span class="line">          // 设置响应内容类型</span><br><span class="line">          response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">         </span><br><span class="line">          //使用默认时区和语言环境获得一个日历  </span><br><span class="line">          Calendar cale = Calendar.getInstance();  </span><br><span class="line">          //将Calendar类型转换成Date类型  </span><br><span class="line">          Date tasktime=cale.getTime();  </span><br><span class="line">          //设置日期输出的格式  </span><br><span class="line">          SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  </span><br><span class="line">          //格式化输出  </span><br><span class="line">          String nowTime = df.format(tasktime);</span><br><span class="line">          PrintWriter out = response.getWriter();</span><br><span class="line">          String title = &quot;自动刷新 Header 设置 ;</span><br><span class="line">          String docType =</span><br><span class="line">          &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">          out.println(docType +</span><br><span class="line">            &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;p&gt;当前时间是：&quot; + nowTime + &quot;&lt;/p&gt;\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 处理 POST 方法请求的方法</span><br><span class="line">      public void doPost(HttpServletRequest request,</span><br><span class="line">                         HttpServletResponse response)</span><br><span class="line">          throws ServletException, IOException &#123;</span><br><span class="line">         doGet(request, response);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//对应的 web.xml 配置</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app&gt;  </span><br><span class="line">  &lt;servlet&gt;  </span><br><span class="line">     &lt;!-- 类名 --&gt;  </span><br><span class="line">    &lt;servlet-name&gt;Refresh&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;!-- 所在的包 --&gt;  </span><br><span class="line">    &lt;servlet-class&gt;com.runoob.test.Refresh&lt;/servlet-class&gt;  </span><br><span class="line">  &lt;/servlet&gt;  </span><br><span class="line">  &lt;servlet-mapping&gt;  </span><br><span class="line">    &lt;servlet-name&gt;Refresh&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;!-- 访问的网址 --&gt;  </span><br><span class="line">    &lt;url-pattern&gt;/TomcatTest/Refresh&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/servlet-mapping&gt;  </span><br><span class="line">&lt;/web-app&gt; </span><br></pre></td></tr></table></figure><h3 id="Servlet-HTTP-状态码"><a href="#Servlet-HTTP-状态码" class="headerlink" title="Servlet HTTP 状态码"></a>Servlet HTTP 状态码</h3><ul><li><p>HTTP 请求和 HTTP 响应消息的格式是类似的</p><ul><li>初始状态行 + 回车换行符（回车+换行）</li><li>零个或多个标题行+回车换行符</li><li>一个空白行，即回车换行符</li><li>一个可选的消息主体，比如文件、查询数据或查询输出</li></ul></li><li><p>例如访问出错后显示的数据，就有状态码</p></li><li><p>服务器的响应头例子</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Header2: ...</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">  (Blank Line)</span><br><span class="line">&lt;!doctype ...&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;...&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="Servlet-编写过滤器"><a href="#Servlet-编写过滤器" class="headerlink" title="Servlet 编写过滤器"></a>Servlet 编写过滤器</h3><ul><li><p>Servlet 过滤器可以<strong>动态地拦截请求和响应</strong>，以变换或使用包含在请求或响应中的信息</p></li><li><p>可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet</p></li><li><p>过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前调用所有附加的 Servlet 过滤器</p></li><li><p>Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的</p><ul><li>在客户端的请求访问后端资源之前，拦截这些请求</li><li>在服务器的响应发送回客户端之前，处理这些响应</li></ul></li><li><p>过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式</p><ul><li>当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例</li><li>Filter的执行顺序与在web.xml配置文件中的配置顺序一致，<strong>一般把Filter配置在所有的Servlet之前</strong></li></ul></li></ul><h4 id="Servlet-过滤器方法"><a href="#Servlet-过滤器方法" class="headerlink" title="Servlet 过滤器方法"></a>Servlet 过滤器方法</h4><ul><li>过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类<ul><li>javax.servlet.Filter 接口定义了三个方法</li></ul></li></ul><table><thead><tr><th>序号</th><th>方法及其描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public void doFilter (ServletRequest, ServletResponse, FilterChain)</strong> &#x2F;&#x2F;该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。</td></tr><tr><td>2</td><td><strong>public void init(FilterConfig filterConfig)</strong> &#x2F;&#x2F;web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</td></tr><tr><td>3</td><td><strong>public void destroy()</strong> &#x2F;&#x2F;Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。</td></tr></tbody></table><h4 id="Servlet-过滤器实例"><a href="#Servlet-过滤器实例" class="headerlink" title="Servlet 过滤器实例"></a>Servlet 过滤器实例</h4><ul><li>Servlet 过滤器的实例，将输出网站名称和地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.runoob.test;</span><br><span class="line"></span><br><span class="line">//导入必需的 java 库</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">//实现 Filter 类</span><br><span class="line">public class LogFilter implements Filter  &#123;</span><br><span class="line">    public void  init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">        // 获取初始化参数</span><br><span class="line">        String site = config.getInitParameter(&quot;Site&quot;); </span><br><span class="line"></span><br><span class="line">        // 输出初始化参数</span><br><span class="line">        System.out.println(&quot;网站名称: &quot; + site); </span><br><span class="line">    &#125;</span><br><span class="line">    public void  doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        // 输出站点名称</span><br><span class="line">        System.out.println(&quot;站点网址：http://www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">        // 把请求传回过滤链</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">    public void destroy( )&#123;</span><br><span class="line">        /* 在 Filter 实例被 Web 容器从服务移除之前调用 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>DisplayHeader例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.runoob.test;</span><br><span class="line"></span><br><span class="line">//导入必需的 java 库</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">//实现 Filter 类</span><br><span class="line">public class LogFilter implements Filter  &#123;</span><br><span class="line">    public void  init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">        // 获取初始化参数</span><br><span class="line">        String site = config.getInitParameter(&quot;Site&quot;); </span><br><span class="line"></span><br><span class="line">        // 输出初始化参数</span><br><span class="line">        System.out.println(&quot;网站名称: &quot; + site); </span><br><span class="line">    &#125;</span><br><span class="line">    public void  doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        // 输出站点名称</span><br><span class="line">        System.out.println(&quot;站点网址：http://www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">        // 把请求传回过滤链</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">    public void destroy( )&#123;</span><br><span class="line">        /* 在 Filter 实例被 Web 容器从服务移除之前调用 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这边使用前文提到的 DisplayHeader.java 为例子：</span><br><span class="line"></span><br><span class="line">//导入必需的 java 库</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/DisplayHeader&quot;)</span><br><span class="line"></span><br><span class="line">//扩展 HttpServlet 类</span><br><span class="line">public class DisplayHeader extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    // 处理 GET 方法请求的方法</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;HTTP Header 请求实例 - 菜鸟教程实例&quot;;</span><br><span class="line">        String docType =</span><br><span class="line">            &quot;&lt;!DOCTYPE html&gt; \n&quot;;</span><br><span class="line">            out.println(docType +</span><br><span class="line">            &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;table width=\&quot;100%\&quot; border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;th&gt;Header 名称&lt;/th&gt;&lt;th&gt;Header 值&lt;/th&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;/tr&gt;\n&quot;);</span><br><span class="line"></span><br><span class="line">        Enumeration headerNames = request.getHeaderNames();</span><br><span class="line"></span><br><span class="line">        while(headerNames.hasMoreElements()) &#123;</span><br><span class="line">            String paramName = (String)headerNames.nextElement();</span><br><span class="line">            out.print(&quot;&lt;tr&gt;&lt;td&gt;&quot; + paramName + &quot;&lt;/td&gt;\n&quot;);</span><br><span class="line">            String paramValue = request.getHeader(paramName);</span><br><span class="line">            out.println(&quot;&lt;td&gt; &quot; + paramValue + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(&quot;&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理 POST 方法请求的方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Web.xml 中的 Servlet 过滤器映射（Servlet Filter Mapping）<ul><li>定义过滤器，然后映射到一个 URL 或 Servlet，这与定义 Servlet，然后映射到一个 URL 模式方式大致相同</li><li>部署描述符文件 <strong>web.xml</strong> 中为 filter 标签创建下面的条目：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app&gt;  </span><br><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.runoob.test.LogFilter&lt;/filter-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;Site&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;菜鸟教程&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">  &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt; //过滤器适用于所有的 Servlet，因为我们在配置中指定 /* </span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line">&lt;servlet&gt;  </span><br><span class="line">  &lt;!-- 类名 --&gt;  </span><br><span class="line">  &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;  </span><br><span class="line">  &lt;!-- 所在的包 --&gt;  </span><br><span class="line">  &lt;servlet-class&gt;com.runoob.test.DisplayHeader&lt;/servlet-class&gt;  </span><br><span class="line">&lt;/servlet&gt;  </span><br><span class="line">&lt;servlet-mapping&gt;  </span><br><span class="line">  &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;  </span><br><span class="line">  &lt;!-- 访问的网址 --&gt;  </span><br><span class="line">  &lt;url-pattern&gt;/TomcatTest/DisplayHeader&lt;/url-pattern&gt;  </span><br><span class="line">&lt;/servlet-mapping&gt;  </span><br><span class="line">&lt;/web-app&gt; </span><br></pre></td></tr></table></figure><h4 id="使用多个过滤器"><a href="#使用多个过滤器" class="headerlink" title="使用多个过滤器"></a>使用多个过滤器</h4><ul><li>Web 应用程序可以根据特定的目的定义若干个不同的过滤器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;com.runoob.test.LogFilter&lt;/filter-class&gt;</span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;test-param&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt; //初始化参数</span><br><span class="line">   &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;com.runoob.test.AuthenFilter&lt;/filter-class&gt;</span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;test-param&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt;</span><br><span class="line">   &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><h4 id="过滤器的应用顺序"><a href="#过滤器的应用顺序" class="headerlink" title="过滤器的应用顺序"></a>过滤器的应用顺序</h4><ul><li>web.xml 中的 filter-mapping 元素的顺序决定了 Web 容器应用过滤器到 Servlet 的顺序</li></ul><h4 id="web-xml-配置各个节点说明"><a href="#web-xml-配置各个节点说明" class="headerlink" title="web.xml 配置各个节点说明"></a>web.xml 配置各个节点说明</h4><ul><li><p><code>&lt;filter&gt;</code></p><p>指定一个过滤器</p><ul><li><code>&lt;filter-name&gt;</code>用于为过滤器指定一个名字，该元素的内容不能为空。</li><li><code>&lt;filter-class&gt;</code>元素用于指定过滤器的完整的限定类名。</li><li><code>&lt;init-param&gt;</code>元素用于为过滤器指定初始化参数，它的子元素<code>&lt;param-name&gt;</code>指定参数的名字，<code>&lt;param-value&gt;</code>指定参数的值。</li><li>在过滤器中，可以使用<code>FilterConfig</code>接口对象来访问初始化参数。</li></ul></li><li><p><code>&lt;filter-mapping&gt;</code></p><p>元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径</p><ul><li><code>&lt;filter-name&gt;</code>子元素用于设置filter的注册名称。该值必须是在<code>&lt;filter&gt;</code>元素中声明过的过滤器的名字</li><li><code>&lt;url-pattern&gt;</code>设置 filter 所拦截的请求路径(过滤器关联的URL样式)</li></ul></li><li><p><code>&lt;servlet-name&gt;</code>指定过滤器所拦截的Servlet名称。</p></li><li><p><code>&lt;dispatcher&gt;</code>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是<code>REQUEST</code>,<code>INCLUDE</code>,<code>FORWARD</code>和<code>ERROR</code>之一，默认<code>REQUEST</code>。用户可以设置多个<code>&lt;dispatcher&gt;</code>子元素用来指定 Filter 对资源的多种调用方式进行拦截。</p></li><li><p><code>&lt;dispatcher&gt;</code></p><p>子元素可以设置的值及其意义</p><ul><li><code>REQUEST</code>：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li><li><code>INCLUDE</code>：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li><li><code>FORWARD</code>：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li><li><code>ERROR</code>：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li></ul></li></ul><h4 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h4><ul><li>过滤器中我们可以根据 doFilter() 方法中的 request 对象获取表单参数信息，例如我们可以获取到请求的用户名和密码进行逻辑处理，也可以通过 response 对用户做出回应。</li><li>比如如果验证用户名不正确，禁止用户访问 web 资源，并且向浏览器输出提示，告诉用户用户名或者密码不正确等等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest req, ServletResponse resp,</span><br><span class="line">FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    //获取请求信息(测试时可以通过get方式在URL中添加name)</span><br><span class="line">    //http://localhost:8080/servlet_demo/helloword?name=123</span><br><span class="line">    String name = req.getParameter(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">    // 过滤器核心代码逻辑</span><br><span class="line">    System.out.println(&quot;过滤器获取请求参数:&quot;+name);</span><br><span class="line">    System.out.println(&quot;第二个过滤器执行--网站名称：www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">    if(&quot;123&quot;.equals(name))&#123;</span><br><span class="line">        // 把请求传回过滤链</span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //设置返回内容类型</span><br><span class="line">        resp.setContentType(&quot;text/html;charset=GBK&quot;);</span><br><span class="line"></span><br><span class="line">        //在页面输出响应信息</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.print(&quot;&lt;b&gt;name不正确，请求被拦截，不能访问web资源&lt;/b&gt;&quot;);</span><br><span class="line">        System.out.println(&quot;name不正确，请求被拦截，不能访问web资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet-异常处理"><a href="#Servlet-异常处理" class="headerlink" title="Servlet 异常处理"></a>Servlet 异常处理</h3><ul><li><p>当一个 Servlet 抛出一个异常时，Web 容器在使用了 exception-type 元素的 <strong>web.xml</strong> 中搜索与抛出异常类型相匹配的配置。</p></li><li><p>您必须在 web.xml 中使用 <strong>error-page</strong> 元素来指定对特定<strong>异常</strong> 或 HTTP <strong>状态码</strong> 作出相应的 Servlet 调用。</p></li><li><p>例子</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- servlet 定义 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;ErrorHandler&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;ErrorHandler&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;!-- servlet 映射 --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;ErrorHandler&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/ErrorHandler&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- error-code 相关的错误页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;error-code&gt;404&lt;/error-code&gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;error-code&gt;403&lt;/error-code&gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- exception-type 相关的错误页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;</span><br><span class="line">          javax.servlet.ServletException</span><br><span class="line">    &lt;/exception-type &gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;java.io.IOException&lt;/exception-type &gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果您想对所有的异常有一个通用的错误处理程序，那么应该定义下面的 error-page，而不是为每个异常定义单独的 error-page 元素</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type &gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br></pre></td></tr></table></figure><ul><li>关于上面的 web.xml 异常处理要注意的点<ul><li>Servlet ErrorHandler 与其他的 Servlet 的定义方式一样，且在 web.xml 中进行配置。</li><li>如果有错误状态代码出现，不管为 404（Not Found 未找到）或 403（Forbidden 禁止），则会调用 ErrorHandler 的 Servlet。</li><li>如果 Web 应用程序抛出 <em>ServletException</em> 或 <em>IOException</em>，那么 Web 容器会调用 ErrorHandler 的 Servlet。</li><li>您可以定义不同的错误处理程序来处理不同类型的错误或异常。上面的实例是非常通用的，希望您能通过实例理解基本的概念。</li></ul></li></ul><h4 id="请求属性-错误-x2F-异常"><a href="#请求属性-错误-x2F-异常" class="headerlink" title="请求属性 - 错误&#x2F;异常"></a>请求属性 - 错误&#x2F;异常</h4><ul><li>用来分析错误&#x2F;异常的性质</li></ul><table><thead><tr><th>序号</th><th>属性以及描述</th></tr></thead><tbody><tr><td>1</td><td><strong>javax.servlet.error.status_code</strong> &#x2F;&#x2F;该属性给出状态码，状态码可被存储，并在存储为 java.lang.Integer 数据类型后可被分析。</td></tr><tr><td>2</td><td><strong>javax.servlet.error.exception_type</strong> &#x2F;&#x2F;属性给出异常类型的信息，异常类型可被存储，并在存储为 java.lang.Class 数据类型后可被分析。</td></tr><tr><td>3</td><td><strong>javax.servlet.error.message</strong> &#x2F;&#x2F;该属性给出确切错误消息的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr><tr><td>4</td><td><strong>javax.servlet.error.request_uri</strong> &#x2F;&#x2F;该属性给出有关 URL 调用 Servlet 的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr><tr><td>5</td><td><strong>javax.servlet.error.exception</strong> &#x2F;&#x2F;属性给出异常产生的信息，信息可被存储，并在存储为 java.lang.Throwable 数据类型后可被分析。</td></tr><tr><td>6</td><td><strong>javax.servlet.error.servlet_name</strong> &#x2F;&#x2F;属性给出 Servlet 的名称，名称可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr></tbody></table><h3 id="Servlet-Cookie-处理"><a href="#Servlet-Cookie-处理" class="headerlink" title="Servlet Cookie 处理"></a>Servlet Cookie 处理</h3><ul><li><p>Cookie 是存储在<strong>客户端</strong>计算机上的<strong>文本文件</strong>，并保留了各种<strong>跟踪信息</strong>。</p></li><li><p>Java Servlet 支持 HTTP Cookie。</p></li><li><p>识别返回用户包括三个步骤</p><ul><li><p>服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等</p></li><li><p>浏览器将这些信息存储在本地计算机上，以备将来使用</p></li><li><p>当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户</p></li></ul></li><li><p><em>Servlet Cookie 处理需要对中文进行编码与解码</em></p><ul><li>编码<ul><li><code>String   str   =   java.net.URLEncoder.encode(&quot;中文&quot;，&quot;UTF-8&quot;);</code></li></ul></li><li>解码<ul><li><code>String   str   =   java.net.URLDecoder.decode(&quot;编码后的字符串&quot;,&quot;UTF-8&quot;);   </code></li></ul></li></ul></li></ul><h4 id="Cookie-解析"><a href="#Cookie-解析" class="headerlink" title="Cookie 解析"></a>Cookie 解析</h4><ul><li>Cookie 通常设置在 HTTP 头信息中（ JavaScript 也可以直接在浏览器上设置一个 Cookie）。</li><li>设置 Cookie 的 Servlet 会发送如下的头信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 04 Feb 2000 21:03:38 GMT</span><br><span class="line">Server: Apache/1.3.9 (UNIX) PHP/4.0b3</span><br><span class="line">Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; </span><br><span class="line">                 path=/; domain=runoob.com</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure><ul><li>Set-Cookie 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码</li><li><code>expires</code> 字段是一个指令，告诉浏览器在给定的时间和日期之后”忘记”该 Cookie。如果浏览器被配置为存储 Cookie，它将会保留此信息直到到期日期</li><li>如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器</li><li>浏览器的头信息可能如下所示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">User-Agent: Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)</span><br><span class="line">Host: zink.demon.co.uk:1126</span><br><span class="line">Accept: image/gif, */*</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Language: en</span><br><span class="line">Accept-Charset: iso-8859-1,*,utf-8</span><br><span class="line">Cookie: name=xyz</span><br></pre></td></tr></table></figure><ul><li>Servlet 就能够通过请求方法<code>request.getCookies() </code>访问 Cookie，该方法将返回一个 <em>Cookie</em> 对象的数组</li></ul><h4 id="Servlet-Cookie-方法"><a href="#Servlet-Cookie-方法" class="headerlink" title="Servlet Cookie 方法"></a>Servlet Cookie 方法</h4><ul><li>在 Servlet 中操作 Cookie 时可使用的有用的方法列表</li></ul><table><thead><tr><th>序号</th><th>方法及其描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public void setDomain(String pattern)</strong> &#x2F;&#x2F;该方法设置 cookie 适用的域，例如 runoob.com。</td></tr><tr><td>2</td><td><strong>public String getDomain()</strong> &#x2F;&#x2F;方法获取 cookie 适用的域，例如 runoob.com。</td></tr><tr><td>3</td><td><strong>public void setMaxAge(int expiry)</strong> &#x2F;&#x2F;该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td></tr><tr><td>4</td><td><strong>public int getMaxAge()</strong> 该方法返回 &#x2F;&#x2F;cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td></tr><tr><td>5</td><td><strong>public String getName()</strong> &#x2F;&#x2F;该方法返回 cookie 的名称。名称在创建后不能改变。</td></tr><tr><td>6</td><td><strong>public void setValue(String newValue)</strong> &#x2F;&#x2F;该方法设置与 cookie 关联的值。</td></tr><tr><td>7</td><td><strong>public String getValue()</strong> &#x2F;&#x2F;方法获取与 cookie 关联的值。</td></tr><tr><td>8</td><td><strong>public void setPath(String uri)</strong> &#x2F;&#x2F;该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td></tr><tr><td>9</td><td><strong>public String getPath()</strong> &#x2F;&#x2F;该方法获取 cookie 适用的路径。</td></tr><tr><td>10</td><td><strong>public void setSecure(boolean flag)</strong> &#x2F;&#x2F;该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。</td></tr><tr><td>11</td><td><strong>public void setComment(String purpose)</strong> &#x2F;&#x2F;设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td></tr><tr><td>12</td><td><strong>public String getComment()</strong> &#x2F;&#x2F;获取 cookie 的注释，如果 cookie 没有注释则返回 null。</td></tr></tbody></table><h4 id="通过-Servlet-设置-Cookie"><a href="#通过-Servlet-设置-Cookie" class="headerlink" title="通过 Servlet 设置 Cookie"></a>通过 Servlet 设置 Cookie</h4><ul><li><p>通过 Servlet 设置 Cookie 包括三个步骤</p><ul><li><strong>创建一个 Cookie 对象</strong><ul><li>可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串<ul><li><code>Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);</code></li></ul></li><li>无论是名字还是值，都不应该包含空格或以下任何字符<ul><li><code>[ ] ( ) = , &quot; / ? @ : ;</code></li></ul></li></ul></li><li><strong>设置最大生存周期</strong><ul><li>可以使用 setMaxAge 方法来指定 cookie 能够保持有效的时间（以秒为单位）</li><li>下面将设置一个最长有效期为 24 小时的 cookie<ul><li><code>cookie.setMaxAge(60*60*24);</code></li></ul></li></ul></li><li><strong>发送 Cookie 到 HTTP 响应头</strong><ul><li>可以使用 <strong>response.addCookie</strong> 来添加 HTTP 响应头中的 Cookie<ul><li><code>response.addCookie(cookie);</code></li></ul></li></ul></li></ul></li><li><p>实例</p><ul><li>修改表单数据实例，为名字和姓氏设置 Cookie</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Servlet implementation class HelloServlet</span><br><span class="line"> */</span><br><span class="line">@WebServlet(&quot;/HelloForm&quot;)</span><br><span class="line">public class HelloForm extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">       </span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#HttpServlet()</span><br><span class="line">     */</span><br><span class="line">    public HelloForm() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 为名字和姓氏创建 Cookie      </span><br><span class="line">        Cookie name = new Cookie(&quot;name&quot;,</span><br><span class="line">                URLEncoder.encode(request.getParameter(&quot;name&quot;), &quot;UTF-8&quot;)); // 中文转码</span><br><span class="line">        Cookie url = new Cookie(&quot;url&quot;,</span><br><span class="line">                      request.getParameter(&quot;url&quot;));</span><br><span class="line">        </span><br><span class="line">        // 为两个 Cookie 设置过期日期为 24 小时后</span><br><span class="line">        name.setMaxAge(60*60*24); </span><br><span class="line">        url.setMaxAge(60*60*24); </span><br><span class="line">        </span><br><span class="line">        // 在响应头中添加两个 Cookie</span><br><span class="line">        response.addCookie( name );</span><br><span class="line">        response.addCookie( url );</span><br><span class="line">        </span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        </span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;设置 Cookie 实例&quot;;</span><br><span class="line">        String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;ul&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;li&gt;&lt;b&gt;站点名：&lt;/b&gt;：&quot;</span><br><span class="line">                + request.getParameter(&quot;name&quot;) + &quot;\n&lt;/li&gt;&quot; +</span><br><span class="line">                &quot;  &lt;li&gt;&lt;b&gt;站点 URL：&lt;/b&gt;：&quot;</span><br><span class="line">                + request.getParameter(&quot;url&quot;) + &quot;\n&lt;/li&gt;&quot; +</span><br><span class="line">                &quot;&lt;/ul&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>web.xml 文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;servlet&gt; </span><br><span class="line">    &lt;!-- 类名 --&gt;  </span><br><span class="line">    &lt;servlet-name&gt;HelloForm&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 所在的包 --&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.runoob.test.HelloForm&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloForm&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 访问的网址 --&gt;</span><br><span class="line">    &lt;url-pattern&gt;/TomcatTest/HelloForm&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><ul><li>HTML 页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;/TomcatTest/HelloForm&quot; method=&quot;GET&quot;&gt;</span><br><span class="line">站点名 ：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">站点 URL：&lt;input type=&quot;text&quot; name=&quot;url&quot; /&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="通过-Servlet-读取-Cookie"><a href="#通过-Servlet-读取-Cookie" class="headerlink" title="通过 Servlet 读取 Cookie"></a>通过 Servlet 读取 Cookie</h4><ul><li>要读取 Cookie，您需要通过调用 <em>HttpServletRequest</em> 的 <strong>getCookies( )</strong> 方法创建一个 <em>javax.servlet.http.Cookie</em> 对象的数组</li><li>然后循环遍历数组，并使用 getName() 和 getValue() 方法来访问每个 cookie 和关联的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Servlet implementation class ReadCookies</span><br><span class="line"> */</span><br><span class="line">@WebServlet(&quot;/ReadCookies&quot;)</span><br><span class="line">public class ReadCookies extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">       </span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#HttpServlet()</span><br><span class="line">     */</span><br><span class="line">    public ReadCookies() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        Cookie cookie = null;</span><br><span class="line">        Cookie[] cookies = null;</span><br><span class="line">        // 获取与该域相关的 Cookie 的数组</span><br><span class="line">        cookies = request.getCookies();</span><br><span class="line">         </span><br><span class="line">         // 设置响应内容类型</span><br><span class="line">         response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">    </span><br><span class="line">         PrintWriter out = response.getWriter();</span><br><span class="line">         String title = &quot;Delete Cookie Example&quot;;</span><br><span class="line">         String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">         out.println(docType +</span><br><span class="line">                   &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                   &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">                   &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; );</span><br><span class="line">          if( cookies != null )&#123;</span><br><span class="line">            out.println(&quot;&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;&quot;);</span><br><span class="line">            for (int i = 0; i &lt; cookies.length; i++)&#123;</span><br><span class="line">               cookie = cookies[i];</span><br><span class="line">               if((cookie.getName( )).compareTo(&quot;name&quot;) == 0 )&#123;</span><br><span class="line">                    cookie.setMaxAge(0);</span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line">                    out.print(&quot;已删除的 cookie：&quot; + </span><br><span class="line">                                 cookie.getName( ) + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               out.print(&quot;名称：&quot; + cookie.getName( ) + &quot;，&quot;);</span><br><span class="line">               out.print(&quot;值：&quot; +  URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;) +&quot; &lt;br/&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             out.println(</span><br><span class="line">               &quot;&lt;h2 class=\&quot;tutheader\&quot;&gt;No Cookie founds&lt;/h2&gt;&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         out.println(&quot;&lt;/body&gt;&quot;);</span><br><span class="line">         out.println(&quot;&lt;/html&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过-Servlet-删除-Cookie"><a href="#通过-Servlet-删除-Cookie" class="headerlink" title="通过 Servlet 删除 Cookie"></a>通过 Servlet 删除 Cookie</h4><ul><li>如果您想删除一个 cookie，只需要按照以下三个步骤进行<ul><li>读取一个现有的 cookie，并把它存储在 Cookie 对象中。</li><li>使用 <strong>setMaxAge()</strong> 方法设置 cookie 的年龄为零，来删除现有的 cookie。</li><li>把这个 cookie 添加到响应头。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line"> */</span><br><span class="line">public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    Cookie cookie = null;</span><br><span class="line">    Cookie[] cookies = null;</span><br><span class="line">    // 获取与该域相关的 Cookie 的数组</span><br><span class="line">    cookies = request.getCookies();</span><br><span class="line">    </span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">    response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">   </span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    String title = &quot;删除 Cookie 实例&quot;;</span><br><span class="line">    String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">    out.println(docType +</span><br><span class="line">              &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">              &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">              &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; );</span><br><span class="line">     if( cookies != null )&#123;</span><br><span class="line">       out.println(&quot;&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;&quot;);</span><br><span class="line">       for (int i = 0; i &lt; cookies.length; i++)&#123;</span><br><span class="line">          cookie = cookies[i];</span><br><span class="line">          if((cookie.getName( )).compareTo(&quot;url&quot;) == 0 )&#123;</span><br><span class="line">               cookie.setMaxAge(0);</span><br><span class="line">               response.addCookie(cookie);</span><br><span class="line">               out.print(&quot;已删除的 cookie：&quot; + </span><br><span class="line">                            cookie.getName( ) + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          out.print(&quot;名称：&quot; + cookie.getName( ) + &quot;，&quot;);</span><br><span class="line">          out.print(&quot;值：&quot; + cookie.getValue( )+&quot; &lt;br/&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        out.println(</span><br><span class="line">          &quot;&lt;h2 class=\&quot;tutheader\&quot;&gt;No Cookie founds&lt;/h2&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(&quot;&lt;/body&gt;&quot;);</span><br><span class="line">    out.println(&quot;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet-Session-跟踪"><a href="#Servlet-Session-跟踪" class="headerlink" title="Servlet Session 跟踪"></a>Servlet Session 跟踪</h3><ul><li><p>HTTP 是一种”无状态”协议，这意味着每次客户端检索网页时，客户端打开一个单独的连接到 Web 服务器，服务器会<strong>自动不保留</strong>之前客户端请求的任何记录</p></li><li><p>但是仍然有以下三种方式来维持 Web 客户端和 Web 服务器之间的 session 会话</p><ul><li><p>Cookies</p><ul><li>一个 Web 服务器可以分配一个唯一的 session 会话 ID 作为每个 Web 客户端的 cookie，对于客户端的后续请求可以使用接收到的 cookie 来识别</li></ul></li><li><p>隐藏的表单字段</p><ul><li>一个 Web 服务器可以发送一个隐藏的 HTML 表单字段，以及一个唯一的 session 会话 ID<ul><li><code>&lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;12345&quot;&gt;</code></li><li>该条目意味着，当表单被提交时，指定的名称和值会被自动包含在 GET 或 POST 数据中。每次当 Web 浏览器发送回请求时，session_id 值可以用于保持不同的 Web 浏览器的跟踪。</li><li>这可能是一种保持 session 会话跟踪的有效方式，但是点击常规的超文本链接<code>（&lt;A HREF...&gt;）</code>不会导致表单提交，因此隐藏的表单字段也不支持常规的 session 会话跟踪。</li></ul></li></ul></li><li><p>URL 重写</p><ul><li>可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。<ul><li>例如，<code>http://w3cschool.cc/file.htm;sessionid=12345</code>，session 会话标识符被附加为 sessionid&#x3D;12345，标识符可被 Web 服务器访问以识别客户端。</li></ul></li><li>一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态 HTML 页面中也会如此。</li></ul></li></ul></li></ul><h4 id="HttpSession-对象"><a href="#HttpSession-对象" class="headerlink" title="HttpSession 对象"></a>HttpSession 对象</h4><ul><li><p>除了上述的三种方式，Servlet 还提供了 HttpSession 接口，该接口提供了一种<strong>跨多个页面请求或访问</strong>网站时识别用户以及存储有关用户信息的方式。</p></li><li><p>Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。</p></li><li><p>您会通过调用 HttpServletRequest 的公共方法 <strong>getSession()</strong> 来获取 HttpSession 对象，如下所示：</p><ul><li><code>HttpSession session = request.getSession();</code></li></ul></li><li><p>你需要在向客户端发送任何文档内容之前调用 *request.getSession()*。下面总结了 HttpSession 对象中可用的几个重要的方法</p></li></ul><table><thead><tr><th>序号</th><th>方法以及描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public Object getAttribute(String name)</strong> &#x2F;&#x2F;该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</td></tr><tr><td>2</td><td><strong>public Enumeration getAttributeNames()</strong> &#x2F;&#x2F;该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td></tr><tr><td>3</td><td><strong>public long getCreationTime()</strong> &#x2F;&#x2F;该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr><tr><td>4</td><td><strong>public String getId()</strong> &#x2F;&#x2F;该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td></tr><tr><td>5</td><td><strong>public long getLastAccessedTime()</strong> &#x2F;&#x2F;该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr><tr><td>6</td><td><strong>public int getMaxInactiveInterval()</strong> &#x2F;&#x2F;该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td></tr><tr><td>7</td><td><strong>public void invalidate()</strong> &#x2F;&#x2F;该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td></tr><tr><td>8</td><td><strong>public boolean isNew()</strong> &#x2F;&#x2F;如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td></tr><tr><td>9</td><td><strong>public void removeAttribute(String name)</strong> &#x2F;&#x2F;该方法将从该 session 会话移除指定名称的对象。</td></tr><tr><td>10</td><td><strong>public void setAttribute(String name, Object value)</strong> &#x2F;&#x2F;方法使用指定的名称绑定一个对象到该 session 会话。</td></tr><tr><td>11</td><td><strong>public void setMaxInactiveInterval(int interval)</strong> &#x2F;&#x2F;方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td></tr></tbody></table><h4 id="Session-跟踪实例"><a href="#Session-跟踪实例" class="headerlink" title="Session 跟踪实例"></a>Session 跟踪实例</h4><ul><li>本实例说明了如何使用 HttpSession 对象获取 session 会话创建时间和最后访问时间。</li><li>如果不存在 session 会话，我们将通过请求创建一个新的 session 会话。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Servlet implementation class SessionTrack</span><br><span class="line"> */</span><br><span class="line">@WebServlet(&quot;/SessionTrack&quot;)</span><br><span class="line">public class SessionTrack extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果不存在 session 会话，则创建一个 session 对象</span><br><span class="line">        HttpSession session = request.getSession(true);</span><br><span class="line">        // 获取 session 创建时间</span><br><span class="line">        Date createTime = new Date(session.getCreationTime());</span><br><span class="line">        // 获取该网页的最后一次访问时间</span><br><span class="line">        Date lastAccessTime = new Date(session.getLastAccessedTime());</span><br><span class="line">         </span><br><span class="line">        //设置日期输出的格式  </span><br><span class="line">        SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  </span><br><span class="line">    </span><br><span class="line">        String title = &quot;Servlet Session 实例 - 菜鸟教程&quot;;</span><br><span class="line">        Integer visitCount = new Integer(0);</span><br><span class="line">        String visitCountKey = new String(&quot;visitCount&quot;);</span><br><span class="line">        String userIDKey = new String(&quot;userID&quot;);</span><br><span class="line">        String userID = new String(&quot;Runoob&quot;);</span><br><span class="line">        if(session.getAttribute(visitCountKey) == null) &#123;</span><br><span class="line">            session.setAttribute(visitCountKey, new Integer(0));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        // 检查网页上是否有新的访问者</span><br><span class="line">        if (session.isNew())&#123;</span><br><span class="line">            title = &quot;Servlet Session 实例 - 菜鸟教程&quot;;</span><br><span class="line">             session.setAttribute(userIDKey, userID);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             visitCount = (Integer)session.getAttribute(visitCountKey);</span><br><span class="line">             visitCount = visitCount + 1;</span><br><span class="line">             userID = (String)session.getAttribute(userIDKey);</span><br><span class="line">        &#125;</span><br><span class="line">        session.setAttribute(visitCountKey,  visitCount);</span><br><span class="line">    </span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">    </span><br><span class="line">        String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">                 &quot;&lt;h2 align=\&quot;center\&quot;&gt;Session 信息&lt;/h2&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;table border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;th&gt;Session 信息&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;id&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; + session.getId() + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;创建时间&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; +  df.format(createTime) + </span><br><span class="line">                &quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;最后访问时间&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; + df.format(lastAccessTime) + </span><br><span class="line">                &quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;用户 ID&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; + userID + </span><br><span class="line">                &quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;访问统计：&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; + visitCount + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/table&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/body&gt;&lt;/html&gt;&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>web.xml</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;servlet&gt; </span><br><span class="line">    &lt;!-- 类名 --&gt;  </span><br><span class="line">    &lt;servlet-name&gt;SessionTrack&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 所在的包 --&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.runoob.test.SessionTrack&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;SessionTrack&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 访问的网址 --&gt;</span><br><span class="line">    &lt;url-pattern&gt;/TomcatTest/SessionTrack&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h4 id="删除-Session-会话数据"><a href="#删除-Session-会话数据" class="headerlink" title="删除 Session 会话数据"></a>删除 Session 会话数据</h4><ul><li><p>当您完成了一个用户的 session 会话数据，您有以下几种选择：</p><ul><li><p>移除一个特定的属性：您可以调用 <em>public void removeAttribute(String name)</em> 方法来删除与特定的键相关联的值。</p></li><li><p>删除整个 session 会话：您可以调用 <em>public void invalidate()</em> 方法来丢弃整个 session 会话。</p></li><li><p>设置 session 会话过期时间：您可以调用 <em>public void setMaxInactiveInterval(int interval)</em> 方法来单独设置 session 会话超时。</p></li><li><p>注销用户：如果使用的是支持 servlet 2.4 的服务器，您可以调用 <strong>logout</strong> 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。</p></li><li><p>web.xml 配置：如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">  &lt;session-timeout&gt;15&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></li><li><p>在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，以<strong>秒</strong>为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么 getMaxInactiveInterval() 会返回 900。</p></li></ul></li></ul><h3 id="Servlet-数据库访问"><a href="#Servlet-数据库访问" class="headerlink" title="Servlet 数据库访问"></a>Servlet 数据库访问</h3><ul><li>JDBC形式，不做笔记</li></ul><h3 id="Servlet-文件上传"><a href="#Servlet-文件上传" class="headerlink" title="Servlet 文件上传"></a>Servlet 文件上传</h3><ul><li>Servlet 可以与 HTML form 标签一起使用，来允许用户上传文件到服务器。上传的文件可以是文本文件或图像文件或任何文档<ul><li>表单 <strong>method</strong> 属性应该设置为 <strong>POST</strong> 方法，不能使用 GET 方法</li></ul></li></ul><h3 id="Servlet-处理日期"><a href="#Servlet-处理日期" class="headerlink" title="Servlet 处理日期"></a>Servlet 处理日期</h3><ul><li>不做笔记</li></ul><h3 id="Servlet-国家化"><a href="#Servlet-国家化" class="headerlink" title="Servlet 国家化"></a>Servlet 国家化</h3><ul><li>不做笔记</li></ul><h3 id="Servlet-自动刷新页面"><a href="#Servlet-自动刷新页面" class="headerlink" title="Servlet 自动刷新页面"></a>Servlet 自动刷新页面</h3><ul><li>Java Servlet 提供了一个机制，使得网页会在给定的时间间隔自动刷新</li><li>刷新网页的最简单的方式是使用响应对象的方法 <strong>setIntHeader()</strong>,此方法把头信息 “Refresh” 连同一个表示时间间隔的整数值（以秒为单位）发送回浏览器<ul><li><code>public void setIntHeader(String header, int headerValue)</code></li></ul></li></ul><h3 id="Servlet-网页重定向"><a href="#Servlet-网页重定向" class="headerlink" title="Servlet 网页重定向"></a>Servlet 网页重定向</h3><ul><li><p>当文档移动到新的位置，我们需要向客户端发送这个新位置时，我们需要用到网页重定向，当然，也可能是为了负载均衡，或者只是为了简单的随机，这些情况都有可能用到网页重定向。</p></li><li><p>重定向请求到另一个网页的最简单的方式是使用 response 对象的 <code>sendRedirect()</code> 方法,该方法把响应连同状态码和新的网页位置发送回浏览器,下面是该方法的定义</p><ul><li><code>public void HttpServletResponse.sendRedirect(String location) throws IOException </code></li></ul></li><li><p>也可以通过把 setStatus() 和 setHeader() 方法一起使用来达到同样的效果</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String site = &quot;http://www.xinye.com&quot; ;</span><br><span class="line">response.setStatus(response.SC_MOVED_TEMPORARILY);</span><br><span class="line">response.setHeader(&quot;Location&quot;, site); </span><br></pre></td></tr></table></figure><h3 id="Servlet-包"><a href="#Servlet-包" class="headerlink" title="Servlet 包"></a>Servlet 包</h3><ul><li>涉及到 WEB-INF 子目录的 Web 应用程序结构是所有的 Java web 应用程序的标准，并由 Servlet API 规范指定<ul><li>WEB-INF 子目录中包含应用程序的部署描述符，名为 web.xml。</li><li>所有的 HTML 文件都位于顶级目录下。对于 admin 用户，您会发现 ROOT 目录是顶级目录的父目录</li></ul></li></ul><h3 id="Servlet-调试"><a href="#Servlet-调试" class="headerlink" title="Servlet 调试"></a>Servlet 调试</h3><ul><li><p>System.out.println()</p><ul><li>是作为一个标记来使用的，用来测试一段特定的代码是否被执行，也可以打印出变量的值</li><li>由于 System 对象是核心 Java 对象的一部分，它可以在不需要安装任何额外类的情况下被用于任何地方</li><li>与在断点处停止不同，写入到 System.out 不会干扰到应用程序的正常执行流程</li><li>语法生成的所有消息将被记录在 Web 服务器日志文件中</li></ul></li><li><p>消息日志</p><ul><li>使用适当的日志记录方法来记录所有调试、警告和错误消息，这是非常好的想法，推荐使用 <a href="https://logging.apache.org/log4j/2.0/download.html">log4J</a> 来记录所有的消息</li></ul></li><li><p>使用 JDB 调试器</p></li><li><p>使用注释</p></li><li><p>客户端和服务器端头信息</p></li><li><p>重要的调试技巧</p><ul><li>请注意，server_root&#x2F;classes 不会重载，而 server_root&#x2F;servlets 可能会。</li><li>要求浏览器显示它所显示的页面的原始内容。这有助于识别格式的问题。它通常是”视图”菜单下的一个选项。</li><li>通过强制执行完全重新加载页面来确保浏览器还没有缓存前一个请求的输出。在 Netscape Navigator 中，请使用 Shift-Reload，在 Internet Explorer 中，请使用 Shift-Refresh。</li><li>请确认 servlet 的 init() 方法接受一个 ServletConfig 参数，并调用 super.init(config)。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML学习笔记</title>
      <link href="/2022/09/22/XML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/22/XML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>XML 是指可扩展标记语言:Extensible Markup Language</li><li>被设计为传输数据和存储数据</li><li>需要自行定义标签</li><li>具有自我描述型</li><li>不作为，XML 被设计用来结构化、存储以及传输信息</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>XML 把数据从 HTML 分离</li><li>XML 简化数据共享和数据传输</li><li>XML 简化平台变更</li><li>XML 使你的数据更有用</li><li>XML 用于创建新的Internet语言</li></ul><h4 id="简单的-XML-实例"><a href="#简单的-XML-实例" class="headerlink" title="简单的 XML 实例"></a>简单的 XML 实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><ul><li><p>XML 文档形成一种树结构</p><ul><li>该文档树从根部开始，并扩展到树的最低端</li></ul></li><li><p>必须包含根元素。</p><ul><li>是其他元素的父元素</li></ul></li><li><p>图例</p></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202209202251295.png" alt="image-20220918212803392"></p><h4 id="XML-语法"><a href="#XML-语法" class="headerlink" title="XML 语法"></a>XML 语法</h4><ul><li>所有元素都必须有关闭标签</li><li>对大小写敏感</li><li>正确的嵌套</li><li>必须有根元素</li><li>XML 的属性值必须加引号</li><li>实体引用<ul><li>&lt; 和 &amp; 的是不能直接引用的</li></ul></li><li>注释同 HTML 相似</li><li>空格会被保留</li><li>以 LF 存储换行</li></ul><h4 id="XML-元素"><a href="#XML-元素" class="headerlink" title="XML 元素"></a>XML 元素</h4><ul><li><p>一个元素可以包含：其他元素，文本，属性，或者混合所有</p></li><li><p>命名规则</p><ul><li>名称可以包含字母、数字以及其他的字符</li><li>名称不能以数字或者标点符号开始</li><li>名称不能以字母 xml 或者 XML，Xml 等开始</li><li>名称不能包含空格</li></ul></li><li><p>建议命名习惯</p><ul><li>简短，具有描述性，避免 - . : 等字符</li></ul></li><li><p>XML 元素是可扩展的</p></li></ul><h4 id="XML-属性"><a href="#XML-属性" class="headerlink" title="XML 属性"></a>XML 属性</h4><ul><li>Attribute 提供有关元素的额外信息，类型于 HTML</li><li>XML 属性必须加引号</li><li>尽量避免用属性，如果看起来像数据，那么请使用元素，仅仅使用属性来提高一些与数据无关的信息<ul><li>原因<ul><li>属性不能包含多个值</li><li>属性不能包含树结构</li><li>属性不易扩展</li><li>难以阅读和维护</li></ul></li></ul></li><li>针对元数据的 XML 属性<ul><li>向元素分配 ID 引用，可用标识 XML 元素，作为一个标识符</li></ul></li><li><em><strong>元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。</strong></em></li></ul><h4 id="XML-验证"><a href="#XML-验证" class="headerlink" title="XML 验证"></a>XML 验证</h4><ul><li><p>拥有正确格式的 XML 被称为“形式良好”的 XML</p></li><li><p>可通过 DTD 验证 XML 是否“合法”</p><ul><li>DTD 的目的是定义 XML 文档的结构</li></ul></li><li><p>W3C 支持替代 DTD 的替代者，为 XML Schema</p></li><li><p>XML 文档中的错误会终止您的 XML 应用程序</p><ul><li>W3C 的 XML 规范声明：如果 XML 文档存在错误，那么程序就不应当继续处理这个文档。理由是，XML 软件应当轻巧，快速，具有良好的兼容性。</li></ul></li></ul><h4 id="查看-XML-文件"><a href="#查看-XML-文件" class="headerlink" title="查看 XML 文件"></a>查看 XML 文件</h4><ul><li>在所有主流的浏览器中，均能够查看原始的 XML 文件</li><li>XML 文件不会直接显示为 HTML 页面<ul><li>原因<ul><li>XML 文档不会携带如何显示数据的信息<br>浏览器无法确定如<code>&lt;table&gt;</code>标签描述为 HTML 表格还是餐桌</li></ul></li></ul></li></ul><h4 id="显示-XML"><a href="#显示-XML" class="headerlink" title="显示 XML"></a>显示 XML</h4><ul><li>通过使用 CSS(Cascading Style Sheets 层叠样式表)，你可以添加显示信息到 XML 文档中 (不建议)</li><li>例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;cd_catalog.css&quot;?&gt;</span><br><span class="line">&lt;CATALOG&gt;</span><br><span class="line">&lt;CD&gt;</span><br><span class="line">&lt;TITLE&gt;Empire Burlesque&lt;/TITLE&gt;</span><br><span class="line">&lt;ARTIST&gt;Bob Dylan&lt;/ARTIST&gt;</span><br><span class="line">&lt;COUNTRY&gt;USA&lt;/COUNTRY&gt;</span><br><span class="line">&lt;COMPANY&gt;Columbia&lt;/COMPANY&gt;</span><br><span class="line">&lt;PRICE&gt;10.90&lt;/PRICE&gt;</span><br><span class="line">&lt;YEAR&gt;1985&lt;/YEAR&gt;</span><br><span class="line">&lt;/CD&gt;</span><br><span class="line">&lt;CD&gt;</span><br><span class="line">&lt;TITLE&gt;Hide your heart&lt;/TITLE&gt;</span><br><span class="line">&lt;ARTIST&gt;Bonnie Tyler&lt;/ARTIST&gt;</span><br><span class="line">&lt;COUNTRY&gt;UK&lt;/COUNTRY&gt;</span><br><span class="line">&lt;COMPANY&gt;CBS Records&lt;/COMPANY&gt;</span><br><span class="line">&lt;PRICE&gt;9.90&lt;/PRICE&gt;</span><br><span class="line">&lt;YEAR&gt;1988&lt;/YEAR&gt;</span><br><span class="line">&lt;/CD&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&lt;/CATALOG&gt;</span><br></pre></td></tr></table></figure><ul><li>通过 XSLT(eXtensible Stylesheet Language Transformations),把 XML 文档转化成 HTML 格式<ul><li>首选的 XML 样式表语言</li><li>功能比 CSS 更完善</li></ul></li></ul><h4 id="XML-JavaScript"><a href="#XML-JavaScript" class="headerlink" title="XML JavaScript"></a>XML JavaScript</h4><h5 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h5><ul><li>XML HttpRequest 对象用于在后台与服务器交换数据<ul><li>能不加载页面的情况下更新网页</li><li>在页面已加载后从服务器请求数据，接受数据</li><li>在后台向服务器发送数据</li></ul></li><li>创建一个 XMLHttpRequest实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建 XMLHttpRequest 对象的语法</span><br><span class="line">xmlhttp=new XMLHttpRequest();</span><br><span class="line">//旧版本的Internet Explorer（IE5和IE6）中使用 ActiveX 对象</span><br><span class="line">xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br></pre></td></tr></table></figure><h5 id="XML-Parser"><a href="#XML-Parser" class="headerlink" title="XML Parser"></a>XML Parser</h5><ul><li>XML 解析器把 XML 文档转换为 XML DOM对象，可以通过 JavaScript 操作的对象<ul><li>Internet Explorer 使用 <code>loadXML()</code>方法解析 XML 字符串，其他浏览器用 <code>DOMParser</code></li></ul></li><li>解析 XML 例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (window.XMLHttpRequest)</span><br><span class="line">&#123;// code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">xmlhttp=new XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;// code for IE6, IE5</span><br><span class="line">xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;books.xml&quot;,false);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlDoc=xmlhttp.responseXML;</span><br></pre></td></tr></table></figure><ul><li>解析 XML 字符串例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">txt=&quot;&lt;bookstore&gt;&lt;book&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;title&gt;Everyday Italian&lt;/title&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;year&gt;2005&lt;/year&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;/book&gt;&lt;/bookstore&gt;&quot;;</span><br><span class="line"></span><br><span class="line">if (window.DOMParser)</span><br><span class="line">&#123;</span><br><span class="line">parser=new DOMParser();</span><br><span class="line">xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else // Internet Explorer</span><br><span class="line">&#123;</span><br><span class="line">xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);</span><br><span class="line">xmlDoc.async=false;</span><br><span class="line">xmlDoc.loadXML(txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="XML-DOM"><a href="#XML-DOM" class="headerlink" title="XML DOM"></a>XML DOM</h5><ul><li><p>DOM(Document Object Model 文档对象模型)定义了访问和操作文档的标注方法</p></li><li><p>把 XML 文档作为树结构来查看</p></li><li><p>所有元素都可以通过 DOM 树来访问。</p><ul><li>可以修改，删除，创建</li></ul></li><li><p>元素，文本，属性都被认为是节点</p></li><li><p>加载一个 XML 文件 例子</p><ul><li>请注意，即使 XML 文件只包含一个 <to> 元素，您仍然必须指定数组索引 [0]。这是因为 <code>getElementsByTagName()</code> 方法返回一个数组。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//该实例把 XML 文档（&quot;note.xml&quot;）解析到 XML DOM 对象中，然后通过 JavaScript 提取一些信息</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">if (window.XMLHttpRequest)</span><br><span class="line">&#123;// code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">xmlhttp=new XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;// code for IE6, IE5</span><br><span class="line">xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;note.xml&quot;,false);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlDoc=xmlhttp.responseXML;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;to&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;to&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById(&quot;from&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;from&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById(&quot;message&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;body&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>加载一个 XML 字符串 - 跨浏览器实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">txt=&quot;&lt;note&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;to&gt;Tove&lt;/to&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;from&gt;Jani&lt;/from&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;heading&gt;Reminder&lt;/heading&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;/note&gt;&quot;;</span><br><span class="line"></span><br><span class="line">if (window.DOMParser)</span><br><span class="line">&#123;</span><br><span class="line">parser=new DOMParser();</span><br><span class="line">xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else // Internet Explorer</span><br><span class="line">&#123;</span><br><span class="line">xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);</span><br><span class="line">xmlDoc.async=false;</span><br><span class="line">xmlDoc.loadXML(txt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;to&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;to&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById(&quot;from&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;from&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById(&quot;message&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;body&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="XML-进阶"><a href="#XML-进阶" class="headerlink" title="XML 进阶"></a>XML 进阶</h4><h5 id="XML-命名空间"><a href="#XML-命名空间" class="headerlink" title="XML 命名空间"></a>XML 命名空间</h5><ul><li>提供避免元素命名冲突的方法<ul><li>使用前缀来避免命名冲突</li></ul></li><li>通过开始标签的 xmlns 属性中定义 用于前缀的命名空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">语法：xmlns:前缀=&quot;URI&quot;</span><br><span class="line"></span><br><span class="line">//例子1</span><br><span class="line">//&lt;table&gt; 标签的 xmlns 属性定义了 h: 和 f: 前缀的合格命名空间。</span><br><span class="line">//当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。</span><br><span class="line"></span><br><span class="line">命名空间，可以在他们被使用的元素中或者在 XML 根元素中声明：</span><br><span class="line">&lt;root&gt;</span><br><span class="line"></span><br><span class="line">&lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt;</span><br><span class="line">&lt;h:tr&gt;</span><br><span class="line">&lt;h:td&gt;Apples&lt;/h:td&gt;</span><br><span class="line">&lt;h:td&gt;Bananas&lt;/h:td&gt;</span><br><span class="line">&lt;/h:tr&gt;</span><br><span class="line">&lt;/h:table&gt;</span><br><span class="line"></span><br><span class="line">&lt;f:table xmlns:f=&quot;http://www.w3cschool.cc/furniture&quot;&gt;</span><br><span class="line">&lt;f:name&gt;African Coffee Table&lt;/f:name&gt;</span><br><span class="line">&lt;f:width&gt;80&lt;/f:width&gt;</span><br><span class="line">&lt;f:length&gt;120&lt;/f:length&gt;</span><br><span class="line">&lt;/f:table&gt;</span><br><span class="line"></span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//例子2</span><br><span class="line">&lt;root xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;</span><br><span class="line">xmlns:f=&quot;http://www.w3cschool.cc/furniture&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;h:table&gt;</span><br><span class="line">&lt;h:tr&gt;</span><br><span class="line">&lt;h:td&gt;Apples&lt;/h:td&gt;</span><br><span class="line">&lt;h:td&gt;Bananas&lt;/h:td&gt;</span><br><span class="line">&lt;/h:tr&gt;</span><br><span class="line">&lt;/h:table&gt;</span><br><span class="line"></span><br><span class="line">&lt;f:table&gt;</span><br><span class="line">&lt;f:name&gt;African Coffee Table&lt;/f:name&gt;</span><br><span class="line">&lt;f:width&gt;80&lt;/f:width&gt;</span><br><span class="line">&lt;f:length&gt;120&lt;/f:length&gt;</span><br><span class="line">&lt;/f:table&gt;</span><br><span class="line"></span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p> 注释：命名空间URI不会被解析器用于查找信息，其目的是赋予命名空间一个惟一的名称</p><ul><li>为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。它的语法如下</li><li><code>xmlns=&quot;*namespaceURI*&quot;</code></li></ul><h6 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h6><ul><li>统一资源标识符（URI，全称 Uniform Resource Identifier）</li><li>用于标识因特网资源的字符</li><li>常用的 URI 是是用来标识因特网地址的统一资源定位器(URL),另一个少用的URI是统一资源命名(URN)</li></ul><h5 id="CDATA-和-PCDATA"><a href="#CDATA-和-PCDATA" class="headerlink" title="CDATA 和 PCDATA"></a>CDATA 和 PCDATA</h5><ul><li><p>XML 文档中的所有文本均会被解析器解析</p></li><li><p>被解析的字符数据(PCDATA)</p><ul><li>XML 解析器通常会解析 XML 文档中所有的文本。</li><li>解析字符数据（PCDATA）是 XML 解析器解析的文本数据使用的一个术语</li></ul></li><li><p>未解析的字符数据(CDATA)</p><ul><li><p>只有 CDATA 区段中的文本会被解析器忽略</p></li><li><p>术语 CDATA 是不应该由 XML 解析器解析的文本数据</p></li><li><p>像 “&lt;” 和 “&amp;” 字符在 XML 元素中都是非法的</p><ul><li><p>“&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始</p></li><li><p>“&amp;” 会产生错误，因为解析器会把该字符解释为字符实体的开始</p></li></ul></li><li><p>某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA</p></li><li><p>语法 ：”<strong><code>&lt;![CDATA[</code></strong>“ 开始，由 “<strong><code>]]&gt;</code></strong>“ 结束</p></li></ul></li></ul><h5 id="XML-编码"><a href="#XML-编码" class="headerlink" title="XML 编码"></a>XML 编码</h5><ul><li>XML 文档可以包含非 ASCII 字符，比如挪威语 æ ø å，或者法语 ê è é</li><li>为了避免错误，需要规定 XML 编码，或者将 XML 文件存为 <code>Unicode</code></li><li>始终使用编码属性</li><li>使用支持编码的编辑器</li><li>确保您知道编辑器使用什么编码</li><li>在您的编码属性中使用相同的编码</li></ul><h5 id="服务器上的-XML"><a href="#服务器上的-XML" class="headerlink" title="服务器上的 XML"></a>服务器上的 XML</h5><ul><li>XML 文件是类似 HTML 文件的纯文本文件</li><li>XML 能够通过标准的 Web 服务器轻松地存储和生成<ul><li>Internet 服务器上进行存储的方式与 HTML 文件完全相同</li></ul></li></ul><h5 id="XML-注意事项"><a href="#XML-注意事项" class="headerlink" title="XML 注意事项"></a>XML 注意事项</h5><ul><li><p>使用 XML 时应该尽量避免使用的技术</p><ul><li><p>Internet Explorer - XML 数据岛</p></li><li><p>Internet Explorer - 行为</p></li></ul></li></ul><h5 id="XML-相关技术"><a href="#XML-相关技术" class="headerlink" title="XML 相关技术"></a>XML 相关技术</h5><ul><li><p>XHTML (可扩展 HTML)</p><ul><li>更纯净的基于 XML 的 HTML 版本</li></ul></li><li><p>XML DOM (XML 文档对象模型)</p><ul><li>访问和操作 XML 的标准文档模型</li></ul></li><li><p><a href="https://www.runoob.com/xsl/xsl-tutorial.html">XSL (可扩展样式表语言)</a> XSL 包含三个部分</p><ul><li><a href="https://www.runoob.com/xsl/xsl-tutorial.html">XSLT</a> (XSL 转换) - 把 XML 转换为其他格式，比如 HTML</li><li><a href="https://www.runoob.com/xslfo/xslfo-tutorial.html">XSL-FO</a> (XSL 格式化对象)- 用于格式化 XML 文档的语言</li><li><a href="https://www.runoob.com/xpath/xpath-tutorial.html">XPath</a> - 用于导航 XML 文档的语言</li></ul></li><li><p>DTD (文档类型定义)</p><ul><li>用于定义 XML 文档中的合法元素的标准</li></ul></li><li><p>XSD (XML 架构)</p><ul><li>基于 XML 的 DTD 替代物。</li></ul></li><li><p>XQuery(XML查询语言)</p><ul><li>基于 XML 的用于查询 XML 数据的语言</li></ul></li></ul><h4 id="XML-总结"><a href="#XML-总结" class="headerlink" title="XML 总结"></a>XML 总结</h4><ul><li>XML 可用于交换、共享和存储数据</li><li>XML 文档形成树状结构，在”根”和”叶子”的分支机构开始的</li><li>XML 有非常简单的语法规则。带有正确语法的 XML 是”形式良好”的。有效的 XML 是针对 DTD 进行验证的</li><li>XSLT用于把 XML 转换为其他格式，比如 HTML</li><li>所有现代的浏览器有一个内建的 XML 解析器，可读取和操作 XML</li><li>DOM(Document Object Model）定义了一个访问 XML 的标准方式</li><li>XMLHttpRequest 对象提供了一个网页加载后与服务器进行通信的方式</li><li>XML 命名空间提供了一种避免元素命名冲突的方法</li><li>CDATA 区域内的文本会被解析器忽略</li></ul>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit笔记(一)</title>
      <link href="/2022/09/13/Junit%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2022/09/13/Junit%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Junit简述"><a href="#Junit简述" class="headerlink" title="Junit简述"></a>Junit简述</h3><ul><li>junit是用于java单元测试工具，是一个单元测试框架，适用于白盒测试，也适用于回归测试<ul><li>白合测试: 程序的内部逻辑结构和其他信息对测试人员是公开的</li><li>回归测试: 对软件或者环境修复更正后的“再测试”</li><li>单元测试: 最小的测试模块，</li></ul></li><li>特性<ul><li>用于测试期望结果的断言</li><li>用于共享测试数据的测试工具</li><li>方便组织和运行的测试套件</li><li>图形和文本的测试运行器</li></ul></li></ul><h3 id="编写测试用例步骤"><a href="#编写测试用例步骤" class="headerlink" title="编写测试用例步骤"></a>编写测试用例步骤</h3><ul><li>创建被测对象</li><li>调用被测试方法，输入参数</li><li>判断预期结果是否和真实值一样</li></ul><h3 id="Junit语法"><a href="#Junit语法" class="headerlink" title="Junit语法"></a>Junit语法</h3><h4 id="junit3"><a href="#junit3" class="headerlink" title="junit3"></a>junit3</h4><ul><li>测试类都要继承TestCase</li><li>测试方法都要以test开头</li><li>测试三步骤进行测试</li><li>void setUp()方法每次执行测试方法都先执行一次、<ul><li>可以用来实例化对象</li></ul></li><li>void teardown()方法每次测试方法停止测试的时候都执行一次</li></ul><h4 id="Junit4"><a href="#Junit4" class="headerlink" title="Junit4"></a>Junit4</h4><ul><li><p>@Test</p><ul><li>每个测试方法要被标注，同时必须用public void进行修饰，且不能携带参数</li></ul></li><li><p>@Before</p><ul><li>同setup()一个作用</li></ul></li><li><p>@After</p><ul><li>同teardown()一个作用</li></ul></li><li><p>@BeforeClass</p><ul><li>被标记的方法必须为static，每次类初始化执行一次</li></ul></li><li><p>@AfterClass</p><ul><li>被标记的方法必须为static,每次类停止前执行一次</li></ul></li><li><p>ingore</p><ul><li>忽略被标记的方法</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Juint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记(一)</title>
      <link href="/2022/09/13/Git%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2022/09/13/Git%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h3 id="git是什么"><a href="#git是什么" class="headerlink" title="git是什么"></a>git是什么</h3><ul><li>一个开源的分布式版本的控制系统，用于处理项目</li><li>分布式版本库的方式</li><li>不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</li></ul><h4 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h4><ul><li>git config<ul><li>专门用来配置或者读取相应的工作环境变量的工具</li></ul></li><li>查看所有的git配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><ul><li>用户配置<ul><li>配置用户名和邮箱</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;XXX&quot;</span><br><span class="line">git config --global user.email &quot;XXX&quot;</span><br></pre></td></tr></table></figure><ul><li>设置文本编辑器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor XXX</span><br></pre></td></tr></table></figure><p>略</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li>克隆git资源作为工作目录</li><li>添加或者修改文件</li><li>如果其他人修改了，你可以更新资源</li><li>在提交前查看修改</li><li>提交修改</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交</li></ul><p>流程图</p><ul><li><img src="https://cdn.jsdelivr.net/gh/xinyemoon/Image//article_img/image-20220913150753435.png" alt="image-20220913150753435"></li></ul><h4 id="Git的工作区，暂存区和版本库"><a href="#Git的工作区，暂存区和版本库" class="headerlink" title="Git的工作区，暂存区和版本库"></a>Git的工作区，暂存区和版本库</h4><ul><li>工作区：我们电脑上能看见的目录</li><li>暂缓区：.&#x2F;git目录下index文件(.git&#x2F;index)中，也称索引</li><li>版本库：工作区的隐藏目录.git</li></ul><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><ul><li>创建仓库<ul><li>生成.git目录，存放gi需求的数据和资源</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init &quot;XXX&quot;</span><br></pre></td></tr></table></figure><ul><li>从git库拷贝项目<ul><li>repository: git仓库</li><li>directory: 本地目录</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repository&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比</p></li><li><p>基本六个命令：git clone、git push、git add、git commit、git checkout、git pull</p></li><li><p>流程图：</p><p><img src="https://cdn.jsdelivr.net/gh/xinyemoon/Image//article_img/image-20220913152424189.png" alt="image-20220913152424189"></p></li><li><p>创建：上面已演示</p></li><li><p>修改和提交</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add //增加文件到缓存区</span><br><span class="line">git status //查看仓看状态</span><br><span class="line">git diff //比较缓存区和工作区文件的不同</span><br><span class="line">git commit //提交到本地仓库</span><br><span class="line">git reset //回退版本</span><br><span class="line">git rm //删除暂存区和工作区的文件</span><br><span class="line">git mv //移动或者重命名工作区文件</span><br></pre></td></tr></table></figure><ul><li>提交日志</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log //查看历史提交记录</span><br><span class="line">git blame &lt;file&gt; //指定查看文件记录</span><br></pre></td></tr></table></figure><ul><li>远程命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote //远程仓库操作</span><br><span class="line">git fetch //获取代码库(不能自动merge)</span><br><span class="line">git merge //获取代码库后整合到当前分支</span><br><span class="line">git push //上传远程代码并合并</span><br><span class="line">git pull //下载远程代码并合并</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建一个博客</title>
      <link href="/2022/09/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/09/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="本篇文章搭建博客使用的是hexo博客框架，是基于Node-js安装的，同时，本文对发布部署内容都使用git，需要读者自行安装Node和git"><a href="#本篇文章搭建博客使用的是hexo博客框架，是基于Node-js安装的，同时，本文对发布部署内容都使用git，需要读者自行安装Node和git" class="headerlink" title="本篇文章搭建博客使用的是hexo博客框架，是基于Node.js安装的，同时，本文对发布部署内容都使用git，需要读者自行安装Node和git."></a>本篇文章搭建博客使用的是hexo博客框架，是基于Node.js安装的，同时，本文对发布部署内容都使用git，需要读者自行安装Node和git.</h4><h4 id="hexo框架有许多博客主题，本文使用的是Butterfly"><a href="#hexo框架有许多博客主题，本文使用的是Butterfly" class="headerlink" title="hexo框架有许多博客主题，本文使用的是Butterfly"></a>hexo框架有许多博客主题，本文使用的是Butterfly</h4><h4 id="版本：hexo-6-3-0-butterfly-4-4-0"><a href="#版本：hexo-6-3-0-butterfly-4-4-0" class="headerlink" title="版本：hexo:6.3.0; butterfly:4.4.0"></a>版本：hexo:6.3.0; butterfly:4.4.0</h4><h3 id="初步流程"><a href="#初步流程" class="headerlink" title="初步流程"></a>初步流程</h3><ul><li>安装hexo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure><ul><li>创建存放目录，建议放非系统盘<ul><li>完成后该目录下会有_config.yml等文件</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &quot;XXX&quot;  </span><br></pre></td></tr></table></figure><ul><li>生成静态html文件<ul><li>该命令是把博客.md等文件生成.html等格式，让用户得以访问</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><ul><li>本地部署</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><strong>执行完上述命令后，读者可以自行访问git bush界面出现的本地地址，默认是localhost:4000</strong></p><p>其他命令</p><ul><li>清楚静态文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><ul><li>生成.md文件<ul><li>读者也可以自行建立，但需要在文件头部加上必要的“标签”，是hexo对文章进行分类的表示，具体请看hexo官方文档</li><li>官方文档地址：<a href="https://hexo.io/zh-cn/index.html">Hexo</a></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;XXX&quot;</span><br></pre></td></tr></table></figure><p>好了，如果但是这样，不够美观，所以我选择用Butterfly主题来美化，读者也可以自行到hexo官方或者github等地找合适的主题安装，不过建议选择主题文档详细和常更新的，方便后续的改造。</p><h4 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h4><ul><li>安装butterfly</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly //版本为4.4.0</span><br></pre></td></tr></table></figure><ul><li>安装pug以及stylus的渲染器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><ul><li>在根目录下的_config.yml文件修改</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>到此在运行hexo clean,hexo g,hexo s就可以看到本地浏览下的界面更改了</p><h4 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h4><ul><li>根目录下的_config.yml为站点配置文件_,_&#x2F;根目录&#x2F;theme&#x2F;Butterfly&#x2F;_config.yml为主题配置文件，对于界面修改都是基于两个文件进行的</li><li>每次写新的博客内容或者新建删除，都要执行 <em>hexo cl,hexo g,hexo s</em>的步骤，后面部署到服务器后把hexo s改为hexo d 即可。</li></ul><h4 id="Github-Page部署"><a href="#Github-Page部署" class="headerlink" title="Github Page部署"></a>Github Page部署</h4><ul><li><p>需要一个github账号，注册流程不多赘述</p></li><li><p>安装扩展，辅助部署</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><ul><li>新建一个repostiory，命名为&lt;你的账号&gt;.github.io,这是为了我们的站点能通过域名访问</li><li>获取你本地git的密钥，辅助到github,进行连接，不多赘述</li><li>验证是否成功，出现你的github账号名代表连接成功</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><ul><li>然后执行hexo cl &amp;&amp; hexo g &amp;&amp; hexo d上传远程仓库</li><li>你就能在&lt;你的账号名&gt;.github.io访问你的站点啦！</li></ul><p><strong>简单的流程到此结束，接下来是阿里云配置</strong></p><h4 id="阿里云域名"><a href="#阿里云域名" class="headerlink" title="阿里云域名"></a>阿里云域名</h4><ul><li><p>在后面，我们不想用尾缀github.io的进行访问，那用其他com,cn等域名行不行?回答是可以的，而且不用域名备案。</p></li><li><p>注册一个阿里云账号，根据需求购买域名，但要注意一下续费收款，有些头年很低，但续费非常高</p><ul><li>阿里云：地址<a href="https://www.aliyun.com/?spm=5176.authc-home.top-nav.dlogo.63834babwfioQc">阿里云-为了无法计算的价值 (aliyun.com)</a></li></ul></li><li><p>注册完成后还要进行身份验证等步骤，具体过程不赘述</p></li><li><p>完成上述步骤后，在域名管理，点击你的域名，在行条上的右手边有解析域名</p></li><li><p>新手直接点新手引导就行，输入你的github那个博客的ip，ip获取可以在git中输入</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;你的名字&gt;@github.io</span><br></pre></td></tr></table></figure><ul><li>完成后在你的github点击你博客repository的settings，注意不是你个人的头像那里的settings</li><li>找到Page的domins，输入你的阿里云域名并保存，建议勾选下方的https，增加安全性。</li><li>然后在你的repository下建立一个CNAME文件，写入你的阿里云域名，在到你的本地博客的根目录下的source建议同名的文件填上相同的域名，这样做的目的是github会在你更新内容重新写绑定的域名，稳定解析连接</li></ul><h4 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h4><p>你可能发现我并没有对主题页面配置有过多的描述，这是因为在hexo官方文档和Butterfly主题文档都有详细的说明，具体请自己去查看。</p><ul><li><a href="https://hexo.io/zh-cn/index.html">Hexo</a></li><li><a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2022/09/11/test/"/>
      <url>/2022/09/11/test/</url>
      
        <content type="html"><![CDATA[<h3 id="1-图片测试"><a href="#1-图片测试" class="headerlink" title="1.图片测试"></a>1.图片测试</h3><ul><li><img src="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209202246670.png"><br>2.调试评论区是否能正常运行,测试cover能否正常运行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
