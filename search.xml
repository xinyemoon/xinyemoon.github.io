<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DTD</title>
      <link href="/2022/09/25/DTD/"/>
      <url>/2022/09/25/DTD/</url>
      
        <content type="html"><![CDATA[<h4 id="DTD-简介"><a href="#DTD-简介" class="headerlink" title="DTD 简介"></a>DTD 简介</h4><ul><li>DTD(文档类型定义)的作用是定义 XML 文档的合法构建模块</li><li>可以被声明于 XML 的文档中，也可作为一个外部引用</li><li>为什么使用的 DTD<ul><li>使得每个 XML 文件均可携带一个有关自身格式的描述</li><li>方便团队配合，用定义的 DTD 的的标准 来交换数据</li><li>也可以验证外部或自己的数据</li></ul></li></ul><h4 id="DTD-使用"><a href="#DTD-使用" class="headerlink" title="DTD 使用"></a>DTD 使用</h4><ul><li><p>内部的 DOCTYPE 声明</p><ul><li><code>&lt;!DOCTYPE root-element [element-declarations]&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*!DOCTYPE note (第十行)定义此文档是 note 类型的文档。</span><br><span class="line">*!ELEMENT note (第十一行)定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;</span><br><span class="line">*!ELEMENT to (第十二行)定义 to 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line">*!ELEMENT from (第十三行)定义 from 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line">*!ELEMENT heading (第十四行)定义 heading 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line">*!ELEMENT body (第十五行)定义 body 元素为 &quot;#PCDATA&quot; 类型</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部的文档声明</p><ul><li><code>&lt;DOCTYPE root-element SYSTEM &quot;filename&quot;</code></li></ul></li></ul><h4 id="DTD-XML-d构建模块"><a href="#DTD-XML-d构建模块" class="headerlink" title="DTD -XML d构建模块"></a>DTD -XML d构建模块</h4><ul><li><p>XML 和 HTML 文档的主要的构建模块是元素标签</p></li><li><p>均有一下简单的构建模块构成</p><ul><li><p>元素</p><ul><li>XML 和 HTML 文档的主要构建模块</li></ul></li><li><p>属性</p><ul><li><p>可提供有关元素的额外信息</p></li><li><p>总是以名称&#x2F;值的形式成对出现</p></li></ul></li><li><p>实体</p><ul><li>用来定义普通文本的变量。实体引用是对实体的引用</li><li>如 &amp;lt 被 XML 解析器解析成 字符 &lt;</li></ul></li><li><p>PCDATA</p><ul><li>是会被解析器解析的文本。这些文本将被解析器检查实体以及标记</li></ul></li><li><p>CDATA</p><ul><li>不会被解析器解析的文本</li></ul></li></ul></li></ul><h4 id="DTD-元素"><a href="#DTD-元素" class="headerlink" title="DTD -元素"></a>DTD -元素</h4><ul><li><p>在 DTD 中，元素通过元素声明来进行声明</p></li><li><p>语法</p><ul><li><p>声明一个元素</p><ul><li><code>&lt;!ELEMENT element-name category&gt;</code> 或者 <code>&lt;!ELEMENT element-name(element-content)</code></li></ul></li><li><p>空元素</p><ul><li><code>&lt;!ELEMENT element-name EMPTY&gt;</code></li></ul></li><li><p>只有 PCDATA 的元素</p><ul><li><code>&lt;!ELEMENT elemet-name(#PCDATA)&gt;</code></li></ul></li><li><p>带有任何内容的元素</p><ul><li><code>&lt;!ELEMENT element-name ANY&gt;</code></li></ul></li><li><p>带有子元素（序列）的元素，带有一个或多个子元素的元素通过圆括号中的子元素名进行声明</p><ul><li><code>&lt;!ELEMENT element-name (child1)&gt;</code> 或 <code>&lt;!ELEMENT element-name (child1,child2,...)&gt;</code></li></ul></li><li><p>声明只出现一次的异常</p><ul><li><code>&lt;!ELEMENT element-name (child-name)&gt;</code></li></ul></li><li><p>声明最少出现一次的元素</p><ul><li><code>&lt;!ELEMENT element-name (child-name+)&gt;</code></li></ul></li><li><p>声明出现零次或多次的元素</p><ul><li><code>&lt;!ELEMENT element-name (child-name*)&gt;</code></li></ul></li><li><p>声明出现零次或一次的元素</p><ul><li><code>&lt;!ELEMENT element-name (child-name?)&gt;</code></li></ul></li><li><p>声明”非…&#x2F;即…”类型的内容</p><ul><li><code>&lt;!ELEMENT note (to,from,header,(message|body))&gt;</code></li></ul></li><li><p>声明混合型的内容</p><ul><li>例子声明了：”note” 元素可包含出现零次或多次的 PCDATA、”to”、”from”、”header” 或者 “message”</li><li><code>&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</code></li></ul></li></ul></li></ul><h4 id="DTD-属性"><a href="#DTD-属性" class="headerlink" title="DTD -属性"></a>DTD -属性</h4><ul><li><p>在 DTD 中，属性通过 ATTLIST 声明来进行声明</p></li><li><p>语法</p><ul><li><code>&lt;!ATTLTST element-name attribute-name attribute-type attribute-value</code></li></ul></li><li><p>属性类型的选项</p></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>CDATA</td><td>值为字符数据 (character data)</td></tr><tr><td>(<em>en1</em>|<em>en2</em>|..)</td><td>此值是枚举列表中的一个值</td></tr><tr><td>ID</td><td>值为唯一的 id</td></tr><tr><td>IDREF</td><td>值为另外一个元素的 id</td></tr><tr><td>IDREFS</td><td>值为其他 id 的列表</td></tr><tr><td>NMTOKEN</td><td>值为合法的 XML 名称</td></tr><tr><td>NMTOKENS</td><td>值为合法的 XML 名称的列表</td></tr><tr><td>ENTITY</td><td>值是一个实体</td></tr><tr><td>ENTITIES</td><td>值是一个实体列表</td></tr><tr><td>NOTATION</td><td>此值是符号的名称</td></tr><tr><td>xml:</td><td>值是一个预定义的 XML 值</td></tr></tbody></table><ul><li><strong>属性值</strong>选项</li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>#REQUIRED</td><td>属性值是必需的</td></tr><tr><td>#IMPLIED</td><td>属性不是必需的</td></tr><tr><td>#FIXED value</td><td>属性值是固定的</td></tr></tbody></table><ul><li><p>#REQUIRED</p><ul><li><code>&lt;!ATTLIST element-name attribute-name attribute-type #REQUIRED&gt;</code></li></ul></li><li><p>#IMPLIED</p><ul><li><code>&lt;!ATTLIST element-name attribute-name attribute-type #IMPLIED&gt;</code></li></ul></li><li><p>FIXED</p><ul><li><code>&lt;!ATTLIST element-name attribute-name attribute-type #FIXED &quot;value&quot;&gt;</code></li></ul></li><li><p>列举属性值</p><ul><li>属性值为一系列固定的合法值之一，请使用列举属性值</li><li><code>&lt;!ATTLIST element-name attribute-name (en1|en2|..) default-value&gt;</code></li></ul></li></ul><h4 id="DTD-实体"><a href="#DTD-实体" class="headerlink" title="DTD -实体"></a>DTD -实体</h4><ul><li><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量</p><ul><li>实体引用是对实体的引用</li><li>实体可在内部或外部进行声明</li></ul></li><li><p>一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)</p></li><li></li><li><p>一个内部实体声明</p><ul><li><code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DTD 实例:</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML 实例：</span><br><span class="line"></span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><ul><li>一个外部实体声明<ul><li><code>&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DTD 实例:</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML example:</span><br><span class="line"></span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h4 id="DTD-验证"><a href="#DTD-验证" class="headerlink" title="DTD 验证"></a>DTD 验证</h4><ul><li>可根据某个 DTD 来验证您的 XML</li></ul><h4 id="DTD-总结"><a href="#DTD-总结" class="headerlink" title="DTD 总结"></a>DTD 总结</h4><ul><li>如何描述 XML 文档的结构。</li><li>如何使用 DTD 来定义一个 XML 文档的合法元素，以及如何在 XML 内部或者作为一个外部引用来声明 DTD</li><li>学习了如何为 XML 文档声明合法的元素、属性、实体以及 CDATA 部分。</li><li>了如何根据某个 DTD 来验证一个 XML 文档</li></ul>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> XML </tag>
            
            <tag> DTD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="/2022/09/25/Servlet/"/>
      <url>/2022/09/25/Servlet/</url>
      
        <content type="html"><![CDATA[<h3 id="Servlet-简介"><a href="#Servlet-简介" class="headerlink" title="Servlet 简介"></a>Servlet 简介</h3><ul><li>Java Servlet 是运行在 <strong>Web 服务器</strong>或<strong>应用服务器</strong>上的程序</li><li>它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层</li><li>使用 Servlet，可以收集来自网页<strong>表单</strong>的用户输入，<strong>呈现</strong>来自<strong>数据库</strong>或者其他源的记录，还可以<strong>动态</strong>创建网页</li><li>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，有以下几点优点<ul><li>性能好</li><li>Servlet 在 Web服务器地址空间执行。没必要再创建一个单独的进程来处理每个客户端的请求</li><li>独立于平台</li><li>更安全</li><li>Java 类库的全部功能对 Servlet 都是可用的<ul><li>通过 <strong>sockets</strong> 和 <strong>RMI(<strong>Remote Method Invocation</strong>)</strong> 机制与 applets、数据库或其他软件进行交互</li></ul></li></ul></li></ul><h3 id="Servlet-框架图"><a href="#Servlet-框架图" class="headerlink" title="Servlet 框架图"></a>Servlet 框架图</h3><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202209241337018.png" alt="image-20220924133725981"></p><h3 id="Servlet-任务"><a href="#Servlet-任务" class="headerlink" title="Servlet 任务"></a>Servlet 任务</h3><ul><li>读取客户端(浏览器)发送的显示的数据<ul><li>这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单</li></ul></li><li>读取客户端(浏览器)发送的隐式 HTTP 请求数据<ul><li>这包括 cookies、媒体类型和浏览器能理解的压缩格式等等</li></ul></li><li>处理数据并生成结果<ul><li>这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应</li></ul></li><li>发送显示的数据(文档)到客户端(浏览器)<ul><li>该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等</li></ul></li><li>发送隐式的 HTTP 响应到客户端(浏览器)<ul><li>这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务</li></ul></li></ul><h3 id="Servlet-包及其创建"><a href="#Servlet-包及其创建" class="headerlink" title="Servlet 包及其创建"></a>Servlet 包及其创建</h3><ul><li><p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类</p></li><li><p>Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 Java 企业版的标准组成部分</p></li><li><p>Servlet 创建的三种方式</p><ul><li><p><strong>实现 Servlet 接口</strong></p></li><li><p><strong>继承 GenericServlet 类</strong></p></li><li><p><strong>继承 HttpServlet 方法</strong></p><ul><li>重写 doPost() 和 doGet() 方法</li><li>经常用的方法</li></ul></li></ul></li></ul><p>注释(三者之间的关系)：对于一个 Servlet 类，我们日常最常用的方法是继承自 HttpServlet 类，提供了 Http 相关的方法，HttpServlet 扩展了 GenericServlet 类，而 GenericServlet 类又实现了 Servlet 类和 ServletConfig 类</p><h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><p>被定义从创建知道毁灭的整个过程</p><ul><li>Servlet 初始化后调用 init() 方法<ul><li>被设置只被调用一次，在第一次创建 Servlet 是被调用</li><li>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void init() throws ServletException &#123;</span><br><span class="line">  // 初始化代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Servlet 调用 service() 方法来处理用户端的请求</p><ul><li><p>是执行认为的主要方法</p></li><li><p>Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端</p></li><li><p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void service(ServletRequest request, </span><br><span class="line">                    ServletResponse response) </span><br><span class="line">      throws ServletException, IOException&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doGet() 方法<ul><li>GET 请求来自于一个 URL 的正常请求，或者来自于一个<em><strong>未指定</strong></em> METHOD 的 HTML 表单，它由 doGet() 方法处理</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void doGet(HttpServletRequest request,</span><br><span class="line">                  HttpServletResponse response)</span><br><span class="line">    throws ServletException, IOException &#123;</span><br><span class="line">    // Servlet 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doPost() 方法<ul><li>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void doPost(HttpServletRequest request,</span><br><span class="line">                   HttpServletResponse response)</span><br><span class="line">    throws ServletException, IOException &#123;</span><br><span class="line">    // Servlet 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Servlet 销毁前调用 destroy() 方法<ul><li>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void destroy() &#123;</span><br><span class="line">  // 终止化代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>最后由 JVM(java虚拟机) 的垃圾回收器进行垃圾回收</p></li><li><p>框架图</p><ul><li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器</li><li>Servlet 容器在调用 service() 方法之前加载 Servlet</li><li>然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 servlet() 方法</li><li><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202209241414588.png" alt="image-20220924141427525"></li></ul></li></ul><h3 id="Servlet-实例"><a href="#Servlet-实例" class="headerlink" title="Servlet 实例"></a>Servlet 实例</h3><ul><li>Servlet 是服务 HTTP 请求并实现 javax.servlet.Servlet 接口的 Java 类。</li><li>Web开发人员通常编写 Servlet 来扩展 javax.serlet.http.HTTPServlet 接口的抽象类专门用来处理 HTTP 请求</li><li>示例</li></ul><h3 id="Servlet-表单数据"><a href="#Servlet-表单数据" class="headerlink" title="Servlet 表单数据"></a>Servlet 表单数据</h3><ul><li>浏览器将信息传递到 Web 服务器的两种方法</li></ul><h4 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h4><ul><li>GET 方法向页面请求发送已编码的用户信息</li><li>页面和已编码的信息中间用？字符分割<ul><li>例如<code>http://www.xinye.com/hi?key1=value1&amp;key2=value2</code></li></ul></li><li>GET方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏里。<ul><li>如果传递的是密码和其他敏感信息，请不要使用 GET 方法</li><li>请求字符串最多只能有 1024 个字符串</li><li>通过 QUERY_STRING 头传递和访问</li></ul></li><li>Servlet 使用 doGet()方法处理这类型的请求</li></ul><h4 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h4><ul><li>POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不上把信息作为 URL 中？字符后的文本进行发送，而是把这些信息作为一个单独的信息。</li><li>消息以标准输出的形式传到后台程序，可以进行解析和使用这些标准输出</li><li>Servlet 使用 doPost()方法来处理这种类型的请求</li></ul><h4 id="使用-Servlet-读取表单的数据"><a href="#使用-Servlet-读取表单的数据" class="headerlink" title="使用 Servlet 读取表单的数据"></a>使用 Servlet 读取表单的数据</h4><ul><li>Servlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析<ul><li><code>getParameter()</code><ul><li>调用<code>request.getParameter()</code>的方法来获取表单参数的值</li></ul></li><li><code>getParameterValues()</code><ul><li>如果参数出现一次以上，则会调用该方法，并返回多个值，例如复选框</li></ul></li><li><code>getParameterNames()</code><ul><li>如果你想要得到当前请求中的所有参数的完成列表，则调用该方法</li></ul></li></ul></li></ul><p>注释：<code>request.getParameter(String name)</code> 是获取相应名的数据，如果有重复的名，则返回第一个值，接受一般变量，如 text 类型;</p><p><code>request.getParameterValues(String name)</code>是获取如 checkbox类(名字相同，但值有多个)的数据，接受数组变量，如checkbox类型</p><h3 id="Servlet-客户端-HTTP-请求"><a href="#Servlet-客户端-HTTP-请求" class="headerlink" title="Servlet 客户端 HTTP 请求"></a>Servlet 客户端 HTTP 请求</h3><ul><li>当浏览器请求网页时，他会向 Web 服务器发送特定信息，这些信息不能被直接读取，因为这些信息时作为 HTTP 请求的头的一部分进行传输的。</li></ul><h4 id="读取-HTTP-头的方法"><a href="#读取-HTTP-头的方法" class="headerlink" title="读取 HTTP 头的方法"></a>读取 HTTP 头的方法</h4><ul><li>可以在Servlet 程序中读取 HTTP 头，这些方法通过 HTTPServletRequest对象可用</li></ul><table><thead><tr><th>序号</th><th>方法及其描述</th></tr></thead><tbody><tr><td>1</td><td><strong>Cookie[] getCookies()</strong> &#x2F;&#x2F;返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</td></tr><tr><td>2</td><td><strong>Enumeration getAttributeNames()</strong> &#x2F;&#x2F;返回一个枚举，包含提供给该请求可用的属性名称。</td></tr><tr><td>3</td><td><strong>Enumeration getHeaderNames()</strong> &#x2F;&#x2F;返回一个枚举，包含在该请求中包含的所有的头名。</td></tr><tr><td>4</td><td><strong>Enumeration getParameterNames()</strong> &#x2F;&#x2F;返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。</td></tr><tr><td>5</td><td><strong>HttpSession getSession()</strong> &#x2F;&#x2F;返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。</td></tr><tr><td>6</td><td><strong>HttpSession getSession(boolean create)</strong> &#x2F;&#x2F;返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。</td></tr><tr><td>7</td><td><strong>Locale getLocale()</strong> &#x2F;&#x2F;基于 Accept-Language 头，返回客户端接受内容的首选的区域设置。</td></tr><tr><td>8</td><td><strong>Object getAttribute(String name)</strong> &#x2F;&#x2F;以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。</td></tr><tr><td>9</td><td><strong>ServletInputStream getInputStream()</strong> &#x2F;&#x2F;使用 ServletInputStream，以二进制数据形式检索请求的主体。</td></tr><tr><td>10</td><td><strong>String getAuthType()</strong> &#x2F;&#x2F;返回用于保护 Servlet 的身份验证方案的名称，例如，”BASIC” 或 “SSL”，如果JSP没有受到保护则返回 null。</td></tr><tr><td>11</td><td><strong>String getCharacterEncoding()</strong> &#x2F;&#x2F;返回请求主体中使用的字符编码的名称。</td></tr><tr><td>12</td><td><strong>String getContentType()</strong>&#x2F;&#x2F;返回请求主体的 MIME 类型，如果不知道类型则返回 null。</td></tr><tr><td>13</td><td><strong>String getContextPath()</strong> &#x2F;&#x2F;返回指示请求上下文的请求 URI 部分。</td></tr><tr><td>14</td><td><strong>String getHeader(String name)</strong> &#x2F;&#x2F;以字符串形式返回指定的请求头的值。</td></tr><tr><td>15</td><td><strong>String getMethod()</strong> &#x2F;&#x2F;返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</td></tr><tr><td>16</td><td><strong>String getParameter(String name)</strong> &#x2F;&#x2F;以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</td></tr><tr><td>17</td><td><strong>String getPathInfo()</strong> &#x2F;&#x2F;请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。</td></tr><tr><td>18</td><td><strong>String getProtocol()</strong> &#x2F;&#x2F;返回请求协议的名称和版本。</td></tr><tr><td>19</td><td><strong>String getQueryString()</strong> &#x2F;&#x2F;返回包含在路径后的请求 URL 中的查询字符串。</td></tr><tr><td>20</td><td><strong>String getRemoteAddr()</strong> &#x2F;&#x2F;返回发送请求的客户端的互联网协议（IP）地址。</td></tr><tr><td>21</td><td><strong>String getRemoteHost()</strong> &#x2F;&#x2F;返回发送请求的客户端的完全限定名称。</td></tr><tr><td>22</td><td><strong>String getRemoteUser()</strong> &#x2F;&#x2F;如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。</td></tr><tr><td>23</td><td><strong>String getRequestURI()</strong> &#x2F;&#x2F;从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。</td></tr><tr><td>24</td><td><strong>String getRequestedSessionId()</strong> &#x2F;&#x2F;返回由客户端指定的 session 会话 ID。</td></tr><tr><td>25</td><td><strong>String getServletPath()</strong> &#x2F;&#x2F;返回调用 JSP 的请求的 URL 的一部分。</td></tr><tr><td>26</td><td><strong>String[] getParameterValues(String name)</strong> &#x2F;&#x2F;返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。</td></tr><tr><td>27</td><td><strong>boolean isSecure()</strong> &#x2F;&#x2F;返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。</td></tr><tr><td>28</td><td><strong>int getContentLength()</strong> &#x2F;&#x2F;以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。</td></tr><tr><td>29</td><td><strong>int getIntHeader(String name)</strong> &#x2F;&#x2F;返回指定的请求头的值为一个 int 值。</td></tr><tr><td>30</td><td><strong>int getServerPort()</strong> &#x2F;&#x2F;返回接收到这个请求的端口号。</td></tr><tr><td>31</td><td><strong>int getParameterMap()</strong> &#x2F;&#x2F;将参数封装成 Map 类型。</td></tr></tbody></table><ul><li>HTTP Header 请求实例<ul><li>实例使用 HttpServletRequest 的 <strong>getHeaderNames()</strong> 方法读取 HTTP 头信息。该方法返回一个枚举，包含与当前的 HTTP 请求相关的头信息</li><li>一旦我们有一个枚举，我们可以以标准方式循环枚举，使用 <em>hasMoreElements()</em> 方法来确定何时停止，使用 <em>nextElement()</em> 方法来获取每个参数的名称</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//导入必需的 java 库</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/DisplayHeader&quot;)</span><br><span class="line"></span><br><span class="line">//扩展 HttpServlet 类</span><br><span class="line">public class DisplayHeader extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    // 处理 GET 方法请求的方法</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;HTTP Header 请求实例&quot;;</span><br><span class="line">        String docType =</span><br><span class="line">            &quot;&lt;!DOCTYPE html&gt; \n&quot;;</span><br><span class="line">            out.println(docType +</span><br><span class="line">            &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;table width=\&quot;100%\&quot; border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;th&gt;Header 名称&lt;/th&gt;&lt;th&gt;Header 值&lt;/th&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;/tr&gt;\n&quot;);</span><br><span class="line"></span><br><span class="line">        Enumeration headerNames = request.getHeaderNames();</span><br><span class="line"></span><br><span class="line">        while(headerNames.hasMoreElements()) &#123;</span><br><span class="line">            String paramName = (String)headerNames.nextElement();</span><br><span class="line">            out.print(&quot;&lt;tr&gt;&lt;td&gt;&quot; + paramName + &quot;&lt;/td&gt;\n&quot;);</span><br><span class="line">            String paramValue = request.getHeader(paramName);</span><br><span class="line">            out.println(&quot;&lt;td&gt; &quot; + paramValue + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(&quot;&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理 POST 方法请求的方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//对于的web.xml配置</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app&gt;  </span><br><span class="line">  &lt;servlet&gt;  </span><br><span class="line">    &lt;!-- 类名 --&gt;  </span><br><span class="line">    &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;!-- 所在的包 --&gt;  </span><br><span class="line">    &lt;servlet-class&gt;com.runoob.test.DisplayHeader&lt;/servlet-class&gt;  </span><br><span class="line">  &lt;/servlet&gt;  </span><br><span class="line">  &lt;servlet-mapping&gt;  </span><br><span class="line">    &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;!-- 访问的网址 --&gt;  </span><br><span class="line">    &lt;url-pattern&gt;/TomcatTest/DisplayHeader&lt;/url-pattern&gt;  </span><br><span class="line">  &lt;/servlet-mapping&gt;  </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h3 id="Servlet-服务器-HTTP-响应"><a href="#Servlet-服务器-HTTP-响应" class="headerlink" title="Servlet 服务器 HTTP 响应"></a>Servlet 服务器 HTTP 响应</h3><ul><li>当一个 Web 服务器响应一个 HTTP 请求时，响应通常包括一个状态行、一些响应报头、一个空行和文档</li></ul><h4 id="设置-HTTP-响应报头的方法"><a href="#设置-HTTP-响应报头的方法" class="headerlink" title="设置 HTTP 响应报头的方法"></a>设置 HTTP 响应报头的方法</h4><ul><li>下面的方法可用于在 Servlet 程序中设置 HTTP 响应报头</li><li>这些方法通过 <em>HttpServletResponse</em> 对象可用</li></ul><table><thead><tr><th>序号</th><th>方法以及描述</th></tr></thead><tbody><tr><td>1</td><td><strong>String encodeRedirectURL(String url)</strong> &#x2F;&#x2F;为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td></tr><tr><td>2</td><td><strong>String encodeURL(String url)</strong> &#x2F;&#x2F;对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td></tr><tr><td>3</td><td><strong>boolean containsHeader(String name)</strong> &#x2F;&#x2F;返回一个布尔值，指示是否已经设置已命名的响应报头。</td></tr><tr><td>4</td><td><strong>boolean isCommitted()</strong> &#x2F;&#x2F;返回一个布尔值，指示响应是否已经提交。</td></tr><tr><td>5</td><td><strong>void addCookie(Cookie cookie)</strong> &#x2F;&#x2F;把指定的 cookie 添加到响应。</td></tr><tr><td>6</td><td><strong>void addDateHeader(String name, long date)</strong> &#x2F;&#x2F;添加一个带有给定的名称和日期值的响应报头。</td></tr><tr><td>7</td><td><strong>void addHeader(String name, String value)</strong> &#x2F;&#x2F;添加一个带有给定的名称和值的响应报头。</td></tr><tr><td>8</td><td><strong>void addIntHeader(String name, int value)</strong> &#x2F;&#x2F;添加一个带有给定的名称和整数值的响应报头。</td></tr><tr><td>9</td><td><strong>void flushBuffer()</strong> &#x2F;&#x2F;强制任何在缓冲区中的内容被写入到客户端。</td></tr><tr><td>10</td><td><strong>void reset()</strong> &#x2F;&#x2F;清除缓冲区中存在的任何数据，包括状态码和头。</td></tr><tr><td>11</td><td><strong>void resetBuffer()</strong> &#x2F;&#x2F;清除响应中基础缓冲区的内容，不清除状态码和头。</td></tr><tr><td>12</td><td><strong>void sendError(int sc)</strong> &#x2F;&#x2F;使用指定的状态码发送错误响应到客户端，并清除缓冲区。</td></tr><tr><td>13</td><td><strong>void sendError(int sc, String msg)</strong> &#x2F;&#x2F;使用指定的状态发送错误响应到客户端。</td></tr><tr><td>14</td><td><strong>void sendRedirect(String location)</strong> &#x2F;&#x2F;使用指定的重定向位置 URL 发送临时重定向响应到客户端。</td></tr><tr><td>15</td><td><strong>void setBufferSize(int size)</strong> &#x2F;&#x2F;为响应主体设置首选的缓冲区大小。</td></tr><tr><td>16</td><td><strong>void setCharacterEncoding(String charset)</strong> &#x2F;&#x2F;设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。</td></tr><tr><td>17</td><td><strong>void setContentLength(int len)</strong> &#x2F;&#x2F;设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头。</td></tr><tr><td>18</td><td><strong>void setContentType(String type)</strong> &#x2F;&#x2F;如果响应还未被提交，设置被发送到客户端的响应的内容类型。</td></tr><tr><td>19</td><td><strong>void setDateHeader(String name, long date)</strong> &#x2F;&#x2F;设置一个带有给定的名称和日期值的响应报头。</td></tr><tr><td>20</td><td><strong>void setHeader(String name, String value)</strong> &#x2F;&#x2F;设置一个带有给定的名称和值的响应报头。</td></tr><tr><td>21</td><td><strong>void setIntHeader(String name, int value)</strong> &#x2F;&#x2F;设置一个带有给定的名称和整数值的响应报头。</td></tr><tr><td>22</td><td><strong>void setLocale(Locale loc)</strong> &#x2F;&#x2F;如果响应还未被提交，设置响应的区域。</td></tr><tr><td>23</td><td><strong>void setStatus(int sc)</strong> &#x2F;&#x2F;为该响应设置状态码。</td></tr></tbody></table><ul><li>HTTP Header 响应实例<ul><li>前面的实例中看到 setContentType() 方法，下面的实例也使用了同样的方法，此外，我们会用 <strong>setIntHeader()</strong> 方法来设置 <strong>Refresh</strong> 头</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//导入必需的 java 库</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/Refresh&quot;)</span><br><span class="line"></span><br><span class="line">//扩展 HttpServlet 类</span><br><span class="line">public class Refresh extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    // 处理 GET 方法请求的方法</span><br><span class="line">      public void doGet(HttpServletRequest request,</span><br><span class="line">                        HttpServletResponse response)</span><br><span class="line">                throws ServletException, IOException</span><br><span class="line">      &#123;</span><br><span class="line">          // 设置刷新自动加载时间为 5 秒</span><br><span class="line">          response.setIntHeader(&quot;Refresh&quot;, 5);</span><br><span class="line">          // 设置响应内容类型</span><br><span class="line">          response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">         </span><br><span class="line">          //使用默认时区和语言环境获得一个日历  </span><br><span class="line">          Calendar cale = Calendar.getInstance();  </span><br><span class="line">          //将Calendar类型转换成Date类型  </span><br><span class="line">          Date tasktime=cale.getTime();  </span><br><span class="line">          //设置日期输出的格式  </span><br><span class="line">          SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  </span><br><span class="line">          //格式化输出  </span><br><span class="line">          String nowTime = df.format(tasktime);</span><br><span class="line">          PrintWriter out = response.getWriter();</span><br><span class="line">          String title = &quot;自动刷新 Header 设置 ;</span><br><span class="line">          String docType =</span><br><span class="line">          &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">          out.println(docType +</span><br><span class="line">            &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;p&gt;当前时间是：&quot; + nowTime + &quot;&lt;/p&gt;\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 处理 POST 方法请求的方法</span><br><span class="line">      public void doPost(HttpServletRequest request,</span><br><span class="line">                         HttpServletResponse response)</span><br><span class="line">          throws ServletException, IOException &#123;</span><br><span class="line">         doGet(request, response);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//对应的 web.xml 配置</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app&gt;  </span><br><span class="line">  &lt;servlet&gt;  </span><br><span class="line">     &lt;!-- 类名 --&gt;  </span><br><span class="line">    &lt;servlet-name&gt;Refresh&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;!-- 所在的包 --&gt;  </span><br><span class="line">    &lt;servlet-class&gt;com.runoob.test.Refresh&lt;/servlet-class&gt;  </span><br><span class="line">  &lt;/servlet&gt;  </span><br><span class="line">  &lt;servlet-mapping&gt;  </span><br><span class="line">    &lt;servlet-name&gt;Refresh&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;!-- 访问的网址 --&gt;  </span><br><span class="line">    &lt;url-pattern&gt;/TomcatTest/Refresh&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/servlet-mapping&gt;  </span><br><span class="line">&lt;/web-app&gt; </span><br></pre></td></tr></table></figure><h3 id="Servlet-HTTP-状态码"><a href="#Servlet-HTTP-状态码" class="headerlink" title="Servlet HTTP 状态码"></a>Servlet HTTP 状态码</h3><ul><li><p>HTTP 请求和 HTTP 响应消息的格式是类似的</p><ul><li>初始状态行 + 回车换行符（回车+换行）</li><li>零个或多个标题行+回车换行符</li><li>一个空白行，即回车换行符</li><li>一个可选的消息主体，比如文件、查询数据或查询输出</li></ul></li><li><p>例如访问出错后显示的数据，就有状态码</p></li><li><p>服务器的响应头例子</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Header2: ...</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">  (Blank Line)</span><br><span class="line">&lt;!doctype ...&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;...&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="Servlet-编写过滤器"><a href="#Servlet-编写过滤器" class="headerlink" title="Servlet 编写过滤器"></a>Servlet 编写过滤器</h3><ul><li><p>Servlet 过滤器可以<strong>动态地拦截请求和响应</strong>，以变换或使用包含在请求或响应中的信息</p></li><li><p>可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet</p></li><li><p>过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前调用所有附加的 Servlet 过滤器</p></li><li><p>Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的</p><ul><li>在客户端的请求访问后端资源之前，拦截这些请求</li><li>在服务器的响应发送回客户端之前，处理这些响应</li></ul></li><li><p>过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式</p><ul><li>当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例</li><li>Filter的执行顺序与在web.xml配置文件中的配置顺序一致，<strong>一般把Filter配置在所有的Servlet之前</strong></li></ul></li></ul><h4 id="Servlet-过滤器方法"><a href="#Servlet-过滤器方法" class="headerlink" title="Servlet 过滤器方法"></a>Servlet 过滤器方法</h4><ul><li>过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类<ul><li>javax.servlet.Filter 接口定义了三个方法</li></ul></li></ul><table><thead><tr><th>序号</th><th>方法及其描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public void doFilter (ServletRequest, ServletResponse, FilterChain)</strong> &#x2F;&#x2F;该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。</td></tr><tr><td>2</td><td><strong>public void init(FilterConfig filterConfig)</strong> &#x2F;&#x2F;web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</td></tr><tr><td>3</td><td><strong>public void destroy()</strong> &#x2F;&#x2F;Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。</td></tr></tbody></table><h4 id="Servlet-过滤器实例"><a href="#Servlet-过滤器实例" class="headerlink" title="Servlet 过滤器实例"></a>Servlet 过滤器实例</h4><ul><li>Servlet 过滤器的实例，将输出网站名称和地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.runoob.test;</span><br><span class="line"></span><br><span class="line">//导入必需的 java 库</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">//实现 Filter 类</span><br><span class="line">public class LogFilter implements Filter  &#123;</span><br><span class="line">    public void  init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">        // 获取初始化参数</span><br><span class="line">        String site = config.getInitParameter(&quot;Site&quot;); </span><br><span class="line"></span><br><span class="line">        // 输出初始化参数</span><br><span class="line">        System.out.println(&quot;网站名称: &quot; + site); </span><br><span class="line">    &#125;</span><br><span class="line">    public void  doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        // 输出站点名称</span><br><span class="line">        System.out.println(&quot;站点网址：http://www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">        // 把请求传回过滤链</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">    public void destroy( )&#123;</span><br><span class="line">        /* 在 Filter 实例被 Web 容器从服务移除之前调用 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>DisplayHeader例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.runoob.test;</span><br><span class="line"></span><br><span class="line">//导入必需的 java 库</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">//实现 Filter 类</span><br><span class="line">public class LogFilter implements Filter  &#123;</span><br><span class="line">    public void  init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">        // 获取初始化参数</span><br><span class="line">        String site = config.getInitParameter(&quot;Site&quot;); </span><br><span class="line"></span><br><span class="line">        // 输出初始化参数</span><br><span class="line">        System.out.println(&quot;网站名称: &quot; + site); </span><br><span class="line">    &#125;</span><br><span class="line">    public void  doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        // 输出站点名称</span><br><span class="line">        System.out.println(&quot;站点网址：http://www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">        // 把请求传回过滤链</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">    public void destroy( )&#123;</span><br><span class="line">        /* 在 Filter 实例被 Web 容器从服务移除之前调用 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这边使用前文提到的 DisplayHeader.java 为例子：</span><br><span class="line"></span><br><span class="line">//导入必需的 java 库</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/DisplayHeader&quot;)</span><br><span class="line"></span><br><span class="line">//扩展 HttpServlet 类</span><br><span class="line">public class DisplayHeader extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    // 处理 GET 方法请求的方法</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;HTTP Header 请求实例 - 菜鸟教程实例&quot;;</span><br><span class="line">        String docType =</span><br><span class="line">            &quot;&lt;!DOCTYPE html&gt; \n&quot;;</span><br><span class="line">            out.println(docType +</span><br><span class="line">            &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;table width=\&quot;100%\&quot; border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;th&gt;Header 名称&lt;/th&gt;&lt;th&gt;Header 值&lt;/th&gt;\n&quot;+</span><br><span class="line">            &quot;&lt;/tr&gt;\n&quot;);</span><br><span class="line"></span><br><span class="line">        Enumeration headerNames = request.getHeaderNames();</span><br><span class="line"></span><br><span class="line">        while(headerNames.hasMoreElements()) &#123;</span><br><span class="line">            String paramName = (String)headerNames.nextElement();</span><br><span class="line">            out.print(&quot;&lt;tr&gt;&lt;td&gt;&quot; + paramName + &quot;&lt;/td&gt;\n&quot;);</span><br><span class="line">            String paramValue = request.getHeader(paramName);</span><br><span class="line">            out.println(&quot;&lt;td&gt; &quot; + paramValue + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(&quot;&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理 POST 方法请求的方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Web.xml 中的 Servlet 过滤器映射（Servlet Filter Mapping）<ul><li>定义过滤器，然后映射到一个 URL 或 Servlet，这与定义 Servlet，然后映射到一个 URL 模式方式大致相同</li><li>部署描述符文件 <strong>web.xml</strong> 中为 filter 标签创建下面的条目：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app&gt;  </span><br><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.runoob.test.LogFilter&lt;/filter-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;Site&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;菜鸟教程&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">  &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt; //过滤器适用于所有的 Servlet，因为我们在配置中指定 /* </span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line">&lt;servlet&gt;  </span><br><span class="line">  &lt;!-- 类名 --&gt;  </span><br><span class="line">  &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;  </span><br><span class="line">  &lt;!-- 所在的包 --&gt;  </span><br><span class="line">  &lt;servlet-class&gt;com.runoob.test.DisplayHeader&lt;/servlet-class&gt;  </span><br><span class="line">&lt;/servlet&gt;  </span><br><span class="line">&lt;servlet-mapping&gt;  </span><br><span class="line">  &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;  </span><br><span class="line">  &lt;!-- 访问的网址 --&gt;  </span><br><span class="line">  &lt;url-pattern&gt;/TomcatTest/DisplayHeader&lt;/url-pattern&gt;  </span><br><span class="line">&lt;/servlet-mapping&gt;  </span><br><span class="line">&lt;/web-app&gt; </span><br></pre></td></tr></table></figure><h4 id="使用多个过滤器"><a href="#使用多个过滤器" class="headerlink" title="使用多个过滤器"></a>使用多个过滤器</h4><ul><li>Web 应用程序可以根据特定的目的定义若干个不同的过滤器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;com.runoob.test.LogFilter&lt;/filter-class&gt;</span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;test-param&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt; //初始化参数</span><br><span class="line">   &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;com.runoob.test.AuthenFilter&lt;/filter-class&gt;</span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;test-param&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt;</span><br><span class="line">   &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><h4 id="过滤器的应用顺序"><a href="#过滤器的应用顺序" class="headerlink" title="过滤器的应用顺序"></a>过滤器的应用顺序</h4><ul><li>web.xml 中的 filter-mapping 元素的顺序决定了 Web 容器应用过滤器到 Servlet 的顺序</li></ul><h4 id="web-xml-配置各个节点说明"><a href="#web-xml-配置各个节点说明" class="headerlink" title="web.xml 配置各个节点说明"></a>web.xml 配置各个节点说明</h4><ul><li><p><code>&lt;filter&gt;</code></p><p>指定一个过滤器</p><ul><li><code>&lt;filter-name&gt;</code>用于为过滤器指定一个名字，该元素的内容不能为空。</li><li><code>&lt;filter-class&gt;</code>元素用于指定过滤器的完整的限定类名。</li><li><code>&lt;init-param&gt;</code>元素用于为过滤器指定初始化参数，它的子元素<code>&lt;param-name&gt;</code>指定参数的名字，<code>&lt;param-value&gt;</code>指定参数的值。</li><li>在过滤器中，可以使用<code>FilterConfig</code>接口对象来访问初始化参数。</li></ul></li><li><p><code>&lt;filter-mapping&gt;</code></p><p>元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径</p><ul><li><code>&lt;filter-name&gt;</code>子元素用于设置filter的注册名称。该值必须是在<code>&lt;filter&gt;</code>元素中声明过的过滤器的名字</li><li><code>&lt;url-pattern&gt;</code>设置 filter 所拦截的请求路径(过滤器关联的URL样式)</li></ul></li><li><p><code>&lt;servlet-name&gt;</code>指定过滤器所拦截的Servlet名称。</p></li><li><p><code>&lt;dispatcher&gt;</code>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是<code>REQUEST</code>,<code>INCLUDE</code>,<code>FORWARD</code>和<code>ERROR</code>之一，默认<code>REQUEST</code>。用户可以设置多个<code>&lt;dispatcher&gt;</code>子元素用来指定 Filter 对资源的多种调用方式进行拦截。</p></li><li><p><code>&lt;dispatcher&gt;</code></p><p>子元素可以设置的值及其意义</p><ul><li><code>REQUEST</code>：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li><li><code>INCLUDE</code>：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li><li><code>FORWARD</code>：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li><li><code>ERROR</code>：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li></ul></li></ul><h4 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h4><ul><li>过滤器中我们可以根据 doFilter() 方法中的 request 对象获取表单参数信息，例如我们可以获取到请求的用户名和密码进行逻辑处理，也可以通过 response 对用户做出回应。</li><li>比如如果验证用户名不正确，禁止用户访问 web 资源，并且向浏览器输出提示，告诉用户用户名或者密码不正确等等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest req, ServletResponse resp,</span><br><span class="line">FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    //获取请求信息(测试时可以通过get方式在URL中添加name)</span><br><span class="line">    //http://localhost:8080/servlet_demo/helloword?name=123</span><br><span class="line">    String name = req.getParameter(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">    // 过滤器核心代码逻辑</span><br><span class="line">    System.out.println(&quot;过滤器获取请求参数:&quot;+name);</span><br><span class="line">    System.out.println(&quot;第二个过滤器执行--网站名称：www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">    if(&quot;123&quot;.equals(name))&#123;</span><br><span class="line">        // 把请求传回过滤链</span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //设置返回内容类型</span><br><span class="line">        resp.setContentType(&quot;text/html;charset=GBK&quot;);</span><br><span class="line"></span><br><span class="line">        //在页面输出响应信息</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.print(&quot;&lt;b&gt;name不正确，请求被拦截，不能访问web资源&lt;/b&gt;&quot;);</span><br><span class="line">        System.out.println(&quot;name不正确，请求被拦截，不能访问web资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet-异常处理"><a href="#Servlet-异常处理" class="headerlink" title="Servlet 异常处理"></a>Servlet 异常处理</h3><ul><li><p>当一个 Servlet 抛出一个异常时，Web 容器在使用了 exception-type 元素的 <strong>web.xml</strong> 中搜索与抛出异常类型相匹配的配置。</p></li><li><p>您必须在 web.xml 中使用 <strong>error-page</strong> 元素来指定对特定<strong>异常</strong> 或 HTTP <strong>状态码</strong> 作出相应的 Servlet 调用。</p></li><li><p>例子</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- servlet 定义 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;ErrorHandler&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;ErrorHandler&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;!-- servlet 映射 --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;ErrorHandler&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/ErrorHandler&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- error-code 相关的错误页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;error-code&gt;404&lt;/error-code&gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;error-code&gt;403&lt;/error-code&gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- exception-type 相关的错误页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;</span><br><span class="line">          javax.servlet.ServletException</span><br><span class="line">    &lt;/exception-type &gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;java.io.IOException&lt;/exception-type &gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果您想对所有的异常有一个通用的错误处理程序，那么应该定义下面的 error-page，而不是为每个异常定义单独的 error-page 元素</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type &gt;</span><br><span class="line">    &lt;location&gt;/ErrorHandler&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br></pre></td></tr></table></figure><ul><li>关于上面的 web.xml 异常处理要注意的点<ul><li>Servlet ErrorHandler 与其他的 Servlet 的定义方式一样，且在 web.xml 中进行配置。</li><li>如果有错误状态代码出现，不管为 404（Not Found 未找到）或 403（Forbidden 禁止），则会调用 ErrorHandler 的 Servlet。</li><li>如果 Web 应用程序抛出 <em>ServletException</em> 或 <em>IOException</em>，那么 Web 容器会调用 ErrorHandler 的 Servlet。</li><li>您可以定义不同的错误处理程序来处理不同类型的错误或异常。上面的实例是非常通用的，希望您能通过实例理解基本的概念。</li></ul></li></ul><h4 id="请求属性-错误-x2F-异常"><a href="#请求属性-错误-x2F-异常" class="headerlink" title="请求属性 - 错误&#x2F;异常"></a>请求属性 - 错误&#x2F;异常</h4><ul><li>用来分析错误&#x2F;异常的性质</li></ul><table><thead><tr><th>序号</th><th>属性以及描述</th></tr></thead><tbody><tr><td>1</td><td><strong>javax.servlet.error.status_code</strong> &#x2F;&#x2F;该属性给出状态码，状态码可被存储，并在存储为 java.lang.Integer 数据类型后可被分析。</td></tr><tr><td>2</td><td><strong>javax.servlet.error.exception_type</strong> &#x2F;&#x2F;属性给出异常类型的信息，异常类型可被存储，并在存储为 java.lang.Class 数据类型后可被分析。</td></tr><tr><td>3</td><td><strong>javax.servlet.error.message</strong> &#x2F;&#x2F;该属性给出确切错误消息的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr><tr><td>4</td><td><strong>javax.servlet.error.request_uri</strong> &#x2F;&#x2F;该属性给出有关 URL 调用 Servlet 的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr><tr><td>5</td><td><strong>javax.servlet.error.exception</strong> &#x2F;&#x2F;属性给出异常产生的信息，信息可被存储，并在存储为 java.lang.Throwable 数据类型后可被分析。</td></tr><tr><td>6</td><td><strong>javax.servlet.error.servlet_name</strong> &#x2F;&#x2F;属性给出 Servlet 的名称，名称可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr></tbody></table><h3 id="Servlet-Cookie-处理"><a href="#Servlet-Cookie-处理" class="headerlink" title="Servlet Cookie 处理"></a>Servlet Cookie 处理</h3><ul><li><p>Cookie 是存储在<strong>客户端</strong>计算机上的<strong>文本文件</strong>，并保留了各种<strong>跟踪信息</strong>。</p></li><li><p>Java Servlet 支持 HTTP Cookie。</p></li><li><p>识别返回用户包括三个步骤</p><ul><li><p>服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等</p></li><li><p>浏览器将这些信息存储在本地计算机上，以备将来使用</p></li><li><p>当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户</p></li></ul></li><li><p><em>Servlet Cookie 处理需要对中文进行编码与解码</em></p><ul><li>编码<ul><li><code>String   str   =   java.net.URLEncoder.encode(&quot;中文&quot;，&quot;UTF-8&quot;);</code></li></ul></li><li>解码<ul><li><code>String   str   =   java.net.URLDecoder.decode(&quot;编码后的字符串&quot;,&quot;UTF-8&quot;);   </code></li></ul></li></ul></li></ul><h4 id="Cookie-解析"><a href="#Cookie-解析" class="headerlink" title="Cookie 解析"></a>Cookie 解析</h4><ul><li>Cookie 通常设置在 HTTP 头信息中（ JavaScript 也可以直接在浏览器上设置一个 Cookie）。</li><li>设置 Cookie 的 Servlet 会发送如下的头信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 04 Feb 2000 21:03:38 GMT</span><br><span class="line">Server: Apache/1.3.9 (UNIX) PHP/4.0b3</span><br><span class="line">Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; </span><br><span class="line">                 path=/; domain=runoob.com</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure><ul><li>Set-Cookie 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码</li><li><code>expires</code> 字段是一个指令，告诉浏览器在给定的时间和日期之后”忘记”该 Cookie。如果浏览器被配置为存储 Cookie，它将会保留此信息直到到期日期</li><li>如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器</li><li>浏览器的头信息可能如下所示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">User-Agent: Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)</span><br><span class="line">Host: zink.demon.co.uk:1126</span><br><span class="line">Accept: image/gif, */*</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Language: en</span><br><span class="line">Accept-Charset: iso-8859-1,*,utf-8</span><br><span class="line">Cookie: name=xyz</span><br></pre></td></tr></table></figure><ul><li>Servlet 就能够通过请求方法<code>request.getCookies() </code>访问 Cookie，该方法将返回一个 <em>Cookie</em> 对象的数组</li></ul><h4 id="Servlet-Cookie-方法"><a href="#Servlet-Cookie-方法" class="headerlink" title="Servlet Cookie 方法"></a>Servlet Cookie 方法</h4><ul><li>在 Servlet 中操作 Cookie 时可使用的有用的方法列表</li></ul><table><thead><tr><th>序号</th><th>方法及其描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public void setDomain(String pattern)</strong> &#x2F;&#x2F;该方法设置 cookie 适用的域，例如 runoob.com。</td></tr><tr><td>2</td><td><strong>public String getDomain()</strong> &#x2F;&#x2F;方法获取 cookie 适用的域，例如 runoob.com。</td></tr><tr><td>3</td><td><strong>public void setMaxAge(int expiry)</strong> &#x2F;&#x2F;该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td></tr><tr><td>4</td><td><strong>public int getMaxAge()</strong> 该方法返回 &#x2F;&#x2F;cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td></tr><tr><td>5</td><td><strong>public String getName()</strong> &#x2F;&#x2F;该方法返回 cookie 的名称。名称在创建后不能改变。</td></tr><tr><td>6</td><td><strong>public void setValue(String newValue)</strong> &#x2F;&#x2F;该方法设置与 cookie 关联的值。</td></tr><tr><td>7</td><td><strong>public String getValue()</strong> &#x2F;&#x2F;方法获取与 cookie 关联的值。</td></tr><tr><td>8</td><td><strong>public void setPath(String uri)</strong> &#x2F;&#x2F;该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td></tr><tr><td>9</td><td><strong>public String getPath()</strong> &#x2F;&#x2F;该方法获取 cookie 适用的路径。</td></tr><tr><td>10</td><td><strong>public void setSecure(boolean flag)</strong> &#x2F;&#x2F;该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。</td></tr><tr><td>11</td><td><strong>public void setComment(String purpose)</strong> &#x2F;&#x2F;设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td></tr><tr><td>12</td><td><strong>public String getComment()</strong> &#x2F;&#x2F;获取 cookie 的注释，如果 cookie 没有注释则返回 null。</td></tr></tbody></table><h4 id="通过-Servlet-设置-Cookie"><a href="#通过-Servlet-设置-Cookie" class="headerlink" title="通过 Servlet 设置 Cookie"></a>通过 Servlet 设置 Cookie</h4><ul><li><p>通过 Servlet 设置 Cookie 包括三个步骤</p><ul><li><strong>创建一个 Cookie 对象</strong><ul><li>可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串<ul><li><code>Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);</code></li></ul></li><li>无论是名字还是值，都不应该包含空格或以下任何字符<ul><li><code>[ ] ( ) = , &quot; / ? @ : ;</code></li></ul></li></ul></li><li><strong>设置最大生存周期</strong><ul><li>可以使用 setMaxAge 方法来指定 cookie 能够保持有效的时间（以秒为单位）</li><li>下面将设置一个最长有效期为 24 小时的 cookie<ul><li><code>cookie.setMaxAge(60*60*24);</code></li></ul></li></ul></li><li><strong>发送 Cookie 到 HTTP 响应头</strong><ul><li>可以使用 <strong>response.addCookie</strong> 来添加 HTTP 响应头中的 Cookie<ul><li><code>response.addCookie(cookie);</code></li></ul></li></ul></li></ul></li><li><p>实例</p><ul><li>修改表单数据实例，为名字和姓氏设置 Cookie</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Servlet implementation class HelloServlet</span><br><span class="line"> */</span><br><span class="line">@WebServlet(&quot;/HelloForm&quot;)</span><br><span class="line">public class HelloForm extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">       </span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#HttpServlet()</span><br><span class="line">     */</span><br><span class="line">    public HelloForm() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 为名字和姓氏创建 Cookie      </span><br><span class="line">        Cookie name = new Cookie(&quot;name&quot;,</span><br><span class="line">                URLEncoder.encode(request.getParameter(&quot;name&quot;), &quot;UTF-8&quot;)); // 中文转码</span><br><span class="line">        Cookie url = new Cookie(&quot;url&quot;,</span><br><span class="line">                      request.getParameter(&quot;url&quot;));</span><br><span class="line">        </span><br><span class="line">        // 为两个 Cookie 设置过期日期为 24 小时后</span><br><span class="line">        name.setMaxAge(60*60*24); </span><br><span class="line">        url.setMaxAge(60*60*24); </span><br><span class="line">        </span><br><span class="line">        // 在响应头中添加两个 Cookie</span><br><span class="line">        response.addCookie( name );</span><br><span class="line">        response.addCookie( url );</span><br><span class="line">        </span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        </span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;设置 Cookie 实例&quot;;</span><br><span class="line">        String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;ul&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;li&gt;&lt;b&gt;站点名：&lt;/b&gt;：&quot;</span><br><span class="line">                + request.getParameter(&quot;name&quot;) + &quot;\n&lt;/li&gt;&quot; +</span><br><span class="line">                &quot;  &lt;li&gt;&lt;b&gt;站点 URL：&lt;/b&gt;：&quot;</span><br><span class="line">                + request.getParameter(&quot;url&quot;) + &quot;\n&lt;/li&gt;&quot; +</span><br><span class="line">                &quot;&lt;/ul&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>web.xml 文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;servlet&gt; </span><br><span class="line">    &lt;!-- 类名 --&gt;  </span><br><span class="line">    &lt;servlet-name&gt;HelloForm&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 所在的包 --&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.runoob.test.HelloForm&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloForm&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 访问的网址 --&gt;</span><br><span class="line">    &lt;url-pattern&gt;/TomcatTest/HelloForm&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><ul><li>HTML 页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;/TomcatTest/HelloForm&quot; method=&quot;GET&quot;&gt;</span><br><span class="line">站点名 ：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">站点 URL：&lt;input type=&quot;text&quot; name=&quot;url&quot; /&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="通过-Servlet-读取-Cookie"><a href="#通过-Servlet-读取-Cookie" class="headerlink" title="通过 Servlet 读取 Cookie"></a>通过 Servlet 读取 Cookie</h4><ul><li>要读取 Cookie，您需要通过调用 <em>HttpServletRequest</em> 的 <strong>getCookies( )</strong> 方法创建一个 <em>javax.servlet.http.Cookie</em> 对象的数组</li><li>然后循环遍历数组，并使用 getName() 和 getValue() 方法来访问每个 cookie 和关联的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Servlet implementation class ReadCookies</span><br><span class="line"> */</span><br><span class="line">@WebServlet(&quot;/ReadCookies&quot;)</span><br><span class="line">public class ReadCookies extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">       </span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#HttpServlet()</span><br><span class="line">     */</span><br><span class="line">    public ReadCookies() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        Cookie cookie = null;</span><br><span class="line">        Cookie[] cookies = null;</span><br><span class="line">        // 获取与该域相关的 Cookie 的数组</span><br><span class="line">        cookies = request.getCookies();</span><br><span class="line">         </span><br><span class="line">         // 设置响应内容类型</span><br><span class="line">         response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">    </span><br><span class="line">         PrintWriter out = response.getWriter();</span><br><span class="line">         String title = &quot;Delete Cookie Example&quot;;</span><br><span class="line">         String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">         out.println(docType +</span><br><span class="line">                   &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                   &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">                   &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; );</span><br><span class="line">          if( cookies != null )&#123;</span><br><span class="line">            out.println(&quot;&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;&quot;);</span><br><span class="line">            for (int i = 0; i &lt; cookies.length; i++)&#123;</span><br><span class="line">               cookie = cookies[i];</span><br><span class="line">               if((cookie.getName( )).compareTo(&quot;name&quot;) == 0 )&#123;</span><br><span class="line">                    cookie.setMaxAge(0);</span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line">                    out.print(&quot;已删除的 cookie：&quot; + </span><br><span class="line">                                 cookie.getName( ) + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               out.print(&quot;名称：&quot; + cookie.getName( ) + &quot;，&quot;);</span><br><span class="line">               out.print(&quot;值：&quot; +  URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;) +&quot; &lt;br/&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             out.println(</span><br><span class="line">               &quot;&lt;h2 class=\&quot;tutheader\&quot;&gt;No Cookie founds&lt;/h2&gt;&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         out.println(&quot;&lt;/body&gt;&quot;);</span><br><span class="line">         out.println(&quot;&lt;/html&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过-Servlet-删除-Cookie"><a href="#通过-Servlet-删除-Cookie" class="headerlink" title="通过 Servlet 删除 Cookie"></a>通过 Servlet 删除 Cookie</h4><ul><li>如果您想删除一个 cookie，只需要按照以下三个步骤进行<ul><li>读取一个现有的 cookie，并把它存储在 Cookie 对象中。</li><li>使用 <strong>setMaxAge()</strong> 方法设置 cookie 的年龄为零，来删除现有的 cookie。</li><li>把这个 cookie 添加到响应头。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line"> */</span><br><span class="line">public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    Cookie cookie = null;</span><br><span class="line">    Cookie[] cookies = null;</span><br><span class="line">    // 获取与该域相关的 Cookie 的数组</span><br><span class="line">    cookies = request.getCookies();</span><br><span class="line">    </span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">    response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">   </span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    String title = &quot;删除 Cookie 实例&quot;;</span><br><span class="line">    String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">    out.println(docType +</span><br><span class="line">              &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">              &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">              &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; );</span><br><span class="line">     if( cookies != null )&#123;</span><br><span class="line">       out.println(&quot;&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;&quot;);</span><br><span class="line">       for (int i = 0; i &lt; cookies.length; i++)&#123;</span><br><span class="line">          cookie = cookies[i];</span><br><span class="line">          if((cookie.getName( )).compareTo(&quot;url&quot;) == 0 )&#123;</span><br><span class="line">               cookie.setMaxAge(0);</span><br><span class="line">               response.addCookie(cookie);</span><br><span class="line">               out.print(&quot;已删除的 cookie：&quot; + </span><br><span class="line">                            cookie.getName( ) + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          out.print(&quot;名称：&quot; + cookie.getName( ) + &quot;，&quot;);</span><br><span class="line">          out.print(&quot;值：&quot; + cookie.getValue( )+&quot; &lt;br/&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        out.println(</span><br><span class="line">          &quot;&lt;h2 class=\&quot;tutheader\&quot;&gt;No Cookie founds&lt;/h2&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(&quot;&lt;/body&gt;&quot;);</span><br><span class="line">    out.println(&quot;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet-Session-跟踪"><a href="#Servlet-Session-跟踪" class="headerlink" title="Servlet Session 跟踪"></a>Servlet Session 跟踪</h3><ul><li><p>HTTP 是一种”无状态”协议，这意味着每次客户端检索网页时，客户端打开一个单独的连接到 Web 服务器，服务器会<strong>自动不保留</strong>之前客户端请求的任何记录</p></li><li><p>但是仍然有以下三种方式来维持 Web 客户端和 Web 服务器之间的 session 会话</p><ul><li><p>Cookies</p><ul><li>一个 Web 服务器可以分配一个唯一的 session 会话 ID 作为每个 Web 客户端的 cookie，对于客户端的后续请求可以使用接收到的 cookie 来识别</li></ul></li><li><p>隐藏的表单字段</p><ul><li>一个 Web 服务器可以发送一个隐藏的 HTML 表单字段，以及一个唯一的 session 会话 ID<ul><li><code>&lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;12345&quot;&gt;</code></li><li>该条目意味着，当表单被提交时，指定的名称和值会被自动包含在 GET 或 POST 数据中。每次当 Web 浏览器发送回请求时，session_id 值可以用于保持不同的 Web 浏览器的跟踪。</li><li>这可能是一种保持 session 会话跟踪的有效方式，但是点击常规的超文本链接<code>（&lt;A HREF...&gt;）</code>不会导致表单提交，因此隐藏的表单字段也不支持常规的 session 会话跟踪。</li></ul></li></ul></li><li><p>URL 重写</p><ul><li>可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。<ul><li>例如，<code>http://w3cschool.cc/file.htm;sessionid=12345</code>，session 会话标识符被附加为 sessionid&#x3D;12345，标识符可被 Web 服务器访问以识别客户端。</li></ul></li><li>一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态 HTML 页面中也会如此。</li></ul></li></ul></li></ul><h4 id="HttpSession-对象"><a href="#HttpSession-对象" class="headerlink" title="HttpSession 对象"></a>HttpSession 对象</h4><ul><li><p>除了上述的三种方式，Servlet 还提供了 HttpSession 接口，该接口提供了一种<strong>跨多个页面请求或访问</strong>网站时识别用户以及存储有关用户信息的方式。</p></li><li><p>Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。</p></li><li><p>您会通过调用 HttpServletRequest 的公共方法 <strong>getSession()</strong> 来获取 HttpSession 对象，如下所示：</p><ul><li><code>HttpSession session = request.getSession();</code></li></ul></li><li><p>你需要在向客户端发送任何文档内容之前调用 *request.getSession()*。下面总结了 HttpSession 对象中可用的几个重要的方法</p></li></ul><table><thead><tr><th>序号</th><th>方法以及描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public Object getAttribute(String name)</strong> &#x2F;&#x2F;该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</td></tr><tr><td>2</td><td><strong>public Enumeration getAttributeNames()</strong> &#x2F;&#x2F;该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td></tr><tr><td>3</td><td><strong>public long getCreationTime()</strong> &#x2F;&#x2F;该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr><tr><td>4</td><td><strong>public String getId()</strong> &#x2F;&#x2F;该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td></tr><tr><td>5</td><td><strong>public long getLastAccessedTime()</strong> &#x2F;&#x2F;该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr><tr><td>6</td><td><strong>public int getMaxInactiveInterval()</strong> &#x2F;&#x2F;该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td></tr><tr><td>7</td><td><strong>public void invalidate()</strong> &#x2F;&#x2F;该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td></tr><tr><td>8</td><td><strong>public boolean isNew()</strong> &#x2F;&#x2F;如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td></tr><tr><td>9</td><td><strong>public void removeAttribute(String name)</strong> &#x2F;&#x2F;该方法将从该 session 会话移除指定名称的对象。</td></tr><tr><td>10</td><td><strong>public void setAttribute(String name, Object value)</strong> &#x2F;&#x2F;方法使用指定的名称绑定一个对象到该 session 会话。</td></tr><tr><td>11</td><td><strong>public void setMaxInactiveInterval(int interval)</strong> &#x2F;&#x2F;方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td></tr></tbody></table><h4 id="Session-跟踪实例"><a href="#Session-跟踪实例" class="headerlink" title="Session 跟踪实例"></a>Session 跟踪实例</h4><ul><li>本实例说明了如何使用 HttpSession 对象获取 session 会话创建时间和最后访问时间。</li><li>如果不存在 session 会话，我们将通过请求创建一个新的 session 会话。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Servlet implementation class SessionTrack</span><br><span class="line"> */</span><br><span class="line">@WebServlet(&quot;/SessionTrack&quot;)</span><br><span class="line">public class SessionTrack extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果不存在 session 会话，则创建一个 session 对象</span><br><span class="line">        HttpSession session = request.getSession(true);</span><br><span class="line">        // 获取 session 创建时间</span><br><span class="line">        Date createTime = new Date(session.getCreationTime());</span><br><span class="line">        // 获取该网页的最后一次访问时间</span><br><span class="line">        Date lastAccessTime = new Date(session.getLastAccessedTime());</span><br><span class="line">         </span><br><span class="line">        //设置日期输出的格式  </span><br><span class="line">        SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  </span><br><span class="line">    </span><br><span class="line">        String title = &quot;Servlet Session 实例 - 菜鸟教程&quot;;</span><br><span class="line">        Integer visitCount = new Integer(0);</span><br><span class="line">        String visitCountKey = new String(&quot;visitCount&quot;);</span><br><span class="line">        String userIDKey = new String(&quot;userID&quot;);</span><br><span class="line">        String userID = new String(&quot;Runoob&quot;);</span><br><span class="line">        if(session.getAttribute(visitCountKey) == null) &#123;</span><br><span class="line">            session.setAttribute(visitCountKey, new Integer(0));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        // 检查网页上是否有新的访问者</span><br><span class="line">        if (session.isNew())&#123;</span><br><span class="line">            title = &quot;Servlet Session 实例 - 菜鸟教程&quot;;</span><br><span class="line">             session.setAttribute(userIDKey, userID);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             visitCount = (Integer)session.getAttribute(visitCountKey);</span><br><span class="line">             visitCount = visitCount + 1;</span><br><span class="line">             userID = (String)session.getAttribute(userIDKey);</span><br><span class="line">        &#125;</span><br><span class="line">        session.setAttribute(visitCountKey,  visitCount);</span><br><span class="line">    </span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">    </span><br><span class="line">        String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">                 &quot;&lt;h2 align=\&quot;center\&quot;&gt;Session 信息&lt;/h2&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;table border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;th&gt;Session 信息&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;id&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; + session.getId() + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;创建时间&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; +  df.format(createTime) + </span><br><span class="line">                &quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;最后访问时间&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; + df.format(lastAccessTime) + </span><br><span class="line">                &quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;用户 ID&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; + userID + </span><br><span class="line">                &quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;访问统计：&lt;/td&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;td&gt;&quot; + visitCount + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/table&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/body&gt;&lt;/html&gt;&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>web.xml</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;servlet&gt; </span><br><span class="line">    &lt;!-- 类名 --&gt;  </span><br><span class="line">    &lt;servlet-name&gt;SessionTrack&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 所在的包 --&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.runoob.test.SessionTrack&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;SessionTrack&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 访问的网址 --&gt;</span><br><span class="line">    &lt;url-pattern&gt;/TomcatTest/SessionTrack&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h4 id="删除-Session-会话数据"><a href="#删除-Session-会话数据" class="headerlink" title="删除 Session 会话数据"></a>删除 Session 会话数据</h4><ul><li><p>当您完成了一个用户的 session 会话数据，您有以下几种选择：</p><ul><li><p>移除一个特定的属性：您可以调用 <em>public void removeAttribute(String name)</em> 方法来删除与特定的键相关联的值。</p></li><li><p>删除整个 session 会话：您可以调用 <em>public void invalidate()</em> 方法来丢弃整个 session 会话。</p></li><li><p>设置 session 会话过期时间：您可以调用 <em>public void setMaxInactiveInterval(int interval)</em> 方法来单独设置 session 会话超时。</p></li><li><p>注销用户：如果使用的是支持 servlet 2.4 的服务器，您可以调用 <strong>logout</strong> 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。</p></li><li><p>web.xml 配置：如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">  &lt;session-timeout&gt;15&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></li><li><p>在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，以<strong>秒</strong>为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么 getMaxInactiveInterval() 会返回 900。</p></li></ul></li></ul><h3 id="Servlet-数据库访问"><a href="#Servlet-数据库访问" class="headerlink" title="Servlet 数据库访问"></a>Servlet 数据库访问</h3><ul><li>JDBC形式，不做笔记</li></ul><h3 id="Servlet-文件上传"><a href="#Servlet-文件上传" class="headerlink" title="Servlet 文件上传"></a>Servlet 文件上传</h3><ul><li>Servlet 可以与 HTML form 标签一起使用，来允许用户上传文件到服务器。上传的文件可以是文本文件或图像文件或任何文档<ul><li>表单 <strong>method</strong> 属性应该设置为 <strong>POST</strong> 方法，不能使用 GET 方法</li></ul></li></ul><h3 id="Servlet-处理日期"><a href="#Servlet-处理日期" class="headerlink" title="Servlet 处理日期"></a>Servlet 处理日期</h3><ul><li>不做笔记</li></ul><h3 id="Servlet-国家化"><a href="#Servlet-国家化" class="headerlink" title="Servlet 国家化"></a>Servlet 国家化</h3><ul><li>不做笔记</li></ul><h3 id="Servlet-自动刷新页面"><a href="#Servlet-自动刷新页面" class="headerlink" title="Servlet 自动刷新页面"></a>Servlet 自动刷新页面</h3><ul><li>Java Servlet 提供了一个机制，使得网页会在给定的时间间隔自动刷新</li><li>刷新网页的最简单的方式是使用响应对象的方法 <strong>setIntHeader()</strong>,此方法把头信息 “Refresh” 连同一个表示时间间隔的整数值（以秒为单位）发送回浏览器<ul><li><code>public void setIntHeader(String header, int headerValue)</code></li></ul></li></ul><h3 id="Servlet-网页重定向"><a href="#Servlet-网页重定向" class="headerlink" title="Servlet 网页重定向"></a>Servlet 网页重定向</h3><ul><li><p>当文档移动到新的位置，我们需要向客户端发送这个新位置时，我们需要用到网页重定向，当然，也可能是为了负载均衡，或者只是为了简单的随机，这些情况都有可能用到网页重定向。</p></li><li><p>重定向请求到另一个网页的最简单的方式是使用 response 对象的 <code>sendRedirect()</code> 方法,该方法把响应连同状态码和新的网页位置发送回浏览器,下面是该方法的定义</p><ul><li><code>public void HttpServletResponse.sendRedirect(String location) throws IOException </code></li></ul></li><li><p>也可以通过把 setStatus() 和 setHeader() 方法一起使用来达到同样的效果</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String site = &quot;http://www.xinye.com&quot; ;</span><br><span class="line">response.setStatus(response.SC_MOVED_TEMPORARILY);</span><br><span class="line">response.setHeader(&quot;Location&quot;, site); </span><br></pre></td></tr></table></figure><h3 id="Servlet-包"><a href="#Servlet-包" class="headerlink" title="Servlet 包"></a>Servlet 包</h3><ul><li>涉及到 WEB-INF 子目录的 Web 应用程序结构是所有的 Java web 应用程序的标准，并由 Servlet API 规范指定<ul><li>WEB-INF 子目录中包含应用程序的部署描述符，名为 web.xml。</li><li>所有的 HTML 文件都位于顶级目录下。对于 admin 用户，您会发现 ROOT 目录是顶级目录的父目录</li></ul></li></ul><h3 id="Servlet-调试"><a href="#Servlet-调试" class="headerlink" title="Servlet 调试"></a>Servlet 调试</h3><ul><li><p>System.out.println()</p><ul><li>是作为一个标记来使用的，用来测试一段特定的代码是否被执行，也可以打印出变量的值</li><li>由于 System 对象是核心 Java 对象的一部分，它可以在不需要安装任何额外类的情况下被用于任何地方</li><li>与在断点处停止不同，写入到 System.out 不会干扰到应用程序的正常执行流程</li><li>语法生成的所有消息将被记录在 Web 服务器日志文件中</li></ul></li><li><p>消息日志</p><ul><li>使用适当的日志记录方法来记录所有调试、警告和错误消息，这是非常好的想法，推荐使用 <a href="https://logging.apache.org/log4j/2.0/download.html">log4J</a> 来记录所有的消息</li></ul></li><li><p>使用 JDB 调试器</p></li><li><p>使用注释</p></li><li><p>客户端和服务器端头信息</p></li><li><p>重要的调试技巧</p><ul><li>请注意，server_root&#x2F;classes 不会重载，而 server_root&#x2F;servlets 可能会。</li><li>要求浏览器显示它所显示的页面的原始内容。这有助于识别格式的问题。它通常是”视图”菜单下的一个选项。</li><li>通过强制执行完全重新加载页面来确保浏览器还没有缓存前一个请求的输出。在 Netscape Navigator 中，请使用 Shift-Reload，在 Internet Explorer 中，请使用 Shift-Refresh。</li><li>请确认 servlet 的 init() 方法接受一个 ServletConfig 参数，并调用 super.init(config)。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML学习笔记</title>
      <link href="/2022/09/22/XML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/22/XML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>XML 是指可扩展标记语言:Extensible Markup Language</li><li>被设计为传输数据和存储数据</li><li>需要自行定义标签</li><li>具有自我描述型</li><li>不作为，XML 被设计用来结构化、存储以及传输信息</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>XML 把数据从 HTML 分离</li><li>XML 简化数据共享和数据传输</li><li>XML 简化平台变更</li><li>XML 使你的数据更有用</li><li>XML 用于创建新的Internet语言</li></ul><h4 id="简单的-XML-实例"><a href="#简单的-XML-实例" class="headerlink" title="简单的 XML 实例"></a>简单的 XML 实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><ul><li><p>XML 文档形成一种树结构</p><ul><li>该文档树从根部开始，并扩展到树的最低端</li></ul></li><li><p>必须包含根元素。</p><ul><li>是其他元素的父元素</li></ul></li><li><p>图例</p></li></ul><p><img src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202209202251295.png" alt="image-20220918212803392"></p><h4 id="XML-语法"><a href="#XML-语法" class="headerlink" title="XML 语法"></a>XML 语法</h4><ul><li>所有元素都必须有关闭标签</li><li>对大小写敏感</li><li>正确的嵌套</li><li>必须有根元素</li><li>XML 的属性值必须加引号</li><li>实体引用<ul><li>&lt; 和 &amp; 的是不能直接引用的</li></ul></li><li>注释同 HTML 相似</li><li>空格会被保留</li><li>以 LF 存储换行</li></ul><h4 id="XML-元素"><a href="#XML-元素" class="headerlink" title="XML 元素"></a>XML 元素</h4><ul><li><p>一个元素可以包含：其他元素，文本，属性，或者混合所有</p></li><li><p>命名规则</p><ul><li>名称可以包含字母、数字以及其他的字符</li><li>名称不能以数字或者标点符号开始</li><li>名称不能以字母 xml 或者 XML，Xml 等开始</li><li>名称不能包含空格</li></ul></li><li><p>建议命名习惯</p><ul><li>简短，具有描述性，避免 - . : 等字符</li></ul></li><li><p>XML 元素是可扩展的</p></li></ul><h4 id="XML-属性"><a href="#XML-属性" class="headerlink" title="XML 属性"></a>XML 属性</h4><ul><li>Attribute 提供有关元素的额外信息，类型于 HTML</li><li>XML 属性必须加引号</li><li>尽量避免用属性，如果看起来像数据，那么请使用元素，仅仅使用属性来提高一些与数据无关的信息<ul><li>原因<ul><li>属性不能包含多个值</li><li>属性不能包含树结构</li><li>属性不易扩展</li><li>难以阅读和维护</li></ul></li></ul></li><li>针对元数据的 XML 属性<ul><li>向元素分配 ID 引用，可用标识 XML 元素，作为一个标识符</li></ul></li><li><em><strong>元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。</strong></em></li></ul><h4 id="XML-验证"><a href="#XML-验证" class="headerlink" title="XML 验证"></a>XML 验证</h4><ul><li><p>拥有正确格式的 XML 被称为“形式良好”的 XML</p></li><li><p>可通过 DTD 验证 XML 是否“合法”</p><ul><li>DTD 的目的是定义 XML 文档的结构</li></ul></li><li><p>W3C 支持替代 DTD 的替代者，为 XML Schema</p></li><li><p>XML 文档中的错误会终止您的 XML 应用程序</p><ul><li>W3C 的 XML 规范声明：如果 XML 文档存在错误，那么程序就不应当继续处理这个文档。理由是，XML 软件应当轻巧，快速，具有良好的兼容性。</li></ul></li></ul><h4 id="查看-XML-文件"><a href="#查看-XML-文件" class="headerlink" title="查看 XML 文件"></a>查看 XML 文件</h4><ul><li>在所有主流的浏览器中，均能够查看原始的 XML 文件</li><li>XML 文件不会直接显示为 HTML 页面<ul><li>原因<ul><li>XML 文档不会携带如何显示数据的信息<br>浏览器无法确定如<code>&lt;table&gt;</code>标签描述为 HTML 表格还是餐桌</li></ul></li></ul></li></ul><h4 id="显示-XML"><a href="#显示-XML" class="headerlink" title="显示 XML"></a>显示 XML</h4><ul><li>通过使用 CSS(Cascading Style Sheets 层叠样式表)，你可以添加显示信息到 XML 文档中 (不建议)</li><li>例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;cd_catalog.css&quot;?&gt;</span><br><span class="line">&lt;CATALOG&gt;</span><br><span class="line">&lt;CD&gt;</span><br><span class="line">&lt;TITLE&gt;Empire Burlesque&lt;/TITLE&gt;</span><br><span class="line">&lt;ARTIST&gt;Bob Dylan&lt;/ARTIST&gt;</span><br><span class="line">&lt;COUNTRY&gt;USA&lt;/COUNTRY&gt;</span><br><span class="line">&lt;COMPANY&gt;Columbia&lt;/COMPANY&gt;</span><br><span class="line">&lt;PRICE&gt;10.90&lt;/PRICE&gt;</span><br><span class="line">&lt;YEAR&gt;1985&lt;/YEAR&gt;</span><br><span class="line">&lt;/CD&gt;</span><br><span class="line">&lt;CD&gt;</span><br><span class="line">&lt;TITLE&gt;Hide your heart&lt;/TITLE&gt;</span><br><span class="line">&lt;ARTIST&gt;Bonnie Tyler&lt;/ARTIST&gt;</span><br><span class="line">&lt;COUNTRY&gt;UK&lt;/COUNTRY&gt;</span><br><span class="line">&lt;COMPANY&gt;CBS Records&lt;/COMPANY&gt;</span><br><span class="line">&lt;PRICE&gt;9.90&lt;/PRICE&gt;</span><br><span class="line">&lt;YEAR&gt;1988&lt;/YEAR&gt;</span><br><span class="line">&lt;/CD&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&lt;/CATALOG&gt;</span><br></pre></td></tr></table></figure><ul><li>通过 XSLT(eXtensible Stylesheet Language Transformations),把 XML 文档转化成 HTML 格式<ul><li>首选的 XML 样式表语言</li><li>功能比 CSS 更完善</li></ul></li></ul><h4 id="XML-JavaScript"><a href="#XML-JavaScript" class="headerlink" title="XML JavaScript"></a>XML JavaScript</h4><h5 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h5><ul><li>XML HttpRequest 对象用于在后台与服务器交换数据<ul><li>能不加载页面的情况下更新网页</li><li>在页面已加载后从服务器请求数据，接受数据</li><li>在后台向服务器发送数据</li></ul></li><li>创建一个 XMLHttpRequest实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建 XMLHttpRequest 对象的语法</span><br><span class="line">xmlhttp=new XMLHttpRequest();</span><br><span class="line">//旧版本的Internet Explorer（IE5和IE6）中使用 ActiveX 对象</span><br><span class="line">xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br></pre></td></tr></table></figure><h5 id="XML-Parser"><a href="#XML-Parser" class="headerlink" title="XML Parser"></a>XML Parser</h5><ul><li>XML 解析器把 XML 文档转换为 XML DOM对象，可以通过 JavaScript 操作的对象<ul><li>Internet Explorer 使用 <code>loadXML()</code>方法解析 XML 字符串，其他浏览器用 <code>DOMParser</code></li></ul></li><li>解析 XML 例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (window.XMLHttpRequest)</span><br><span class="line">&#123;// code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">xmlhttp=new XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;// code for IE6, IE5</span><br><span class="line">xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;books.xml&quot;,false);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlDoc=xmlhttp.responseXML;</span><br></pre></td></tr></table></figure><ul><li>解析 XML 字符串例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">txt=&quot;&lt;bookstore&gt;&lt;book&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;title&gt;Everyday Italian&lt;/title&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;year&gt;2005&lt;/year&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;/book&gt;&lt;/bookstore&gt;&quot;;</span><br><span class="line"></span><br><span class="line">if (window.DOMParser)</span><br><span class="line">&#123;</span><br><span class="line">parser=new DOMParser();</span><br><span class="line">xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else // Internet Explorer</span><br><span class="line">&#123;</span><br><span class="line">xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);</span><br><span class="line">xmlDoc.async=false;</span><br><span class="line">xmlDoc.loadXML(txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="XML-DOM"><a href="#XML-DOM" class="headerlink" title="XML DOM"></a>XML DOM</h5><ul><li><p>DOM(Document Object Model 文档对象模型)定义了访问和操作文档的标注方法</p></li><li><p>把 XML 文档作为树结构来查看</p></li><li><p>所有元素都可以通过 DOM 树来访问。</p><ul><li>可以修改，删除，创建</li></ul></li><li><p>元素，文本，属性都被认为是节点</p></li><li><p>加载一个 XML 文件 例子</p><ul><li>请注意，即使 XML 文件只包含一个 <to> 元素，您仍然必须指定数组索引 [0]。这是因为 <code>getElementsByTagName()</code> 方法返回一个数组。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//该实例把 XML 文档（&quot;note.xml&quot;）解析到 XML DOM 对象中，然后通过 JavaScript 提取一些信息</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">if (window.XMLHttpRequest)</span><br><span class="line">&#123;// code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">xmlhttp=new XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;// code for IE6, IE5</span><br><span class="line">xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;note.xml&quot;,false);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlDoc=xmlhttp.responseXML;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;to&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;to&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById(&quot;from&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;from&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById(&quot;message&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;body&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>加载一个 XML 字符串 - 跨浏览器实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br /&gt;</span><br><span class="line">&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">txt=&quot;&lt;note&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;to&gt;Tove&lt;/to&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;from&gt;Jani&lt;/from&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;heading&gt;Reminder&lt;/heading&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&quot;;</span><br><span class="line">txt=txt+&quot;&lt;/note&gt;&quot;;</span><br><span class="line"></span><br><span class="line">if (window.DOMParser)</span><br><span class="line">&#123;</span><br><span class="line">parser=new DOMParser();</span><br><span class="line">xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else // Internet Explorer</span><br><span class="line">&#123;</span><br><span class="line">xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);</span><br><span class="line">xmlDoc.async=false;</span><br><span class="line">xmlDoc.loadXML(txt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;to&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;to&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById(&quot;from&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;from&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">document.getElementById(&quot;message&quot;).innerHTML=</span><br><span class="line">xmlDoc.getElementsByTagName(&quot;body&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="XML-进阶"><a href="#XML-进阶" class="headerlink" title="XML 进阶"></a>XML 进阶</h4><h5 id="XML-命名空间"><a href="#XML-命名空间" class="headerlink" title="XML 命名空间"></a>XML 命名空间</h5><ul><li>提供避免元素命名冲突的方法<ul><li>使用前缀来避免命名冲突</li></ul></li><li>通过开始标签的 xmlns 属性中定义 用于前缀的命名空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">语法：xmlns:前缀=&quot;URI&quot;</span><br><span class="line"></span><br><span class="line">//例子1</span><br><span class="line">//&lt;table&gt; 标签的 xmlns 属性定义了 h: 和 f: 前缀的合格命名空间。</span><br><span class="line">//当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。</span><br><span class="line"></span><br><span class="line">命名空间，可以在他们被使用的元素中或者在 XML 根元素中声明：</span><br><span class="line">&lt;root&gt;</span><br><span class="line"></span><br><span class="line">&lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt;</span><br><span class="line">&lt;h:tr&gt;</span><br><span class="line">&lt;h:td&gt;Apples&lt;/h:td&gt;</span><br><span class="line">&lt;h:td&gt;Bananas&lt;/h:td&gt;</span><br><span class="line">&lt;/h:tr&gt;</span><br><span class="line">&lt;/h:table&gt;</span><br><span class="line"></span><br><span class="line">&lt;f:table xmlns:f=&quot;http://www.w3cschool.cc/furniture&quot;&gt;</span><br><span class="line">&lt;f:name&gt;African Coffee Table&lt;/f:name&gt;</span><br><span class="line">&lt;f:width&gt;80&lt;/f:width&gt;</span><br><span class="line">&lt;f:length&gt;120&lt;/f:length&gt;</span><br><span class="line">&lt;/f:table&gt;</span><br><span class="line"></span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//例子2</span><br><span class="line">&lt;root xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;</span><br><span class="line">xmlns:f=&quot;http://www.w3cschool.cc/furniture&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;h:table&gt;</span><br><span class="line">&lt;h:tr&gt;</span><br><span class="line">&lt;h:td&gt;Apples&lt;/h:td&gt;</span><br><span class="line">&lt;h:td&gt;Bananas&lt;/h:td&gt;</span><br><span class="line">&lt;/h:tr&gt;</span><br><span class="line">&lt;/h:table&gt;</span><br><span class="line"></span><br><span class="line">&lt;f:table&gt;</span><br><span class="line">&lt;f:name&gt;African Coffee Table&lt;/f:name&gt;</span><br><span class="line">&lt;f:width&gt;80&lt;/f:width&gt;</span><br><span class="line">&lt;f:length&gt;120&lt;/f:length&gt;</span><br><span class="line">&lt;/f:table&gt;</span><br><span class="line"></span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p> 注释：命名空间URI不会被解析器用于查找信息，其目的是赋予命名空间一个惟一的名称</p><ul><li>为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。它的语法如下</li><li><code>xmlns=&quot;*namespaceURI*&quot;</code></li></ul><h6 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h6><ul><li>统一资源标识符（URI，全称 Uniform Resource Identifier）</li><li>用于标识因特网资源的字符</li><li>常用的 URI 是是用来标识因特网地址的统一资源定位器(URL),另一个少用的URI是统一资源命名(URN)</li></ul><h5 id="CDATA-和-PCDATA"><a href="#CDATA-和-PCDATA" class="headerlink" title="CDATA 和 PCDATA"></a>CDATA 和 PCDATA</h5><ul><li><p>XML 文档中的所有文本均会被解析器解析</p></li><li><p>被解析的字符数据(PCDATA)</p><ul><li>XML 解析器通常会解析 XML 文档中所有的文本。</li><li>解析字符数据（PCDATA）是 XML 解析器解析的文本数据使用的一个术语</li></ul></li><li><p>未解析的字符数据(CDATA)</p><ul><li><p>只有 CDATA 区段中的文本会被解析器忽略</p></li><li><p>术语 CDATA 是不应该由 XML 解析器解析的文本数据</p></li><li><p>像 “&lt;” 和 “&amp;” 字符在 XML 元素中都是非法的</p><ul><li><p>“&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始</p></li><li><p>“&amp;” 会产生错误，因为解析器会把该字符解释为字符实体的开始</p></li></ul></li><li><p>某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA</p></li><li><p>语法 ：”<strong><code>&lt;![CDATA[</code></strong>“ 开始，由 “<strong><code>]]&gt;</code></strong>“ 结束</p></li></ul></li></ul><h5 id="XML-编码"><a href="#XML-编码" class="headerlink" title="XML 编码"></a>XML 编码</h5><ul><li>XML 文档可以包含非 ASCII 字符，比如挪威语 æ ø å，或者法语 ê è é</li><li>为了避免错误，需要规定 XML 编码，或者将 XML 文件存为 <code>Unicode</code></li><li>始终使用编码属性</li><li>使用支持编码的编辑器</li><li>确保您知道编辑器使用什么编码</li><li>在您的编码属性中使用相同的编码</li></ul><h5 id="服务器上的-XML"><a href="#服务器上的-XML" class="headerlink" title="服务器上的 XML"></a>服务器上的 XML</h5><ul><li>XML 文件是类似 HTML 文件的纯文本文件</li><li>XML 能够通过标准的 Web 服务器轻松地存储和生成<ul><li>Internet 服务器上进行存储的方式与 HTML 文件完全相同</li></ul></li></ul><h5 id="XML-注意事项"><a href="#XML-注意事项" class="headerlink" title="XML 注意事项"></a>XML 注意事项</h5><ul><li><p>使用 XML 时应该尽量避免使用的技术</p><ul><li><p>Internet Explorer - XML 数据岛</p></li><li><p>Internet Explorer - 行为</p></li></ul></li></ul><h5 id="XML-相关技术"><a href="#XML-相关技术" class="headerlink" title="XML 相关技术"></a>XML 相关技术</h5><ul><li><p>XHTML (可扩展 HTML)</p><ul><li>更纯净的基于 XML 的 HTML 版本</li></ul></li><li><p>XML DOM (XML 文档对象模型)</p><ul><li>访问和操作 XML 的标准文档模型</li></ul></li><li><p><a href="https://www.runoob.com/xsl/xsl-tutorial.html">XSL (可扩展样式表语言)</a> XSL 包含三个部分</p><ul><li><a href="https://www.runoob.com/xsl/xsl-tutorial.html">XSLT</a> (XSL 转换) - 把 XML 转换为其他格式，比如 HTML</li><li><a href="https://www.runoob.com/xslfo/xslfo-tutorial.html">XSL-FO</a> (XSL 格式化对象)- 用于格式化 XML 文档的语言</li><li><a href="https://www.runoob.com/xpath/xpath-tutorial.html">XPath</a> - 用于导航 XML 文档的语言</li></ul></li><li><p>DTD (文档类型定义)</p><ul><li>用于定义 XML 文档中的合法元素的标准</li></ul></li><li><p>XSD (XML 架构)</p><ul><li>基于 XML 的 DTD 替代物。</li></ul></li><li><p>XQuery(XML查询语言)</p><ul><li>基于 XML 的用于查询 XML 数据的语言</li></ul></li></ul><h4 id="XML-总结"><a href="#XML-总结" class="headerlink" title="XML 总结"></a>XML 总结</h4><ul><li>XML 可用于交换、共享和存储数据</li><li>XML 文档形成树状结构，在”根”和”叶子”的分支机构开始的</li><li>XML 有非常简单的语法规则。带有正确语法的 XML 是”形式良好”的。有效的 XML 是针对 DTD 进行验证的</li><li>XSLT用于把 XML 转换为其他格式，比如 HTML</li><li>所有现代的浏览器有一个内建的 XML 解析器，可读取和操作 XML</li><li>DOM(Document Object Model）定义了一个访问 XML 的标准方式</li><li>XMLHttpRequest 对象提供了一个网页加载后与服务器进行通信的方式</li><li>XML 命名空间提供了一种避免元素命名冲突的方法</li><li>CDATA 区域内的文本会被解析器忽略</li></ul>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit笔记(一)</title>
      <link href="/2022/09/13/Junit%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2022/09/13/Junit%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Junit简述"><a href="#Junit简述" class="headerlink" title="Junit简述"></a>Junit简述</h3><ul><li>junit是用于java单元测试工具，是一个单元测试框架，适用于白盒测试，也适用于回归测试<ul><li>白合测试: 程序的内部逻辑结构和其他信息对测试人员是公开的</li><li>回归测试: 对软件或者环境修复更正后的“再测试”</li><li>单元测试: 最小的测试模块，</li></ul></li><li>特性<ul><li>用于测试期望结果的断言</li><li>用于共享测试数据的测试工具</li><li>方便组织和运行的测试套件</li><li>图形和文本的测试运行器</li></ul></li></ul><h3 id="编写测试用例步骤"><a href="#编写测试用例步骤" class="headerlink" title="编写测试用例步骤"></a>编写测试用例步骤</h3><ul><li>创建被测对象</li><li>调用被测试方法，输入参数</li><li>判断预期结果是否和真实值一样</li></ul><h3 id="Junit语法"><a href="#Junit语法" class="headerlink" title="Junit语法"></a>Junit语法</h3><h4 id="junit3"><a href="#junit3" class="headerlink" title="junit3"></a>junit3</h4><ul><li>测试类都要继承TestCase</li><li>测试方法都要以test开头</li><li>测试三步骤进行测试</li><li>void setUp()方法每次执行测试方法都先执行一次、<ul><li>可以用来实例化对象</li></ul></li><li>void teardown()方法每次测试方法停止测试的时候都执行一次</li></ul><h4 id="Junit4"><a href="#Junit4" class="headerlink" title="Junit4"></a>Junit4</h4><ul><li><p>@Test</p><ul><li>每个测试方法要被标注，同时必须用public void进行修饰，且不能携带参数</li></ul></li><li><p>@Before</p><ul><li>同setup()一个作用</li></ul></li><li><p>@After</p><ul><li>同teardown()一个作用</li></ul></li><li><p>@BeforeClass</p><ul><li>被标记的方法必须为static，每次类初始化执行一次</li></ul></li><li><p>@AfterClass</p><ul><li>被标记的方法必须为static,每次类停止前执行一次</li></ul></li><li><p>ingore</p><ul><li>忽略被标记的方法</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Juint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记(一)</title>
      <link href="/2022/09/13/Git%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2022/09/13/Git%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h3 id="git是什么"><a href="#git是什么" class="headerlink" title="git是什么"></a>git是什么</h3><ul><li>一个开源的分布式版本的控制系统，用于处理项目</li><li>分布式版本库的方式</li><li>不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</li></ul><h4 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h4><ul><li>git config<ul><li>专门用来配置或者读取相应的工作环境变量的工具</li></ul></li><li>查看所有的git配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><ul><li>用户配置<ul><li>配置用户名和邮箱</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;XXX&quot;</span><br><span class="line">git config --global user.email &quot;XXX&quot;</span><br></pre></td></tr></table></figure><ul><li>设置文本编辑器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor XXX</span><br></pre></td></tr></table></figure><p>略</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li>克隆git资源作为工作目录</li><li>添加或者修改文件</li><li>如果其他人修改了，你可以更新资源</li><li>在提交前查看修改</li><li>提交修改</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交</li></ul><p>流程图</p><ul><li><img src="https://cdn.jsdelivr.net/gh/xinyemoon/Image//article_img/image-20220913150753435.png" alt="image-20220913150753435"></li></ul><h4 id="Git的工作区，暂存区和版本库"><a href="#Git的工作区，暂存区和版本库" class="headerlink" title="Git的工作区，暂存区和版本库"></a>Git的工作区，暂存区和版本库</h4><ul><li>工作区：我们电脑上能看见的目录</li><li>暂缓区：.&#x2F;git目录下index文件(.git&#x2F;index)中，也称索引</li><li>版本库：工作区的隐藏目录.git</li></ul><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><ul><li>创建仓库<ul><li>生成.git目录，存放gi需求的数据和资源</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init &quot;XXX&quot;</span><br></pre></td></tr></table></figure><ul><li>从git库拷贝项目<ul><li>repository: git仓库</li><li>directory: 本地目录</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repository&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比</p></li><li><p>基本六个命令：git clone、git push、git add、git commit、git checkout、git pull</p></li><li><p>流程图：</p><p><img src="https://cdn.jsdelivr.net/gh/xinyemoon/Image//article_img/image-20220913152424189.png" alt="image-20220913152424189"></p></li><li><p>创建：上面已演示</p></li><li><p>修改和提交</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add //增加文件到缓存区</span><br><span class="line">git status //查看仓看状态</span><br><span class="line">git diff //比较缓存区和工作区文件的不同</span><br><span class="line">git commit //提交到本地仓库</span><br><span class="line">git reset //回退版本</span><br><span class="line">git rm //删除暂存区和工作区的文件</span><br><span class="line">git mv //移动或者重命名工作区文件</span><br></pre></td></tr></table></figure><ul><li>提交日志</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log //查看历史提交记录</span><br><span class="line">git blame &lt;file&gt; //指定查看文件记录</span><br></pre></td></tr></table></figure><ul><li>远程命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote //远程仓库操作</span><br><span class="line">git fetch //获取代码库(不能自动merge)</span><br><span class="line">git merge //获取代码库后整合到当前分支</span><br><span class="line">git push //上传远程代码并合并</span><br><span class="line">git pull //下载远程代码并合并</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建一个博客</title>
      <link href="/2022/09/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/09/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="本篇文章搭建博客使用的是hexo博客框架，是基于Node-js安装的，同时，本文对发布部署内容都使用git，需要读者自行安装Node和git"><a href="#本篇文章搭建博客使用的是hexo博客框架，是基于Node-js安装的，同时，本文对发布部署内容都使用git，需要读者自行安装Node和git" class="headerlink" title="本篇文章搭建博客使用的是hexo博客框架，是基于Node.js安装的，同时，本文对发布部署内容都使用git，需要读者自行安装Node和git."></a>本篇文章搭建博客使用的是hexo博客框架，是基于Node.js安装的，同时，本文对发布部署内容都使用git，需要读者自行安装Node和git.</h4><h4 id="hexo框架有许多博客主题，本文使用的是Butterfly"><a href="#hexo框架有许多博客主题，本文使用的是Butterfly" class="headerlink" title="hexo框架有许多博客主题，本文使用的是Butterfly"></a>hexo框架有许多博客主题，本文使用的是Butterfly</h4><h4 id="版本：hexo-6-3-0-butterfly-4-4-0"><a href="#版本：hexo-6-3-0-butterfly-4-4-0" class="headerlink" title="版本：hexo:6.3.0; butterfly:4.4.0"></a>版本：hexo:6.3.0; butterfly:4.4.0</h4><h3 id="初步流程"><a href="#初步流程" class="headerlink" title="初步流程"></a>初步流程</h3><ul><li>安装hexo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure><ul><li>创建存放目录，建议放非系统盘<ul><li>完成后该目录下会有_config.yml等文件</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &quot;XXX&quot;  </span><br></pre></td></tr></table></figure><ul><li>生成静态html文件<ul><li>该命令是把博客.md等文件生成.html等格式，让用户得以访问</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><ul><li>本地部署</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><strong>执行完上述命令后，读者可以自行访问git bush界面出现的本地地址，默认是localhost:4000</strong></p><p>其他命令</p><ul><li>清楚静态文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><ul><li>生成.md文件<ul><li>读者也可以自行建立，但需要在文件头部加上必要的“标签”，是hexo对文章进行分类的表示，具体请看hexo官方文档</li><li>官方文档地址：<a href="https://hexo.io/zh-cn/index.html">Hexo</a></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;XXX&quot;</span><br></pre></td></tr></table></figure><p>好了，如果但是这样，不够美观，所以我选择用Butterfly主题来美化，读者也可以自行到hexo官方或者github等地找合适的主题安装，不过建议选择主题文档详细和常更新的，方便后续的改造。</p><h4 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h4><ul><li>安装butterfly</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly //版本为4.4.0</span><br></pre></td></tr></table></figure><ul><li>安装pug以及stylus的渲染器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><ul><li>在根目录下的_config.yml文件修改</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>到此在运行hexo clean,hexo g,hexo s就可以看到本地浏览下的界面更改了</p><h4 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h4><ul><li>根目录下的_config.yml为站点配置文件_,_&#x2F;根目录&#x2F;theme&#x2F;Butterfly&#x2F;_config.yml为主题配置文件，对于界面修改都是基于两个文件进行的</li><li>每次写新的博客内容或者新建删除，都要执行 <em>hexo cl,hexo g,hexo s</em>的步骤，后面部署到服务器后把hexo s改为hexo d 即可。</li></ul><h4 id="Github-Page部署"><a href="#Github-Page部署" class="headerlink" title="Github Page部署"></a>Github Page部署</h4><ul><li><p>需要一个github账号，注册流程不多赘述</p></li><li><p>安装扩展，辅助部署</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><ul><li>新建一个repostiory，命名为&lt;你的账号&gt;.github.io,这是为了我们的站点能通过域名访问</li><li>获取你本地git的密钥，辅助到github,进行连接，不多赘述</li><li>验证是否成功，出现你的github账号名代表连接成功</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><ul><li>然后执行hexo cl &amp;&amp; hexo g &amp;&amp; hexo d上传远程仓库</li><li>你就能在&lt;你的账号名&gt;.github.io访问你的站点啦！</li></ul><p><strong>简单的流程到此结束，接下来是阿里云配置</strong></p><h4 id="阿里云域名"><a href="#阿里云域名" class="headerlink" title="阿里云域名"></a>阿里云域名</h4><ul><li><p>在后面，我们不想用尾缀github.io的进行访问，那用其他com,cn等域名行不行?回答是可以的，而且不用域名备案。</p></li><li><p>注册一个阿里云账号，根据需求购买域名，但要注意一下续费收款，有些头年很低，但续费非常高</p><ul><li>阿里云：地址<a href="https://www.aliyun.com/?spm=5176.authc-home.top-nav.dlogo.63834babwfioQc">阿里云-为了无法计算的价值 (aliyun.com)</a></li></ul></li><li><p>注册完成后还要进行身份验证等步骤，具体过程不赘述</p></li><li><p>完成上述步骤后，在域名管理，点击你的域名，在行条上的右手边有解析域名</p></li><li><p>新手直接点新手引导就行，输入你的github那个博客的ip，ip获取可以在git中输入</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;你的名字&gt;@github.io</span><br></pre></td></tr></table></figure><ul><li>完成后在你的github点击你博客repository的settings，注意不是你个人的头像那里的settings</li><li>找到Page的domins，输入你的阿里云域名并保存，建议勾选下方的https，增加安全性。</li><li>然后在你的repository下建立一个CNAME文件，写入你的阿里云域名，在到你的本地博客的根目录下的source建议同名的文件填上相同的域名，这样做的目的是github会在你更新内容重新写绑定的域名，稳定解析连接</li></ul><h4 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h4><p>你可能发现我并没有对主题页面配置有过多的描述，这是因为在hexo官方文档和Butterfly主题文档都有详细的说明，具体请自己去查看。</p><ul><li><a href="https://hexo.io/zh-cn/index.html">Hexo</a></li><li><a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2022/09/11/test/"/>
      <url>/2022/09/11/test/</url>
      
        <content type="html"><![CDATA[<h3 id="1-图片测试"><a href="#1-图片测试" class="headerlink" title="1.图片测试"></a>1.图片测试</h3><ul><li><img src="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209202246670.png"><br>2.调试评论区是否能正常运行,测试cover能否正常运行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
