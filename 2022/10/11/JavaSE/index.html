<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JavaSE | Nature</title><meta name="keywords" content="Java"><meta name="author" content="新野"><meta name="copyright" content="新野"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaSE导论标柱注释 单独重点加粗  单独背诵下划线  ⭐️重点  ⭐️⭐️重点的重点   学习方法 需求——>知识点——>基本原理语法——>快速入门(基本程序)——>技术细节  java概述转义字符 \t  一个制表位，实现对齐功能  \n  换行  \  一个\  &quot;  一个”  \r  回车   注释 单行注释:  //注释文字">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE">
<meta property="og:url" content="http://example.com/2022/10/11/JavaSE/index.html">
<meta property="og:site_name" content="Nature">
<meta property="og:description" content="JavaSE导论标柱注释 单独重点加粗  单独背诵下划线  ⭐️重点  ⭐️⭐️重点的重点   学习方法 需求——>知识点——>基本原理语法——>快速入门(基本程序)——>技术细节  java概述转义字符 \t  一个制表位，实现对齐功能  \n  换行  \  一个\  &quot;  一个”  \r  回车   注释 单行注释:  //注释文字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808863.png">
<meta property="article:published_time" content="2022-10-11T12:41:28.161Z">
<meta property="article:modified_time" content="2022-10-01T02:00:00.000Z">
<meta property="article:author" content="新野">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808863.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/xinyemoon/Image@v1.0.4/Blog/202209202244190.png"><link rel="canonical" href="http://example.com/2022/10/11/JavaSE/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaSE',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-01 10:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css"> .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body { left: -66px !important; /* 默认情况下缩进左侧66px，只留一点箭头部分 */ }
.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover { left: 0 !important; /* 鼠标悬停是左侧缩进归零，完全显示按钮 */ } </style><link rel="stylesheet" href="/css/modify.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/xinyemoon/Image@v1.0.4/Blog/202209202244761.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808863.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Nature</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaSE</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-11T12:41:28.161Z" title="发表于 2022-10-11 20:41:28">2022-10-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-01T02:00:00.000Z" title="更新于 2022-10-01 10:00:00">2022-10-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>115分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaSE"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808863.png');"></div><article class="post-content" id="article-container"><h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="标柱注释"><a href="#标柱注释" class="headerlink" title="标柱注释"></a>标柱注释</h3><ul>
<li><p>单独重点加粗</p>
</li>
<li><p>单独背诵下划线</p>
</li>
<li><p>⭐️重点</p>
</li>
<li><p>⭐️⭐️重点的重点</p>
</li>
</ul>
<h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><ul>
<li>需求——&gt;知识点——&gt;基本原理语法——&gt;快速入门(基本程序)——&gt;技术细节</li>
</ul>
<h2 id="java概述"><a href="#java概述" class="headerlink" title="java概述"></a>java概述</h2><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul>
<li><p>\t  一个制表位，实现对齐功能</p>
</li>
<li><p>\n  换行</p>
</li>
<li><p>\  一个\</p>
</li>
<li><p>"  一个”</p>
</li>
<li><p>\r  回车</p>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><p>单行注释:  //注释文字 </p>
</li>
<li><p>多行注释:  /<em>注释文字</em>/ </p>
</li>
<li><p>文档注释:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author</span><br><span class="line">* @version</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>



<h3 id="代码规范⭐️"><a href="#代码规范⭐️" class="headerlink" title="代码规范⭐️"></a>代码规范⭐️</h3><ul>
<li><p>类、方法的注释，要以 javadoc 的方式来写</p>
</li>
<li><p>注释详细，着重告述读者为什么这样写，如何修改，注意什么问题等</p>
</li>
<li><p>使用tab、shift + tab</p>
</li>
<li><p>运算符和 = 两边习惯性各加一个空格</p>
</li>
<li><p>源文件使用utf-8编码</p>
</li>
<li><p>行宽度不要超过80字符</p>
</li>
<li><p>代码编写次行风格和行尾风格</p>
</li>
</ul>
<h3 id="JDK-JRE⭐️"><a href="#JDK-JRE⭐️" class="headerlink" title="JDK  JRE⭐️"></a>JDK  JRE⭐️</h3><ul>
<li><p>JDK(java开发工具包)</p>
</li>
<li><p>JDK = JRE + java开发工具</p>
</li>
<li><p>JRE = JVM + Java的核心类库</p>
</li>
<li><p>JVM(java虚拟机)</p>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>变量相当于内存中一个<strong>数据存储空间</strong>的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量(值)</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">double score = 88;</span><br><span class="line">char gender = '男'；</span><br><span class="line">String name = "jack";</span><br></pre></td></tr></tbody></table></figure>



<h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>变量表示内存中的一个存储区域[不同的变量，类型不同，占用的空间大小不同]</p>
</li>
<li><p>该区域有自己的名称[变量名]和类型[数据类型]</p>
</li>
<li><p><strong>变量必须先声明，后使用</strong>，即有顺序</p>
</li>
<li><p>该区域的数据可以在同一类型范围内不断变化</p>
</li>
<li><p><strong>变量在同一个作用域内不能重名</strong></p>
</li>
<li><p>变量=变量名＋值+数据类型</p>
</li>
</ul>
<h3 id="数据类型⭐️"><a href="#数据类型⭐️" class="headerlink" title="数据类型⭐️"></a>数据类型⭐️</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061033405.png"></p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul>
<li><p>整数类型  (byte [1]  short[2]  int[4]  long [8]) </p>
<ul>
<li><p>Java的整型常量(具体值)<strong>默认为 int 型</strong>，声明 long 型常量须后加‘l’或‘L’</p>
</li>
<li><p>java程序中变量常声明为 int 型，除非不足以表示大数，才使用long</p>
</li>
<li><p>bit: 计算机中的最小存储单位</p>
</li>
<li><p>byte:t算机中基本存储单元，1byte = 8 bit</p>
</li>
</ul>
</li>
<li><p>浮点(小数)类型 (float [4]  double [8]) </p>
<ul>
<li><p>浮点数 = 符号位 + 指数位 + 尾数位</p>
</li>
<li><p>尾部可能丢失，造成精度损失</p>
</li>
<li><p>Java 的浮点型常量(具体值)默认为 double 型，声明 float 型常量，须后加’f’或’F’</p>
</li>
<li><p>十进制数形式：5.12   512.0f   .512(必须有小数点) 科学计数法形式：5.12e2   5.12E-2</p>
</li>
<li><p>通常情况<strong>默认使用 double</strong></p>
</li>
</ul>
</li>
<li><p>字符型(Char[2]) </p>
<ul>
<li><p>使用单引号表示</p>
</li>
<li><p>Java 中还允许使用转义字符来将其后的字符转变为特殊字符型常量</p>
</li>
<li><p>char 的<strong>本质是一个整数</strong>，输出时是 unicode 码对应字符</p>
</li>
<li><p>char 类可以进行运算</p>
</li>
</ul>
</li>
<li><p>布尔型(boolean[1]) </p>
<ul>
<li><p>boolean 类型数据只允许取值 true 和 false，无null</p>
</li>
<li><p>boolean类型占1个字节</p>
</li>
<li><p><strong>不可以用0或非0的整数代替 false 和 true</strong>，与C语言不同</p>
</li>
</ul>
</li>
</ul>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul>
<li>略</li>
</ul>
<h3 id="基本数据类型转化"><a href="#基本数据类型转化" class="headerlink" title="基本数据类型转化"></a>基本数据类型转化</h3><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>基本介绍</p>
<ul>
<li>java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int = 'c';</span><br><span class="line">double d = 80</span><br></pre></td></tr></tbody></table></figure>



<p> 转换规则 </p>
<ul>
<li>char &lt; int &lt; long &lt; float &lt; double</li>
<li>byte &lt; short &lt; int &lt; long &lt; float &lt; double</li>
</ul>
<p> 注意事项和细节 </p>
<ul>
<li><p>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，再进行计算</p>
</li>
<li><p>我们把精度(容量)大的数据类型赋值给精度(容量)小 的数据类型时，就会报错，反之就会进行自动类型转换。</p>
</li>
<li><p><strong>byte   short   char   之间不会相互转换</strong></p>
</li>
<li><p><strong>byte   short   char   计算是首先转换为int类型</strong></p>
</li>
<li><p>boolean 不参与转换</p>
</li>
<li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p>
</li>
</ul>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p> 基本介绍</p>
<ul>
<li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符()，但可能造成精度降低或溢出，格外要注意</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = (int)8.8;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></tbody></table></figure>



<p> 注意事项和细节 </p>
<ul>
<li><p>当数据从精度  大——＞小，就需要使用到强制转换 </p>
</li>
<li><p>强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int y = int(10*3.5+6*1.5)</span><br></pre></td></tr></tbody></table></figure>



<ul>
<li>char 类型可以保存 int 的常量值，但不能保存 int 的变量值，需要强转</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int m = 100;</span><br><span class="line">char c2 = m;//false</span><br><span class="line">char c3 = (char)m;//ture</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>byte   short   char   类型在进行运算时，当做int类型处理</strong></li>
</ul>
<h3 id="基本数据类型和-String-类型转换"><a href="#基本数据类型和-String-类型转换" class="headerlink" title="基本数据类型和 String 类型转换"></a>基本数据类型和 String 类型转换</h3><h4 id="基本类型转-String-类型"><a href="#基本类型转-String-类型" class="headerlink" title="基本类型转 String 类型"></a>基本类型转 String 类型</h4><ul>
<li>语法<ul>
<li>将基本类型的值  + ” “</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n1 = 1</span><br><span class="line">float n2 = 1.1f;</span><br><span class="line">double n3 = 3.4;</span><br><span class="line">boolean b1 = true;</span><br><span class="line">String s1 = n1 + "";</span><br><span class="line">String s2 = n2 + "";</span><br><span class="line">String s3 = n3 + "";</span><br><span class="line">String s4 = b1 + "";</span><br></pre></td></tr></tbody></table></figure>

<h4 id="String-类型转基本数据类型"><a href="#String-类型转基本数据类型" class="headerlink" title="String 类型转基本数据类型"></a>String 类型转基本数据类型</h4><ul>
<li>语法<ul>
<li>通过基本类型的包装类调用 parseXX 方法</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s5 = "123";</span><br><span class="line">int num1 = InterInt.parseInt(s5);</span><br><span class="line">int num2 = InterInt.parseDouble(s5);</span><br><span class="line">int num3 = InterInt.parseFloat(s5);</span><br></pre></td></tr></tbody></table></figure>





<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p> 基本介绍</p>
<ul>
<li>算术运算符是对数值类型的变量进行运算的</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061101711.png" alt="image-20221006110137548"></p>
<h4 id="号使用"><a href="#号使用" class="headerlink" title="+号使用"></a>+号使用</h4><ul>
<li><p>当左右两边都是数值型时，则做加法运算 </p>
</li>
<li><p>当左右两边有一方为<strong>字符串</strong>，则做<strong>拼接运算</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out，println(100 + 98): //198</span><br><span class="line">System.out.println("100" + 98);//10098</span><br><span class="line">System.out.println(100 + 3 +"hello");//103hello</span><br><span class="line">System.out.println("hello"+ 100 +3);//hello1003</span><br></pre></td></tr></tbody></table></figure>



<h4 id="号使用-1"><a href="#号使用-1" class="headerlink" title="++号使用"></a>++号使用</h4><ul>
<li>前＋＋和后＋+都完全等价子 i=i+1;作为表达式使用 </li>
<li>前++：++先自增后赋值 </li>
<li>后++：i++先赋值后自增</li>
</ul>
<h4 id="号使用-2"><a href="#号使用-2" class="headerlink" title="%号使用"></a>%号使用</h4><ul>
<li>a % b 当a是<strong>小数</strong>时，公式 = a - (int)a / b * b</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul>
<li>关系运算符的结果都是 boolean 型</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061103576.png" alt="image-20221006110306463"></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p> 基本介绍</p>
<ul>
<li>用于连接多个条件(多个关系表达式)，结果是 boolean</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061103114.png" alt="image-20221006110354000"></p>
<h4 id="amp-amp-和-amp-基本规则"><a href="#amp-amp-和-amp-基本规则" class="headerlink" title="&amp;&amp;和&amp;基本规则"></a>&amp;&amp;和&amp;基本规则</h4><p> &amp;&amp; 短路与</p>
<ul>
<li>如果第一个条件为 false ，后面的条件不再判断</li>
</ul>
<p> &amp; 逻辑与</p>
<ul>
<li>如果第一个条件为 false ，后面的条件仍然判断</li>
</ul>
<h4 id="和-基本规则"><a href="#和-基本规则" class="headerlink" title="||和|基本规则"></a>||和|基本规则</h4><p> || 短路或</p>
<ul>
<li>如果第一个条件为 true，则第二个条件不会判断，结果为true</li>
</ul>
<p> |  逻辑或</p>
<ul>
<li>不管第一个条件是否为true，第二个条件都要判断</li>
</ul>
<h4 id="逻辑异或"><a href="#逻辑异或" class="headerlink" title="^逻辑异或"></a>^逻辑异或</h4><ul>
<li>当 a 和 b 不同时，则结果为 true，否则为 false</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p> 基本介绍</p>
<ul>
<li>赋值运算符就是将某个运算后的值，赋给指定的变量</li>
</ul>
<p> 注意事项和细节</p>
<ul>
<li><p>运算顺序从右往左 </p>
</li>
<li><p>赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值 </p>
</li>
<li><p>复合赋值： a  x=  b  等于  a  =  a  x  b </p>
</li>
<li><p><strong>复合赋值运算符会进行类型转换</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b = 3;</span><br><span class="line">b += 2;  //等价于 b = (byte)(b + 2)</span><br><span class="line">b++;  //等价于 b = (byte)(b + 1)</span><br></pre></td></tr></tbody></table></figure>



<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p> 基本语法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">条件表达式？表达式1：表达式2;</span><br><span class="line"></span><br><span class="line">int a = 10;</span><br><span class="line">int b = 99;</span><br><span class="line">int result = a&gt;b ? a++:b--;</span><br></pre></td></tr></tbody></table></figure>



<p>运算规则</p>
<ul>
<li><p>如果条件表达式为 true，运算后的结果是表达式1;</p>
</li>
<li><p>如果条件表达式为 false，运算后的结果是表达式2;</p>
</li>
</ul>
<p>注意事项和细节</p>
<ul>
<li>表达式1和表达式2要为可以赋给接收变量的类型(或可以自动转换)</li>
<li><!--三元运算符是一个整体，精度保持一致--></li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int c = a &gt; b ? int(1.1) : int(3.4);</span><br></pre></td></tr></tbody></table></figure>



<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>优先级</p>
<ul>
<li>() {} , 等</li>
<li>单目运算符 ++ –</li>
<li>算术运算符</li>
<li>位移运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>三元运算符</li>
<li>赋值运算符</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061116765.png" alt="image-20221006111623543"></p>
<h3 id="标识符的命名规则和规范"><a href="#标识符的命名规则和规范" class="headerlink" title="标识符的命名规则和规范"></a>标识符的命名规则和规范</h3><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul>
<li><p>由26个英文字母大小写，0~9，或＄组成</p>
</li>
<li><p><strong>数字不可开头</strong></p>
</li>
<li><p>不可以使用关键字和保留宇，但能包含关键字和保留字</p>
</li>
<li><p>Java中严格区分大小写，长度无限制</p>
</li>
<li><p>标识符不能包含空格</p>
</li>
</ul>
<h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><ul>
<li><p>包名</p>
<ul>
<li>多单词组成时所有字母都小写：aaa.bbb.ccc</li>
</ul>
</li>
<li><p>类名、接口名</p>
<ul>
<li>多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
</ul>
</li>
<li><p>变量名、方法名</p>
<ul>
<li>多单词组成时，第一个单词首字母小写，第二个单河开始每个单词首字母大写：xxxYyyzzz</li>
</ul>
</li>
<li><p>常量名</p>
<ul>
<li>所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ul>
</li>
</ul>
<h3 id="关键字、保留字"><a href="#关键字、保留字" class="headerlink" title="关键字、保留字"></a>关键字、保留字</h3><ul>
<li>被Java语言赋子了特殊含义，用做专门用途的字符串(单词)特点：关键字中所有字母都为小写</li>
</ul>
<p>关键字基本介绍</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061118450.png" alt="image-20221006111853324"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071949470.png" alt="image-20221006111919985"></p>
<p>保留字基本介绍</p>
<ul>
<li>现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留宇 byValue、cast、future、 generic、 inner、 operator、outer、rest、var、goto、const</li>
</ul>
<h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><p>基本介绍</p>
<ul>
<li>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取lnput.java，需要一个扫描器(对象)，就是 Scanner</li>
</ul>
<p>步骤</p>
<ul>
<li><p>导入该类的包，java.util.*</p>
</li>
<li><p>创建该类的对象(声明变量)</p>
</li>
<li><p>调用里面的功能</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class hello {</span><br><span class="line">    public static void main(String []args) {</span><br><span class="line">        Scanner myScanner = new Scanner(System.in);//System.in 代表使用键盘输入</span><br><span class="line">        System.out.println("请输入名字");</span><br><span class="line">        String name = myScanner.next();</span><br><span class="line">        System.out.println("请输入年龄");</span><br><span class="line">        int age = myScanner.nextInt();</span><br><span class="line">        System.out.println("名字="+name+ "\t" +"年龄="+age);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h3 id="进制⭐️"><a href="#进制⭐️" class="headerlink" title="进制⭐️"></a>进制⭐️</h3><ul>
<li><p>二进制：0.1，满2进1，以 0b 或 0B 开头</p>
</li>
<li><p>十进制：0-9，满10进1</p>
</li>
<li><p>八进制：0-7，满8进1，以数字0开头表示</p>
</li>
<li><p>十六进制：0-9及A(10)-F(15)，满16进1.以 Ox 或 0x 开头表示，此处的 A-F 不区分大小写</p>
</li>
</ul>
<p>3.9.1 其他转十进制</p>
<ul>
<li>从最低位开始，将每个位上的数提取出来，乘以(几进制)的(位数-1)次方例：0b01011 = 1 * 2^(1-1) + 1 * 2^(2-1) + 0 * 2^(3-1) + 1 * 2^(4-1) = 1 + 2 + 0 + 8 =11</li>
</ul>
<p>3.9.2 十进制转其他</p>
<ul>
<li>将该数不断除(几进制)，直到商为0，每步余数倒写</li>
</ul>
<p>3.9.3 二进制转八/十六</p>
<ul>
<li><p>从低位开始，每三位一组，转成对应八进制</p>
</li>
<li><p>从低位开始，每四位一组，转成对应十六进制</p>
</li>
</ul>
<p>3.9.4 八/十六进制转二</p>
<ul>
<li><p>将八进制的每一位，转成对应的一个三位的二进制数</p>
</li>
<li><p>将十六进制的每一位，转成对应的一个四位的二进制数</p>
</li>
</ul>
<h3 id="原码-反码-补码⭐️⭐️"><a href="#原码-反码-补码⭐️⭐️" class="headerlink" title="原码 反码 补码⭐️⭐️"></a>原码 反码 补码⭐️⭐️</h3><p>运算规则</p>
<ul>
<li><p>二进制的最高位是符号位：0表示正数，1表示负数</p>
</li>
<li><p>正数的原码、反码、补码都一样(三码合一)</p>
</li>
<li><p>负数的反码 = 它的原码符号位不变，其它位取反</p>
</li>
<li><p>负数的补码 = 它的反码+1，负数的反码 = 负数的补码 - 1</p>
</li>
<li><p>0的反码，补码都是0</p>
</li>
<li><p>java中的数都是有符号的</p>
</li>
<li><p>计算机运算的时候，都是以补码的方式来运算的</p>
</li>
<li><p>看运算结果的时候，要看他的原码</p>
</li>
</ul>
<h3 id="位运算符⭐️"><a href="#位运算符⭐️" class="headerlink" title="位运算符⭐️"></a>位运算符⭐️</h3><p>位运算符</p>
<ul>
<li><p>按位与 &amp;</p>
</li>
<li><p>按位或 | </p>
</li>
<li><p>按位异或 ^ </p>
</li>
<li><p>按位取反 ~ </p>
</li>
<li><p>算数右移 &gt;&gt; 低位溢出，符号位不变，并用符号位补溢出的高位(本质/2)</p>
</li>
<li><p>算数左移 &lt;&lt; 符号位不变，低位补0(本质*2)</p>
</li>
<li><p>逻辑右移 &gt;&gt;&gt; 低位溢出，高位补0</p>
</li>
</ul>
<p>位运算过程：</p>
<ul>
<li><p>用原码得到补码</p>
</li>
<li><p>用补码进行相关逻辑运算</p>
</li>
<li><p>运算完毕将补码转换成原码</p>
</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>基本介绍</p>
<p>程序在运行的时候, 对代码执行的先后顺序, 称作程序的执行结构. 在Java中, 程序的执行结构分为三种:</p>
<ul>
<li><p>顺序结构:</p>
<ul>
<li>代码从上往下逐行执行, 是程序执行的基本结构</li>
</ul>
</li>
<li><p>分支结构</p>
<ul>
<li>代码执行到某一个节点遇到多个分支, 选择其中的一个分支执行, 其他的分支都不执行</li>
</ul>
</li>
<li><p>循环结构</p>
<ul>
<li>某一个代码段需要重复的执行</li>
</ul>
</li>
<li><p>程序默认采用的是顺序结构, 我们也可以通过一些语句来修改程序的执行结构, 这样的语句叫做<strong>流程控制语句</strong>, 按照修改的执行结构不同, 可以分为 <strong>分支流程控制</strong> 和 <strong>循环流程控制</strong></p>
</li>
</ul>
<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a><strong>顺序结构</strong></h3><ul>
<li>略</li>
</ul>
<h3 id="分支控制-if-else-switch"><a href="#分支控制-if-else-switch" class="headerlink" title="分支控制(if  else  switch)"></a>分支控制(if  else  switch)</h3><h4 id="单分支"><a href="#单分支" class="headerlink" title="单分支"></a>单分支</h4><p>基本语法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(条件表达式){</span><br><span class="line">  执行代码块;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意事项和细节</p>
<ul>
<li><p>当条件表达式为 ture 时，就会执行 {} 的代码。如果为 false，就不执行</p>
</li>
<li><p>如果 {} 中只有一条语句，则可以不用 {} ，建议写上 {}</p>
</li>
</ul>
<h4 id="双分支"><a href="#双分支" class="headerlink" title="双分支"></a>双分支</h4><p>基本语法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(条件表达式){</span><br><span class="line">  执行代码块;</span><br><span class="line">}else{</span><br><span class="line">  执行代码块2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>注意事项和细节</p>
<ul>
<li><p>当条件表达式成立，即执行代码块1，否则执行代码块2</p>
</li>
<li><p>如果执行代码块有一条语句，则 {} 可以省略，否则，不能省略</p>
</li>
</ul>
<h4 id="多分支"><a href="#多分支" class="headerlink" title="多分支"></a>多分支</h4><p>基本语法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(条件表达式){</span><br><span class="line">  执行代码块;</span><br><span class="line">}else if(条件表达式2){</span><br><span class="line">  执行代码块2;</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line">else{</span><br><span class="line">  执行代码块n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>注意事项和细节</p>
<ul>
<li><p>当条件表达式1成立时，即执行代码块1</p>
</li>
<li><p>如果表达式1不成立，才去判断表达式2是否成立</p>
</li>
<li><p>如果表达式2成立，就执行代码块2</p>
</li>
<li><p>以此类推，如果所有的表达式都不成立则执行 else 的代码块</p>
</li>
<li><p>多分支可以没有 else</p>
</li>
</ul>
<h4 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h4><p>基本介绍</p>
<ul>
<li>在一个分支结构中又完整的嵌套了另个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外层分支</li>
</ul>
<p>基本语法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(){</span><br><span class="line">  if(){</span><br><span class="line">    //if-else</span><br><span class="line">  }else{</span><br><span class="line">    //if-else</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="switch分支结构"><a href="#switch分支结构" class="headerlink" title="switch分支结构"></a>switch分支结构</h4><p>基本语法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式){</span><br><span class="line">    case 常量1:</span><br><span class="line">      语句块1;</span><br><span class="line">      break;</span><br><span class="line">    </span><br><span class="line">    case 常量2:</span><br><span class="line">      语句块2;</span><br><span class="line">      break;</span><br><span class="line">    </span><br><span class="line">    default:</span><br><span class="line">      语句块;</span><br><span class="line">      break;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<p>说明</p>
<ul>
<li><p>switch 关键字，表示 swtich 分支</p>
</li>
<li><p>表达式对应一个值</p>
</li>
<li><p>case 常量1:</p>
<ul>
<li>当表达式的值等于常量1，就执行语句块1</li>
</ul>
</li>
<li><p>break</p>
<ul>
<li>表示退出 swtich</li>
</ul>
</li>
<li><p>如果和 case 常量1匹配，就执行语句块1，如果没有匹配，就继续匹配 case 常量2</p>
</li>
<li><p>如果一个都没有匹配上，执行 default</p>
</li>
</ul>
<p>注意事项和细节</p>
<ul>
<li><p>表达式数据类型，应和 case 后的常量类型一致，或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是 int</p>
</li>
<li><p>switch (表达式)中表达式的返回值必须是：(byte,short.int,char,enum,String)</p>
</li>
<li><p>case 子句中的值必须是常量,而不能是变量</p>
</li>
<li><p>default 子句是可选的，当没有匹配的 case 时，执行 default</p>
</li>
<li><p>break 语句跳出 switch 语句块，如果没有 break，程序会执行到结尾</p>
</li>
</ul>
<h3 id="循环控制-for-while-do-while-⭐️"><a href="#循环控制-for-while-do-while-⭐️" class="headerlink" title="循环控制(for  while  do while)⭐️"></a>循环控制(for  while  do while)⭐️</h3><h4 id="for循环控制"><a href="#for循环控制" class="headerlink" title="for循环控制"></a>for循环控制</h4><p>基本语法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(循环变量初始化;循环条件;循环变量迭代){</span><br><span class="line">  循环操作语句;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>说明</p>
<ul>
<li><p>四要素：</p>
<ul>
<li>循环变量初始化</li>
<li>循环条件</li>
<li>循环操作</li>
<li>循环变量迭代</li>
</ul>
</li>
<li><p>循环操作，这里可以有多条语句，也就是我们要循环执行的代码</p>
</li>
<li><p>如果 循环操作(语句) 只有一条语句，可以省路 {}，建议不要省略</p>
</li>
</ul>
<p>注意事项和细节</p>
<ul>
<li><p>循环条件是返回一个布尔值的表达式</p>
</li>
<li><p><strong>for(;循环判断条件;)中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略</strong></p>
</li>
<li><p>循环初始值可以有多条初始化语句，但要求类型一样，井且中间用逗号隔开</p>
</li>
<li><p>循环变量迭代也司以有名条变量迭代语句，中间用逗号隔开</p>
</li>
</ul>
<h4 id="while循环控制"><a href="#while循环控制" class="headerlink" title="while循环控制"></a>while循环控制</h4><p>基本语法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环变量初始化;</span><br><span class="line">while(循环条件){</span><br><span class="line">  循环体;</span><br><span class="line">  循环变量迭代;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>说明</p>
<ul>
<li><p>四要素</p>
<ul>
<li><p>循环变量初始化</p>
</li>
<li><p>循环条件</p>
</li>
<li><p>循环操作</p>
</li>
<li><p>循环变量迭代</p>
</li>
</ul>
</li>
<li><p>四要素位置不同</p>
</li>
</ul>
<p>注意事项和细节</p>
<ul>
<li><p>循环条件是返回一个布尔值的表达式</p>
</li>
<li><p>while循环是先判断在执行语句</p>
</li>
</ul>
<h4 id="do-while循环控制"><a href="#do-while循环控制" class="headerlink" title="do while循环控制"></a>do while循环控制</h4><p>基本语法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环变量初始化;</span><br><span class="line">do{</span><br><span class="line">  循环体;</span><br><span class="line">  循环变量迭代;</span><br><span class="line">}while(循环条件);</span><br></pre></td></tr></tbody></table></figure>



<p>说明</p>
<ul>
<li><p>四要素</p>
<ul>
<li><p>循环变量初始化</p>
</li>
<li><p>循环条件</p>
</li>
<li><p>循环操作</p>
</li>
<li><p>循环变量迭代</p>
</li>
</ul>
</li>
<li><p>四要素位置不同</p>
</li>
</ul>
<p>注意事项和细节</p>
<ul>
<li><p>循环条件是返回一个布尔值的表达式</p>
</li>
<li><p><strong>先执行在判断，至少执行一次</strong></p>
</li>
</ul>
<h4 id="多重循环控制"><a href="#多重循环控制" class="headerlink" title="多重循环控制"></a>多重循环控制</h4><p>介绍</p>
<ul>
<li><p>将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do.while 均可以作为外层循环和内层循环</p>
</li>
<li><p>嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内层盾环，才可结束外层的当次循环，开始下一次的循环</p>
</li>
<li><p>设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行m*n 次</p>
</li>
</ul>
<h3 id="跳转控制break"><a href="#跳转控制break" class="headerlink" title="跳转控制break"></a>跳转控制break</h3><p>基本介绍</p>
<ul>
<li>break语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for,while,do while]</li>
</ul>
<p>注意事项和细节</p>
<ul>
<li><p>break 语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块 </p>
</li>
<li><p>标签的基本使用</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label1:{......</span><br><span class="line">  label2:{</span><br><span class="line">  	break label1;</span><br><span class="line">  }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="跳转控制continue"><a href="#跳转控制continue" class="headerlink" title="跳转控制continue"></a>跳转控制continue</h3><p>基本介绍</p>
<ul>
<li><p>continue 语句用于结束本次循环，继续执行下一次循环 </p>
</li>
<li><p>continue 语句出现在多层嵌套的福环语句体中时，可以通过标签指明要跳过的是哪一层循环</p>
</li>
</ul>
<p>注意事项和细节</p>
<ul>
<li><p>continue 语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块 </p>
</li>
<li><p>标签的基本使用</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label1:{......</span><br><span class="line">  label2:{</span><br><span class="line">  	continue label1;</span><br><span class="line">  }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="跳转控制return"><a href="#跳转控制return" class="headerlink" title="跳转控制return"></a>跳转控制return</h3><p>基本介绍</p>
<ul>
<li>return 使用在方法，表示跳出所在的方法</li>
</ul>
<h2 id="数组、排序、查找"><a href="#数组、排序、查找" class="headerlink" title="数组、排序、查找"></a>数组、排序、查找</h2><h3 id="数组⭐️"><a href="#数组⭐️" class="headerlink" title="数组⭐️"></a>数组⭐️</h3><h4 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h4><ul>
<li><p><strong>数组是一个容器，是一个用来存储指定数据类型的多个元素的容器</strong></p>
<ul>
<li>这多个变量的数据类型要一致</li>
</ul>
</li>
<li><p>数组是一个定长容器，一旦实例化完成，长度不能修改</p>
</li>
</ul>
<h4 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h4><ul>
<li><p>数组长度: 指的就是这个容器的容量, 表示这个数组中能存储多少个数据</p>
</li>
<li><p>元素:  指的就是数组中存储的数据</p>
</li>
<li><p>下标: 某一个元素在数组中的一个位置索引</p>
</li>
<li><p>遍历数组: 依次获取到数组中的每一个元素</p>
</li>
</ul>
<h4 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h4><p>格式</p>
<ul>
<li><p>数据类型[] 数组名;</p>
</li>
<li><p>数据类型 数组名[];</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:int[] a; 定义一个int类型的数组，数组名是a</span><br><span class="line">B:int a[]; 定义一个int类型的变量，变量名是a数组</span><br></pre></td></tr></tbody></table></figure>



<h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><ul>
<li><p><strong>Java中的数组必须先初始化,然后才能使用</strong></p>
</li>
<li><p>所谓初始化</p>
<ul>
<li>就是为数组中的数组元素<strong>分配内存空间</strong>，并为每个数组元素赋值</li>
</ul>
</li>
</ul>
<h5 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h5><ul>
<li>初始化时只指定数组长度，由系统为数组分配初始值</li>
</ul>
<p>注意：</p>
<ul>
<li>数组元素的类型是基本类型中的整数类型（byte、short、int 和 long），则数组元素的初始化值是 0</li>
<li>数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的初始化值是 0.0</li>
<li>数组元素的类型是基本类型中的字符类型（char），则数组元素的初始化值是‘\u0000’</li>
<li>数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的初始化值是 false</li>
<li>数组元素的类型是引用类型（类、接口和数组），则数组元素的初始化值是 null</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//格式：数据类型[] 数组名 = new 数据类型[数组长度];</span><br><span class="line">//数组长度其实就是数组中元素的个数。</span><br><span class="line">//定义了一个int类型的数组，这个数组中可以存放3个int类型的值。</span><br><span class="line">//数组元素的初始化值为0</span><br><span class="line">int[] arr = new int[3];</span><br><span class="line">for (int elem : arr) {</span><br><span class="line">    System.out.println(elem);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h5><ul>
<li>初始化时指定数组元素，即给出初始化值，由系统决定长度</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] number = new int[]{1, 2, 3, 5, 8};</span><br><span class="line">int[] number = {1,2,3,5,8};</span><br></pre></td></tr></tbody></table></figure>



<h4 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h4><ul>
<li>数组名<code>[下标/索引]</code>，下标从0开始</li>
</ul>
<h4 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</li>
<li>使用数组的步骤<ul>
<li>声明数组并开辟空间 </li>
<li>给数组各个元素赋值 </li>
<li>使用数组</li>
</ul>
</li>
<li>数组的下标是从0开始的</li>
<li>数组下标必须在指定范围内使用，否则报：下标越界异常</li>
<li>数组属引用类型，数组型数据是对象(object)</li>
</ul>
<h4 id="数组赋值机制"><a href="#数组赋值机制" class="headerlink" title="数组赋值机制"></a>数组赋值机制</h4><ul>
<li>数组在<strong>默认情況下是引用传递</strong>，赋的值是地址</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr1 = {1,2,3};</span><br><span class="line">int arr2 = arr1;</span><br><span class="line">arr2[0] = 10;  //arr1[0]=10</span><br></pre></td></tr></tbody></table></figure>

<h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a><strong>数组拷贝</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] arr1 = {1,2,3};</span><br><span class="line">int[] arr2 = new int[arr1.length];</span><br><span class="line">for (int i = 0;i &lt; arr1.length;i++){</span><br><span class="line">  arr2[i] = arr1[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a><strong>数组反转</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayReverse01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] arr = {11,22,33,44,55,66};</span><br><span class="line">        int temp = 0,len = arr.length;</span><br><span class="line">        for (int i = 0;i &lt; len/2;i++){</span><br><span class="line">            temp = arr[len-1-i];</span><br><span class="line">            arr[len-1-i] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        }</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++){</span><br><span class="line">            System.out.print(arr[i]+"\t");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>逆序赋值</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayReverse02 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] arr1 = {11,22,33,44,55,66};</span><br><span class="line">        int[] arr2 = new int[arr1.length];</span><br><span class="line">        int len = arr1.length;</span><br><span class="line">        for(int i = len-1;i &gt;= 0;i--){</span><br><span class="line">            arr2[len-i-1] = arr1[i];</span><br><span class="line">        }</span><br><span class="line">        arr1 = arr2;//arr1指向arr2数据空间，此时arr原来的数据空间没有变量引用，会被当作垃圾销毁</span><br><span class="line">        for(int i = 0;i &lt; arr1.length;i++) {</span><br><span class="line">            System.out.print(arr1[i] + "\t");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="数组添加"><a href="#数组添加" class="headerlink" title="数组添加"></a><strong>数组添加</strong></h4><h5 id="静态添加"><a href="#静态添加" class="headerlink" title="静态添加"></a><strong>静态添加</strong></h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayAdd01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] arr = {1,2,3};</span><br><span class="line">        int[] arr2 = new int[arr.length+1];</span><br><span class="line">        for (int i = 0;i &lt; arr.length;i++){</span><br><span class="line">            arr2[i] = arr[i];</span><br><span class="line">        }</span><br><span class="line">        arr2[arr2.length-1] = 4;</span><br><span class="line">        arr = arr2;</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++) {</span><br><span class="line">            System.out.print(arr[i] + "\t");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="动态添加"><a href="#动态添加" class="headerlink" title="动态添加"></a><strong>动态添加</strong></h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayAdd02 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Scanner myScanner = new Scanner(System.in);</span><br><span class="line">        double[] arr = {1,2,3};</span><br><span class="line">        do{</span><br><span class="line">            double[] arr2 = new double[arr.length+1];</span><br><span class="line">            for (int i = 0;i &lt; arr.length;i++) {</span><br><span class="line">                arr2[i] = arr[i];</span><br><span class="line">            }</span><br><span class="line">            System.out.println("请输入添加的元素");</span><br><span class="line">            double addNum = myScanner.nextInt();</span><br><span class="line">            arr2[arr2.length-1] = addNum;</span><br><span class="line">            arr = arr2;</span><br><span class="line">            for(int i = 0;i &lt; arr.length;i++) {</span><br><span class="line">                System.out.print(arr[i] + "\t");</span><br><span class="line">            }</span><br><span class="line">            System.out.println("是否继续添加 y/n");</span><br><span class="line">            char key = myScanner.next().charAt(0);</span><br><span class="line">            if(key == 'n'){</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }while (true);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="动态删减"><a href="#动态删减" class="headerlink" title="动态删减"></a><strong>动态删减</strong></h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayReduce01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Scanner myScanner = new Scanner(System.in);</span><br><span class="line">        int[] arr = {1,2,3,4,5};</span><br><span class="line">        while (true){</span><br><span class="line">            int[] arr2 = new int[arr.length-1];</span><br><span class="line">            for (int i = 0;i &lt; arr2.length;i++){</span><br><span class="line">                arr2[i] = arr[i];</span><br><span class="line">            }</span><br><span class="line">            arr = arr2;</span><br><span class="line">            for(int i = 0;i &lt; arr.length;i++) {</span><br><span class="line">                System.out.print(arr[i] + "\t");</span><br><span class="line">            }</span><br><span class="line">            System.out.println("请输入是否删除最后一个数字 yes/no");</span><br><span class="line">            char key = myScanner.next().charAt(0);</span><br><span class="line">            if(key == 'n'){</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>一维数组构成了二维数组</li>
</ul>
<h4 id="二维数组遍历"><a href="#二维数组遍历" class="headerlink" title="二维数组遍历"></a><strong>二维数组遍历</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TwoDimensionalArrary {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[][] arr = {{1,2,3},{4,5,6},{7,8,9}};</span><br><span class="line">        for (int i = 0;i &lt; arr.length;i++){</span><br><span class="line">            for (int j = 0;j &lt; arr[i].length;j++){</span><br><span class="line">                System.out.print(arr[i][j]+"\t");</span><br><span class="line">            }System.out.println();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="二维数组内存图"><a href="#二维数组内存图" class="headerlink" title="二维数组内存图"></a><strong>二维数组内存图</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071949421.png" alt="image-20221006142936848"></p>
<h4 id="注意事项和细节-2"><a href="#注意事项和细节-2" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>二维数组元素个数：arr.length</li>
<li>取出一维元素需要遍历两次</li>
<li>访问第(i+1)个一维数组的第(j+1)个值  arr [i] [j]</li>
</ul>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a><strong>使用方式</strong></h4><h5 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a><strong>动态初始化</strong></h5><ul>
<li>类型 数组名[] [] = new 类型 [大小] [大小]</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TwoDimensionalArrary02 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int arr[][] = new int[2][3];</span><br><span class="line">        arr[1][1] = 8;</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++){</span><br><span class="line">            for(int j = 0;j &lt; arr[i].length;j++){</span><br><span class="line">                System.out.print(arr[i][j]+" ");</span><br><span class="line">            }</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="动态初始化2"><a href="#动态初始化2" class="headerlink" title="动态初始化2"></a><strong>动态初始化2</strong></h5><p>先声明数组</p>
<ul>
<li>数据类型 数组名[] []; 例：<ul>
<li>int a[] [];</li>
</ul>
</li>
</ul>
<p>再创建数组</p>
<ul>
<li>数组名 = new 数据类型[大小] [大小]; 例：<ul>
<li>a = new int [2] [3];</li>
</ul>
</li>
</ul>
<h5 id="动态初始化-列数不确定"><a href="#动态初始化-列数不确定" class="headerlink" title="动态初始化-列数不确定"></a><strong>动态初始化-列数不确定</strong></h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TwoDimensionalArrary03 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[][] arr = new int[3][];//创建二维数组，只确定一维数组的个数，一维数组开没有开数据空间</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++){</span><br><span class="line">            arr[i] = new int[i+1];//给一维数组开空间</span><br><span class="line">            for (int j = 0; j &lt; arr[i].length;j++){</span><br><span class="line">                arr[i][j] = i+1;//给每一个一维数组元素赋值</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++){</span><br><span class="line">            for (int j = 0; j &lt; arr[i].length;j++){</span><br><span class="line">                System.out.print(arr[i][j]+" ");</span><br><span class="line">            }</span><br><span class="line">            System.out.println(" ");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//输出结果：1 22 333</span><br></pre></td></tr></tbody></table></figure>



<h5 id="静态初始化-1"><a href="#静态初始化-1" class="headerlink" title="静态初始化"></a>静态初始化</h5><p>语法</p>
<ul>
<li>类型 数组名<code>[] [] = {{值1,值2},{值1,值2},{值1,值2}} </code></li>
</ul>
<p>注意事项和细节</p>
<ul>
<li>一维数组声明方式：<code>int [] x 或者 int x []</code></li>
<li>二维数组声明方式：<code>int [] [] y 或者 int[] y [] 或者 int y [] []</code></li>
<li>二维数组实际上是由多个一维数组组成的，<strong>它的各个一维数组的长度可以相同，也可以不相同</strong></li>
</ul>
<h3 id="排序-基础"><a href="#排序-基础" class="headerlink" title="排序(基础)"></a>排序(基础)</h3><h4 id="排序分类"><a href="#排序分类" class="headerlink" title="排序分类"></a>排序分类</h4><ul>
<li><p>想需要处理的所有数据都加载到内部存储器中进行排序。</p>
<ul>
<li>包括(交换式排序法、选择式排序法和插入式排序法)</li>
</ul>
</li>
<li><p>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。</p>
<ul>
<li>包括(合并排序法和直接合并排序法)</li>
</ul>
</li>
</ul>
<p>5.3.2 冒泡排序</p>
<p><strong>定义</strong></p>
<ul>
<li>冒泡排序  (Bubble Sorting) 的基本思想是<ul>
<li>通过对待排序序列从后向前(从下标较大的元素开始)，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒</li>
</ul>
</li>
</ul>
<p><strong>冒泡排序特点</strong></p>
<ul>
<li><p>一共有n个元素</p>
</li>
<li><p>一共进行了n-1轮排序，可以看成是外层循</p>
</li>
<li><p>每1轮排序可以确定一个数的位置，比如第1轮排序确定最大数,第2轮排序，确定第2大的数位置，依次类推</p>
</li>
<li><p>当进行比较时，如果前面的数大于后面的数，就交换</p>
</li>
</ul>
<h3 id="查找-基础"><a href="#查找-基础" class="headerlink" title="查找(基础)"></a><strong>查找(基础)</strong></h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a><strong>顺序查找</strong></h4><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h4><h2 id="面向对象-基础"><a href="#面向对象-基础" class="headerlink" title="面向对象(基础)"></a>面向对象(基础)</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a><strong>类与对象</strong></h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>类是抽象的，概念的，代表一类事物,比如人类, 猫类…即它是数据类型</li>
<li>对象是具体的，实际的，代表一个具体事物，即是实例</li>
<li>类是对象的模板，对象是类的一个个体，对应一个实例</li>
</ul>
<h4 id="对象存在形式⭐️"><a href="#对象存在形式⭐️" class="headerlink" title="对象存在形式⭐️"></a><strong>对象存在形式⭐️</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061439172.png" alt="image-20221006143947024"></p>
<h4 id="属性-x2F-成员变量"><a href="#属性-x2F-成员变量" class="headerlink" title="属性/成员变量"></a>属性/成员变量</h4><h5 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul>
<li><p>从概念或叫法上看</p>
<ul>
<li>成员变量 = 属性 = field(字段)</li>
</ul>
</li>
<li><p>属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)，比如定义猫类 的 int age 就是属性</p>
</li>
</ul>
<h5 id="注意事项和细节-3"><a href="#注意事项和细节-3" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li><p>属性的定义语法同变量，示例：访问修饰符 属性类型 属性名 </p>
</li>
<li><p>访问修饰符：控制属性和访问范围，有四种访问修饰符 public,proctected,defaul,private </p>
</li>
<li><p>属性的定义类型可以为任意类型，包含基本类型或引用类型 </p>
</li>
<li><p>属性如果不赋值，有默认值，规则和数组一致:</p>
<ul>
<li>int0,short 0,byte 0, long 0</li>
<li>float 0.0,double 0.0 </li>
<li>char \u0000</li>
<li>boolean false</li>
<li>String null</li>
</ul>
</li>
</ul>
<h4 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h4><ul>
<li><strong>先声明在创建</strong></li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat;</span><br><span class="line">cat = new Cat();</span><br></pre></td></tr></tbody></table></figure>



<h5 id="对象创建流程分析⭐️⭐️"><a href="#对象创建流程分析⭐️⭐️" class="headerlink" title="对象创建流程分析⭐️⭐️"></a>对象创建流程分析⭐️⭐️</h5><ul>
<li><p>加载 Person 类信息(就是Person.class 且只加载一次) </p>
</li>
<li><p>在堆中分配空间(地址) </p>
</li>
<li><p>完成对象初始化 </p>
<ul>
<li><p>默认初始化 age = 0 name =null  </p>
</li>
<li><p>显示初始化 age = 90 name = null  </p>
</li>
<li><p>构造器初始化 age = 20 name = 小倩)</p>
</li>
</ul>
</li>
<li><p>在对象在堆中的地址返回给 P (P是对象名，是对象的引用)</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061447426.png" alt="image-20221006144745244"></p>
<h4 id="对象分配机制"><a href="#对象分配机制" class="headerlink" title="对象分配机制"></a><strong>对象分配机制</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">p1.age = 10;</span><br><span class="line">p1.name = "小明";</span><br><span class="line">Person p2 = p1//把p1赋给了p2，或让p2指向p1</span><br><span class="line">System.out.println(p2.age);</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061449738.png" alt="image-20221006144902621"></p>
<h4 id="Java内存结构分析"><a href="#Java内存结构分析" class="headerlink" title="Java内存结构分析"></a>Java内存结构分析</h4><ul>
<li><p>栈：一般存放基本数据类型(局部变量)</p>
</li>
<li><p>堆：存放对象(Cat cat，数组等)</p>
</li>
<li><p>方法区：常量池(常量，比如字符串)，类加载信息</p>
</li>
</ul>
<h4 id="Java创建对象流程"><a href="#Java创建对象流程" class="headerlink" title="Java创建对象流程"></a>Java创建对象流程</h4><ul>
<li><p>先加载Person类信息(<strong>属性和方法信息，只会加载一次</strong>) </p>
</li>
<li><p>在堆中分配空间，进行默认初始化(看规则) </p>
</li>
<li><p>把地址赋给 p，p 就指向对象 </p>
</li>
<li><p>行指定初始化，比如 p.name =” jack”  p.age = 10</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">p.name = "jack";</span><br><span class="line">p.age = 10;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="成员方法⭐️"><a href="#成员方法⭐️" class="headerlink" title="成员方法⭐️"></a>成员方法⭐️</h3><h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回数据类型 方法名(形参列表)  {</span><br><span class="line">	//方法体       </span><br><span class="line">	语句;       </span><br><span class="line">	return 返回值; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<p>解析</p>
<ul>
<li>形参列表：表示成员方法输入 callint n)</li>
<li>数据类型(返回类型)<ul>
<li>表示成员方法输出，void 表示没有返回值</li>
</ul>
</li>
<li>方法主体：表示为了实现某一功能代码块</li>
<li>return 语句不是必须的</li>
</ul>
<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Method01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Person p1 = new Person();</span><br><span class="line">        p1.speak();</span><br><span class="line">        p1.cal01();</span><br><span class="line">        p1.cal02(10);</span><br><span class="line">        int returnRes = p1.getSum(1,2);</span><br><span class="line">        System.out.println(returnRes);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Person{</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public void speak(){</span><br><span class="line">        System.out.println("你是一个猪");</span><br><span class="line">    }</span><br><span class="line">    public void cal01(){</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1;i &lt;= 1000;i++){</span><br><span class="line">            res += i;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    }</span><br><span class="line">    public void cal02(int n){</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1;i &lt;= n;i++){</span><br><span class="line">            res += i;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    }</span><br><span class="line">    public int getSum(int num1,int num2){</span><br><span class="line">        int res = num1 + num2;</span><br><span class="line">        return res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>解析</p>
<ul>
<li>public <ul>
<li>表示方法是公开</li>
</ul>
</li>
<li>void<ul>
<li>表示方法没有返回值</li>
</ul>
</li>
<li>speak()<ul>
<li>speak是方法名，()形参列表</li>
</ul>
</li>
<li>{}方法体<ul>
<li>可以写我们要执行的代码</li>
</ul>
</li>
<li>System.out.println(“”)<ul>
<li>表示我们的方法就是输出一句话</li>
</ul>
</li>
<li>p1.speak() 为调用</li>
</ul>
<h4 id="调用的内存机制"><a href="#调用的内存机制" class="headerlink" title="调用的内存机制"></a><strong>调用的内存机制</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int getSum(int num1,int num2){</span><br><span class="line">        int res = num1 + num2;</span><br><span class="line">        return res;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>public <ul>
<li>表示方法是公开的</li>
</ul>
</li>
<li>int <ul>
<li>表示方法执行后，返回一个 int 值</li>
</ul>
</li>
<li>getsum 方法名 </li>
<li>(int num1， int num2) <ul>
<li>形参列表，2个形参，可以接收用户传入的两个数</li>
</ul>
</li>
<li>5 return res<ul>
<li>表示把res 的值，返回</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210061457696.png" alt="image-20221006145724526"></p>
<h4 id="注意事项和细节-4"><a href="#注意事项和细节-4" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><ul>
<li>作用是控制方法使用的适用范围，若果不写则默认访问</li>
</ul>
<h5 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h5><ul>
<li><p>一个方法最多有一个返回值</p>
</li>
<li><p>返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)</p>
</li>
<li><p><strong>方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值;要求返回值类型必须和return的值类型一致或兼容</strong></p>
</li>
<li><p>如果方法是void，则方法体中可以没有return语句，或者 只写 return</p>
</li>
</ul>
<h5 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h5><ul>
<li>方法名遵循驼峰法则</li>
</ul>
<h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h5><ul>
<li><p>一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如 getSum(int n1,int n2) </p>
</li>
<li><p>参数类型可以为任意类型，包含基本类型或引用类型，比如 printArr(intlIl map) </p>
</li>
<li><p>调用参数的方法时，一定对应着参数列表传入相同类型或莱容类型 的参数 </p>
</li>
<li><p><strong>方法定义时的参数称为形式参数，简称形参；方法调用时的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致</strong></p>
</li>
</ul>
<h5 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h5><ul>
<li><p>里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用</p>
</li>
<li><p>里面不能再定义方法！即：<strong>方法不能嵌套定义</strong></p>
</li>
</ul>
<h5 id="方法调用细节"><a href="#方法调用细节" class="headerlink" title="方法调用细节"></a>方法调用细节</h5><ul>
<li><p>同一个类中的方法调用：直接调用即可</p>
</li>
<li><p>跨类中的方法 A 类调用 B 类方法：需要通过对象名调用</p>
</li>
<li><p>跨类的方法调用和方法的访问修饰符相关</p>
</li>
</ul>
<h3 id="成员方传法参机制⭐️⭐️"><a href="#成员方传法参机制⭐️⭐️" class="headerlink" title="成员方传法参机制⭐️⭐️"></a><strong>成员方传法参机制⭐️⭐️</strong></h3><h4 id="基本数据类型的传参数机制"><a href="#基本数据类型的传参数机制" class="headerlink" title="基本数据类型的传参数机制"></a><strong>基本数据类型的传参数机制</strong></h4><ul>
<li>传递的是值(拷贝)，形参的任何改变不影响实参</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071949393.png" alt="image-20221007182910593"></p>
<h4 id="引用数据类型的传参数机制"><a href="#引用数据类型的传参数机制" class="headerlink" title="引用数据类型的传参数机制"></a><strong>引用数据类型的传参数机制</strong></h4><ul>
<li>引用类型传递的是地址(传递也是值，但是值是地址)，可以通过形参影响实参</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071829590.png" alt="image-20221007182953355"></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li><strong>递归就是方法自己调用自己,每次调用时传入不同的变量</strong></li>
</ul>
<h4 id="递归调用内存机制"><a href="#递归调用内存机制" class="headerlink" title="递归调用内存机制"></a>递归调用内存机制</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Recursion01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        t1.test(5);</span><br><span class="line">        int res = t1.factorial(5);</span><br><span class="line">        System.out.println("res = "+ res);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class  T{</span><br><span class="line">    public void test(int n){</span><br><span class="line">        if(n &gt; 2){</span><br><span class="line">            test(n - 1);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int factorial(int n){</span><br><span class="line">        if(n == 1){</span><br><span class="line">            return 1;</span><br><span class="line">        }else {</span><br><span class="line">            return factorial(n - 1)*n;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071830340.png" alt="image-20221007183021205"></p>
<h4 id="注意事项和细节-5"><a href="#注意事项和细节-5" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响，比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组、对象)，就会共享该引用类型的数据</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕，栈空间回收</li>
</ul>
<h3 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载 (overload)"></a><strong>方法重载 (overload)</strong></h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>java 中允许同一个类中，多个同名方法的存在，但要求<strong>形参列表不一致</strong></li>
</ul>
<h4 id="注意事项和细节-6"><a href="#注意事项和细节-6" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><ul>
<li>方法名<ul>
<li>必须相同</li>
</ul>
</li>
<li>形参列表<ul>
<li>必须不同(参数类型、个数、顺序)</li>
</ul>
</li>
<li>返回类型<ul>
<li>无要求</li>
</ul>
</li>
</ul>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变参数</strong></h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><ul>
<li>java 允许将同一个类中多个同名同功能<strong>但参数个数不同</strong>的方法，封装成一个方法，通过可变参数实现</li>
</ul>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回类型 方法名(**数据类型...** 形参名){}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="注意事项和细节-7"><a href="#注意事项和细节-7" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>可变参数的实参可以为0个或任意多个</li>
<li>可变参数的实参可以为数组</li>
<li>可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li>
<li>一个形参列表中只能出现一个可变参数</li>
</ul>
<h3 id="变量作用域⭐️"><a href="#变量作用域⭐️" class="headerlink" title="变量作用域⭐️"></a><strong>变量作用域⭐️</strong></h3><h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><ul>
<li><p>主要的变量就是属性(成员变量)和局部变量</p>
</li>
<li><p>局部变量一般是指在成员方法中定义的变量</p>
</li>
<li><p>全局变量：也就是属性，作用域为整个类体</p>
</li>
<li><p>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</p>
</li>
<li><p><strong>全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值</strong></p>
</li>
</ul>
<h4 id="注意事项和细节-8"><a href="#注意事项和细节-8" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>全局变量和局部变量可以重名，访问时遵循就近原则</p>
</li>
<li><p>在同一个作用域中，两个局部变量，不能重名</p>
</li>
<li><p>全局变量生命周期长，伴随着对象的创建而创建，伴随着对象的销毁而销毁</p>
</li>
<li><p>局部变量生命周期短，伴随着它的代码块的执行而创建，伴随着代码块的结束而结束：即在一次方法调用过程中</p>
</li>
<li><p>作用域范围不同 全局变量/属性：可以被本类使用，或其他类使用(通过对象调用) 局部变量：只能在本类中对应的方法中使用</p>
</li>
<li><p>修饰符不同 全局变量/属性可以加修饰符 局部变量不可以加修饰符</p>
</li>
</ul>
<h4 id="两种调用方式"><a href="#两种调用方式" class="headerlink" title="两种调用方式"></a><strong>两种调用方式</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class VarScopeDetail {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        E e1 = new E();</span><br><span class="line">        e1.test();</span><br><span class="line"></span><br><span class="line">        Per p1 = new Per();</span><br><span class="line">        e1.test2(p1);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class E{</span><br><span class="line">    public void test(){</span><br><span class="line">        Per p1 = new Per();</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">    }</span><br><span class="line">    public void test2(Per p){//接收一个类</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Per{</span><br><span class="line">    String name = "jack";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="构造器⭐️"><a href="#构造器⭐️" class="headerlink" title="构造器⭐️"></a><strong>构造器⭐️</strong></h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对<strong>新对象的初始化</strong></li>
</ul>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法名 (行参列表){</span><br><span class="line">  方法体;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="注意事项和细节-9"><a href="#注意事项和细节-9" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><ul>
<li>修饰符可以默认 </li>
<li>一个类可以定义多个不同的构造器，即构造器重载 </li>
<li>构造器名和类名要相同 </li>
<li><strong>构造器没有返回值</strong> </li>
<li>构造器是完成对象的初始化，井不是创建对象 </li>
<li>在创建对象时,系统自动的调用该类的构造方法 </li>
<li><strong>如果没有定义构造器，系统会自动给类生成一个默认无参构造器</strong>(默认构造器) </li>
<li><strong>定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下</strong></li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Constructor01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Pers p1 = new Pers();</span><br><span class="line">        Pers p2 = new Pers("jack",80);</span><br><span class="line">        System.out.println(p1.name+p1.age);</span><br><span class="line">        System.out.println(p2.name+p2.age);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Pers{</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public Pers(){</span><br><span class="line">        System.out.println("构造器1被调用");</span><br><span class="line">        age = 18;</span><br><span class="line">    }</span><br><span class="line">    public Pers(String pName,int pAge){</span><br><span class="line">        System.out.println("构造器2被调用");</span><br><span class="line">        name = pName;</span><br><span class="line">        age = pAge;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>java虚拟机会给每个对象分配this，代表当前对象</li>
</ul>
<h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a><strong>内存分析</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071830533.png" alt="image-20221007183055402"></p>
<h4 id="注意事项和细节-10"><a href="#注意事项和细节-10" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><ul>
<li>this关键字可以用来访问本类的属性、方法、构造器</li>
<li>this用于区分当前类的属性和局部变量</li>
<li>访问成员方法的语法：this.方法名(参数列表);</li>
<li>访问构造器语法<ul>
<li>this(参数列表)：<strong>注意只能在构造器中使用(在构造器中访问另外一个构造器，必须放在第一条语句)</strong></li>
</ul>
</li>
<li>this不能在类定义的外部使用，只能在类定义的方法中使用</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ThisExercise01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        person p1 = new person("marry",20);</span><br><span class="line">        person p2 = new person("marry",20);</span><br><span class="line">        System.out.println(p1.compareTo(p2));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class person{</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public person(String name,int age){</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean compareTo(person p){</span><br><span class="line">        return this.name.equals(p.name) &amp;&amp; this.age == p.age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="面向对象-中级"><a href="#面向对象-中级" class="headerlink" title="面向对象(中级)"></a><strong>面向对象(中级)</strong></h2><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a><strong>IDEA</strong></h3><p><strong>常用快捷键</strong></p>
<ul>
<li><p>win + d  删除当前行</p>
</li>
<li><p>win + shift + 向下光标  向下复制当前行</p>
</li>
<li><p>shift + /  补全代码</p>
</li>
<li><p>win + /  注释</p>
</li>
<li><p>shift+enter  导入该行的类</p>
</li>
<li><p>win + shift + L  格式化代码</p>
</li>
<li><p>control + R  运行</p>
</li>
<li><p>shift + A  构造器</p>
</li>
<li><p>control + H 查看继承关系</p>
</li>
<li><p>win + B  定位方法</p>
</li>
<li><p>var  自动变量名</p>
</li>
<li><p>win + shift + T 环绕方式</p>
</li>
</ul>
<p>常用模块快捷键</p>
<ul>
<li><p>fori  遍历</p>
</li>
<li><p>itar  遍历数组</p>
</li>
<li><p>iter  增强遍历</p>
</li>
<li><p>sout  打印换行</p>
</li>
</ul>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>Package 包名</li>
</ul>
<h4 id="包的命名"><a href="#包的命名" class="headerlink" title="包的命名"></a>包的命名</h4><ul>
<li>只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字</li>
</ul>
<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><ul>
<li>小写字母＋小圆点一般是  com.公司名.项目名.业务模块名</li>
</ul>
<h4 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h4><ul>
<li><p>import java.uti Scanner；就只是引入一个类Scanner</p>
</li>
<li><p>import java.util*：1/ 表示将java.util 包所有都引入</p>
</li>
</ul>
<h4 id="注意事项和细节-11"><a href="#注意事项和细节-11" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一个package</p>
</li>
<li><p>import指令 位置放在package的下面，在类定义前面,可以有多句目没有顺序要求</p>
</li>
</ul>
<h3 id="访问修饰符-1"><a href="#访问修饰符-1" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>java提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限(范围)</li>
</ul>
<h4 id="访问权限⭐️⭐️"><a href="#访问权限⭐️⭐️" class="headerlink" title="访问权限⭐️⭐️"></a>访问权限⭐️⭐️</h4><ul>
<li><p>公开级别</p>
<ul>
<li>用public修饰,对外公开</li>
</ul>
</li>
<li><p>受保护级别</p>
<ul>
<li>用protected修饰，对子类和同一个包中的类公开</li>
</ul>
</li>
<li><p>默认级别</p>
<ul>
<li>没有修饰符号，向同一个包的类公开</li>
</ul>
</li>
<li><p>私有级别</p>
<ul>
<li>用private修饰,只有类本身可以访问，不对外公开</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>访问级别</th>
<th>访问修饰符</th>
<th>同类</th>
<th>同包</th>
<th>子类</th>
<th>不同包</th>
</tr>
</thead>
<tbody><tr>
<td>公开</td>
<td>public</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>受保护</td>
<td>protected</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>默认</td>
<td>无</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<h4 id="注意事项和细节-12"><a href="#注意事项和细节-12" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>修饰符可以用来修饰类中的属性，成员方法以及类</li>
<li><strong>只有默认的和public才能修饰类</strong>，并目遵循上述访问权限的特点</li>
<li>子类待定</li>
<li>成员方法的访问规则和属性完全样</li>
</ul>
<h3 id="封装⭐️"><a href="#封装⭐️" class="headerlink" title="封装⭐️"></a><strong>封装⭐️</strong></h3><h4 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作方法封装在一起数据被保护在内部，程序的其它部分只有通过被授权的操作（方法），才能对数据进行操作</li>
</ul>
<h4 id="封装步骤"><a href="#封装步骤" class="headerlink" title="封装步骤"></a><strong>封装步骤</strong></h4><ul>
<li>将属性进行私有化private【不能直接修改属性】</li>
<li>提供一个公共的(public)set方法，用于对属性判断井赋值 public void setxxx(类型 参数名){ 加入数据验证的业务逻辑; 属性 = 参数名;}</li>
<li>提供个公共的(public)get方法，用于获取属性的值 public 数据类型 getXxxx0{ return XX;}</li>
</ul>
<h3 id="继承⭐️"><a href="#继承⭐️" class="headerlink" title="继承⭐️"></a><strong>继承⭐️</strong></h3><h4 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>继承可以<strong>解决代码复用</strong>，当多个类存在相同的属性(变量)和方法时,可以以这些类中抽象出交类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可</li>
</ul>
<h4 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>class 子类 extends 父类{}</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071832706.png" alt="image-20221007183209452"></p>
<h4 id="注意事项和细节-13"><a href="#注意事项和细节-13" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问</li>
<li><strong>子类必须调用父类的构造器，完成父类的初始化</strong></li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</li>
<li>指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)</li>
<li>super在使用时，必须放在构造器第一行(super只能在构造器中使用)</li>
<li>super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li>
<li>java所有类都是Object类的子类</li>
<li>父类构造器的调用不限于直接父类！将一直往上追潮直到Object类</li>
<li>子类最多只能继承一个父类(指直接继承)，即<strong>java中是单继承机制</strong></li>
<li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public class TopBase { //父类是Object</span><br><span class="line"></span><br><span class="line">    public TopBase() {</span><br><span class="line">        //super(); Object的无参构造器</span><br><span class="line">        System.out.println("构造器TopBase() 被调用...");//1</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Base extends TopBase { //父类</span><br><span class="line">    //4个属性</span><br><span class="line">    public int n1 = 100;</span><br><span class="line">    protected int n2 = 200;</span><br><span class="line">    int n3 = 300;</span><br><span class="line">    private int n4 = 400;</span><br><span class="line"></span><br><span class="line">    public Base() { //无参构造器</span><br><span class="line">        System.out.println("父类Base()构造器被调用....");</span><br><span class="line">    }</span><br><span class="line">    public Base(String name, int age) {//有参构造器</span><br><span class="line">        //默认super()</span><br><span class="line">        System.out.println("父类Base(String name, int age)构造器被调用....");</span><br><span class="line">    }</span><br><span class="line">    public Base(String name) {//有参构造器</span><br><span class="line">        System.out.println("父类Base(String name)构造器被调用....");</span><br><span class="line">    }</span><br><span class="line">    //父类提供一个public的方法,返回了n4</span><br><span class="line">    public int getN4() {</span><br><span class="line">        return n4;</span><br><span class="line">    }</span><br><span class="line">    public void test100() {</span><br><span class="line">        System.out.println("test100");</span><br><span class="line">    }</span><br><span class="line">    protected void test200() {</span><br><span class="line">        System.out.println("test200");</span><br><span class="line">    }</span><br><span class="line">    void test300() {</span><br><span class="line">        System.out.println("test300");</span><br><span class="line">    }</span><br><span class="line">    private void test400() {</span><br><span class="line">        System.out.println("test400");</span><br><span class="line">    }</span><br><span class="line">    //call</span><br><span class="line">    public void callTest400() {</span><br><span class="line">        test400();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/输入ctrl + H 可以看到类的继承关系</span><br><span class="line">public class Sub extends Base { //子类</span><br><span class="line"></span><br><span class="line">    public Sub(String name, int age) {</span><br><span class="line">        //1. 调用父类的无参构造器, 如下或者 什么都不写,默认就是调用super()</span><br><span class="line">        //super();//父类的无参构造器</span><br><span class="line">        //2. 调用父类的 Base(String name) 构造器</span><br><span class="line">        //super("hsp");</span><br><span class="line">        //3. 调用父类的 Base(String name, int age) 构造器</span><br><span class="line">        super("king", 20);</span><br><span class="line"></span><br><span class="line">        //细节：super在使用时，必须放在构造器第一行</span><br><span class="line">        //细节: super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</span><br><span class="line">        //this() 不能再使用了</span><br><span class="line">        System.out.println("子类Sub(String name, int age)构造器被调用....");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Sub() {//无参构造器</span><br><span class="line">        //super(); //默认调用父类的无参构造器</span><br><span class="line">        super("smith", 10);</span><br><span class="line">        System.out.println("子类Sub()构造器被调用....");</span><br><span class="line">    }</span><br><span class="line">    //当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器</span><br><span class="line">    public Sub(String name) {</span><br><span class="line">        super("tom", 30);</span><br><span class="line">        //do nothing...</span><br><span class="line">        System.out.println("子类Sub(String name)构造器被调用....");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void sayOk() {//子类方法</span><br><span class="line">        //非私有的属性和方法可以在子类直接访问</span><br><span class="line">        //但是私有属性和方法不能在子类直接访问</span><br><span class="line">        System.out.println(n1 + " " + n2 + " " + n3);</span><br><span class="line">        test100();</span><br><span class="line">        test200();</span><br><span class="line">        test300();</span><br><span class="line">        //test400();错误</span><br><span class="line">        //要通过父类提供公共的方法去访问</span><br><span class="line">        System.out.println("n4=" + getN4());</span><br><span class="line">        callTest400();//</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="继承本质"><a href="#继承本质" class="headerlink" title="继承本质"></a>继承本质</h4><ul>
<li>子对象创建完成，建立查找关系</li>
</ul>
<h4 id="继承内存图"><a href="#继承内存图" class="headerlink" title="继承内存图"></a>继承内存图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071833402.png" alt="image-20221007183305242"></p>
<h3 id="多态⭐️⭐️"><a href="#多态⭐️⭐️" class="headerlink" title="多态⭐️⭐️"></a>多态⭐️⭐️</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础之上的</li>
</ul>
<h4 id="多态具体体现"><a href="#多态具体体现" class="headerlink" title="多态具体体现"></a>多态具体体现</h4><h5 id="方法的多态"><a href="#方法的多态" class="headerlink" title="方法的多态"></a>方法的多态</h5><ul>
<li>重写和重载就是体现多态</li>
</ul>
<h5 id="对象的多态"><a href="#对象的多态" class="headerlink" title="对象的多态"></a><strong>对象的多态</strong></h5><ul>
<li><p>一个对象的编译类型和运行类型可以不一致</p>
</li>
<li><p>编译类型在定义对象时，就确定了，不能改变</p>
</li>
<li><p>运行类型是可以变化的</p>
</li>
<li><p><strong>编译类型看定义时 = 号 的左边，运行类型看 = 号的 右边</strong></p>
</li>
</ul>
<h6 id="注意事项和细节-14"><a href="#注意事项和细节-14" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h6><h6 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h6><ul>
<li><p>本质</p>
<ul>
<li>父类的引用指向了子类的对象</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>父类类型 引用名 = new 子类类型();</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>编译类型看左边，运行类型看右边</li>
</ul>
</li>
<li><p>可以调用父类中的所有成员(需遵守访问权限)</p>
</li>
<li><p>不能调用子类特有成员</p>
</li>
<li><p>最终运行效果看子类的具体实现</p>
</li>
</ul>
<h6 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h6><ul>
<li><p>本质</p>
<ul>
<li>把指向子类对象的父类引用，转成子类对象的子类引用</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>子类类型 引用名 = (子类类型) 父类引用;</li>
</ul>
</li>
<li><p><strong>只能强转父类引用，不能强转父类对象</strong></p>
</li>
<li><p>父类的引用必须指向的是当前目标类型的对象</p>
</li>
<li><p>当向下转型后，可以调用子类类型中所有的成员</p>
</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li>属性没有重写，属性的值看编译类型</li>
<li><strong>instance of 比较较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型</strong></li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">             //语法：父类类型引用名 = new 子类类型();</span><br><span class="line">             Animal animal = new Cat();</span><br><span class="line">             Object obj = new Cat();//可以吗? 可以 Object 也是 Cat的父类</span><br><span class="line">     </span><br><span class="line">             //向上转型调用方法的规则如下:</span><br><span class="line">             //(1)可以调用父类中的所有成员(需遵守访问权限)</span><br><span class="line">             //(2)但是不能调用子类的特有的成员</span><br><span class="line">             //(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的</span><br><span class="line">             //animal.catchMouse();错误</span><br><span class="line">             //(4)最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法</span><br><span class="line">             //，然后调用，规则我前面我们讲的方法调用规则一致。</span><br><span class="line">             animal.eat();//猫吃鱼..</span><br><span class="line">             animal.run();//跑</span><br><span class="line">             animal.show();//hello,你好</span><br><span class="line">             animal.sleep();//睡</span><br><span class="line">     </span><br><span class="line">             //可以调用Cat的 catchMouse方法</span><br><span class="line">             //多态的向下转型</span><br><span class="line">             //(1)语法：子类类型 引用名 =（子类类型）父类引用;</span><br><span class="line">             //问一个问题? cat 的编译类型 Cat,运行类型是 Cat</span><br><span class="line">             Cat cat = (Cat) animal;</span><br><span class="line">             cat.catchMouse();//猫抓老鼠</span><br><span class="line">             //(2)要求父类的引用必须指向的是当前目标类型的对象</span><br><span class="line">             Dog dog = (Dog) animal; //可以吗？</span><br><span class="line">     </span><br><span class="line">             System.out.println("ok~~");</span><br><span class="line">         }</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure>

<pre><code> <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyDetail02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//属性没有重写之说！属性的值看编译类型</span></span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();<span class="comment">//向上转型</span></span><br><span class="line">        System.out.println(base.count);<span class="comment">// ？ 看编译类型 10</span></span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(sub.count);<span class="comment">//?  20</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> { <span class="comment">//父类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//属性</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> {<span class="comment">//子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//属性</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
  
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyDetail03</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        System.out.println(bb <span class="keyword">instanceof</span>  BB);<span class="comment">// true</span></span><br><span class="line">        System.out.println(bb <span class="keyword">instanceof</span>  AA);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//aa 编译类型 AA, 运行类型是BB</span></span><br><span class="line">        <span class="comment">//BB是AA子类</span></span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        System.out.println(aa <span class="keyword">instanceof</span> AA);</span><br><span class="line">        System.out.println(aa <span class="keyword">instanceof</span> BB);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> AA);<span class="comment">//false</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"hello"</span>;</span><br><span class="line">        <span class="comment">//System.out.println(str instanceof AA);</span></span><br><span class="line">        System.out.println(str <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> {} <span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">AA</span> {}<span class="comment">//子类</span></span><br></pre></td></tr></tbody></table></figure>
</code></pre>
<h4 id="动态绑定机制⭐️⭐️"><a href="#动态绑定机制⭐️⭐️" class="headerlink" title="动态绑定机制⭐️⭐️"></a>动态绑定机制⭐️⭐️</h4><ul>
<li>当调用对象方法的时候，该方法会和该对象的内存地址/<strong>运行类型</strong>绑定</li>
<li>当调用对象属性时，没有动态綁定机制，哪里声明，那里使用()</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;<span class="comment">//当子类不存在sum方法时，会从父类找到sum方法，但动态绑定机制会找到子类的getI返回i值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a><strong>多态的应用</strong></h4><h5 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h5><ul>
<li>多态数组<ul>
<li>定义类型为父类类型，里面保存的实际元素类型为子类类型</li>
</ul>
</li>
<li>多态参数<ul>
<li>方法定义的形参类型为父类类型，实参类型允许为子类类型</li>
</ul>
</li>
</ul>
<h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>super 代表父类的引用，用于访问父类的属性、方法、构造器</li>
</ul>
<h4 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>访问父类的属性，但不能访问父类的 private 属性 super.属性名</li>
<li>访问父类的方法，不能访问父类的 private 方法 super.方法名(参数列表)</li>
<li>访问父类的构造器(只能放在构造器的第一句，只能出现一句) super(参数列表)</li>
</ul>
<h4 id="注意事项和细节-15"><a href="#注意事项和细节-15" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>调用父类的构造器的好处 (分工明确，父类属性由父类初始化，子类的属性由子类初始化)</li>
<li>当子类中有和父类中的成员(属性和方法) 重名时，为了访问父类的成员，必须通过super，如果没有重名，使用super、this、 直接访问效果相同</li>
<li><strong>super的访问不限于直接父类</strong>，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类(上级类)中都有同名的成员，使用super访问遵循就近原则</li>
</ul>
<h4 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a><strong>super和this</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071835631.png" alt="image-20221007183503501"></p>
<h3 id="方法重写-overwrite"><a href="#方法重写-overwrite" class="headerlink" title="方法重写(overwrite)"></a><strong>方法重写(overwrite)</strong></h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>子类的方法和父类方法一致，那么子类的方法覆盖了父类的方法</li>
</ul>
<h4 id="注意事项和细节-16"><a href="#注意事项和细节-16" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><strong>子类的方法的形参列表,方法名称，要和父类方法的形参列表,方法名称完全一样</strong></li>
<li><strong>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类</strong></li>
<li><strong>子类方法大于等于父类方法的访问权限</strong></li>
</ul>
<p>实例</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Base { //父类是Object</span><br><span class="line"></span><br><span class="line">    public int n1 = 999;</span><br><span class="line">    public int age = 111;</span><br><span class="line">    public void cal() {</span><br><span class="line">        System.out.println("Base类的cal() 方法...");</span><br><span class="line">    }</span><br><span class="line">    public void eat() {</span><br><span class="line">        System.out.println("Base类的eat().....");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a><strong>Object类</strong></h3><ul>
<li>常见的方法</li>
</ul>
<h4 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="=="></a>==</h4><ul>
<li>既可以判断基本类型，又可以判断引用类型 </li>
<li>如果判断基本类型，判断的是值是否相等 </li>
<li><strong>如果判断引用类型，判断的是地址是否相等</strong>，即判定是不是同一个对象</li>
</ul>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><ul>
<li>equals:是 Object 类中的方法，<strong>只能判断引用类型</strong></li>
<li>默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等</li>
</ul>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><ul>
<li><p><strong>提高具有哈希结构的容器的效率</strong></p>
</li>
<li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</p>
</li>
<li><p>两个引用，如果指向的是不同对象，则哈希值是不一样的</p>
</li>
<li><p>哈希值主要根据地址号来的，不能完全将哈希值等价子地址</p>
</li>
<li><p>后面在集合中 hashCode 如果需要的话，也会重写</p>
</li>
</ul>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><ul>
<li><p>默认返回：全类名＋@+哈希值的十六进制</p>
</li>
<li><p>子类往往重写 to String 方法，用于返回对象的属性信息</p>
</li>
<li><p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式</p>
</li>
<li><p>当直接输出一个对象时，toString  方法会被默认的调用</p>
</li>
</ul>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><ul>
<li><p>当对象被回收时，系统自动调用该对象的  finalize 方法。子类可以重写该方法，做一些释放资源的操作</p>
</li>
<li><p>什么时候被回收</p>
<ul>
<li>当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法</li>
</ul>
</li>
<li><p>垃圾回收机制的调用，是由系统来決定(即有自己的GC算法)，也可以通过System.gc() 主动触发垃圾回收机制</p>
</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a><strong>断点调试</strong></h3><h4 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug</li>
</ul>
<h4 id="注意事项和细节-17"><a href="#注意事项和细节-17" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>在断点调试 过程中，是运行状态，是以对象的运行类型来执行的</p>
</li>
<li><p>F7：跳入方法内</p>
</li>
<li><p>F8：逐行执行代码 shift+F8:跳出方法</p>
</li>
<li><p>F9：resume，执行到下一个断点</p>
</li>
</ul>
<h2 id="面向对象-高级"><a href="#面向对象-高级" class="headerlink" title="面向对象(高级)"></a><strong>面向对象(高级)</strong></h2><h3 id="类变量和类方法⭐️"><a href="#类变量和类方法⭐️" class="headerlink" title="类变量和类方法⭐️"></a><strong>类变量和类方法⭐️</strong></h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a><strong>类变量</strong></h4><h5 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul>
<li>类变量也叫<strong>静态变量/静态属性</strong>，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量</li>
</ul>
<h5 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 static 数据类型 变量名;</span><br><span class="line">static 访问修饰符 数据类型 变量名;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="如何访问类变量"><a href="#如何访问类变量" class="headerlink" title="如何访问类变量"></a>如何访问类变量</h5><ul>
<li>类名.类变量名</li>
<li>对象名.类变量名</li>
</ul>
<p><strong>静态变量的访问修饰符的访问权限和范围和普通属性是一样的</strong></p>
<h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a><strong>内存布局</strong></h5><ul>
<li>略</li>
</ul>
<h5 id="注意事项和细节-18"><a href="#注意事项和细节-18" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量(静态变量)</li>
<li>类变量是该类的所有对象共享的，而实例变量是每个对象独享的</li>
<li>加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量</li>
<li>类变量可以通过 <ul>
<li>类名.类变量名 或者 对象名.类变量名 来访问</li>
</ul>
</li>
<li>实例变量不能通过 类名.类变量名 方式访问</li>
<li>类变量是在类加载时就初始化</li>
<li>类变量的生命周期是随类的加载开始，随着类消亡而销毁</li>
</ul>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a><strong>类方法</strong></h4><h5 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul>
<li>类方法也叫静态方法</li>
</ul>
<h5 id="基本语法-6"><a href="#基本语法-6" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 static 数据返回类型 方法名(){};</span><br><span class="line">static 访问修饰符 数据返回类型 方法名(){};</span><br></pre></td></tr></tbody></table></figure>

<h5 id="类方法调用"><a href="#类方法调用" class="headerlink" title="类方法调用"></a>类方法调用</h5><ul>
<li>类名.类方法名</li>
<li>对象名.类方法名</li>
</ul>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法,提高开发效率</p>
</li>
<li><p>程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用</p>
</li>
</ul>
<h5 id="注意事项和细节-19"><a href="#注意事项和细节-19" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li><p><strong>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区</strong></p>
<ul>
<li>类方法中无 this 的参数，普通方法中隐含着 this 的参数</li>
</ul>
</li>
<li><p>类方法可以通过类名调用，也可以通过对象名调用</p>
</li>
<li><p>音通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用</p>
</li>
<li><p>类方法中不允许使用和对象有关的关键字，比如this和super</p>
</li>
<li><p><strong>静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员</strong></p>
</li>
</ul>
<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a><strong>main方法</strong></h3><h4 id="深入理解main方法"><a href="#深入理解main方法" class="headerlink" title="深入理解main方法"></a><strong>深入理解main方法</strong></h4><ul>
<li>java虛拟机需要调用类的 main() 方法，所以该方法的访问权限化须是 public</li>
<li>java虚拟机在执行 main() 方法时不必创建对象，所以该方法心须是 static</li>
<li>该方法接收 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数</li>
<li>java 执行的程序 参数1 参数2 参数3</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071835730.png" alt="image-20221007183555627"></p>
<h4 id="注意事项和细节-20"><a href="#注意事项和细节-20" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>在 main() 方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性</li>
<li>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的目标静态成员</li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h3><h4 id="基本介绍-17"><a href="#基本介绍-17" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>代码化块又称为初始化块,属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过们包围起来</li>
<li>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用</li>
</ul>
<h4 id="基本语法-7"><a href="#基本语法-7" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]{</span><br><span class="line">  代码;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h5><ul>
<li><p>修饰符 可选，要写的话，也只能写 static</p>
</li>
<li><p>代码块分为两类，使用static 修饰的叫静态代码块，没有static修饰的，叫普通代码块</p>
</li>
<li><p>逻辑语句可以为任何逻辑语句</p>
</li>
<li><p>号可以写上，也可以省略</p>
</li>
</ul>
<h4 id="注意事项和细节-21"><a href="#注意事项和细节-21" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p><strong>static 代码块是类加载时执行，且只会执行一次</strong></p>
</li>
<li><p>普通代码块是在创建对象的调用的，创建一次，调用一次</p>
</li>
<li><p>类什么时候被加载⭐️⭐️： </p>
<ul>
<li><p>创建对象实例时</p>
</li>
<li><p>创建子类对象实例时，父类也会被加载</p>
</li>
<li><p>使用类的静态成员时</p>
</li>
</ul>
</li>
<li><p><strong>创建一个对象时，在一个类的调用顺序</strong> </p>
<ul>
<li><p>调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调</p>
</li>
<li><p>调用普通代码块和普通属性的初始化(注意：普通代码块和普通属性初始化调用的优先级一样，若果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)</p>
</li>
<li><p>调用构造器</p>
</li>
</ul>
</li>
<li><p>构造方法(构造器)的最前面其实隐含了 super()和调用普通代码块</p>
</li>
<li><p>创建子类时顺序⭐️⭐️： </p>
<ul>
<li><p>父类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p>
</li>
<li><p>子类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p>
</li>
<li><p>父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p>
</li>
<li><p>父类构造方法</p>
</li>
<li><p>子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p>
</li>
<li><p>子类构造方法</p>
</li>
</ul>
</li>
<li><p>静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员</p>
</li>
</ul>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a><strong>单例设计模式</strong></h3><h4 id="基本介绍-18"><a href="#基本介绍-18" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法 </li>
<li>单例模式有两种方式<ul>
<li>饿汉式 </li>
<li>懒汉式</li>
</ul>
</li>
</ul>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><ul>
<li><p>构造器私有化 </p>
</li>
<li><p>类的内部创建静态对象 </p>
</li>
<li><p>向外暴露一个静态公共方法 </p>
</li>
<li><p>特点：在类加载的时候就创建对象实例，可能存在资源浪费</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private static GirlFriend gf = new GirlFriend("新野");</span><br><span class="line"></span><br><span class="line">    private GirlFriend(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static GirlFriend Instance() {</span><br><span class="line">        return gf;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul>
<li>构造器私有化 </li>
<li>定义一个 static 静态属性对象 </li>
<li>提供一个 public 的 static 方法，返回一个对象 </li>
<li>只有当使用(3)的方法时，才返回对象，再次调用时，返回上次创建的对象 </li>
<li>特点：线程安全问题</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Cat{</span><br><span class="line">    private String name;</span><br><span class="line">    private static Cat cat;</span><br><span class="line"></span><br><span class="line">    private Cat(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static Cat getInstance(){</span><br><span class="line">        if(cat == null){</span><br><span class="line">            cat = new Cat("小花");</span><br><span class="line">        }</span><br><span class="line">        return cat;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>最主要的区别在于创建对象的时机不同<ul>
<li>饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li>
</ul>
</li>
<li>饿汉式不存在线程安全问题，而懒汉式存在线程安全问题</li>
<li>饿汉式存在浪费姿源的可能，对象实例都没有使用，那么饿汉式创建的对象就浪费，懒汉式是使用时才创建，就不存在这个问题</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a><strong>final</strong></h3><h4 id="基本介绍-19"><a href="#基本介绍-19" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><p>final 可以修饰类、属性、方法、局部变量 </p>
</li>
<li><p>final 类</p>
<ul>
<li>类不能被继承</li>
</ul>
</li>
<li><p>final 方法</p>
<ul>
<li>子类无法重写方法</li>
</ul>
</li>
<li><p>final 属性</p>
<ul>
<li>属性无法被修改</li>
</ul>
</li>
<li><p>final 局部变量</p>
<ul>
<li>局部变量无法被修改</li>
</ul>
</li>
</ul>
<h4 id="注意事项和细节-22"><a href="#注意事项和细节-22" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>final 修饰的属性又叫常量，一般用XX_XX_XX 来命名</p>
</li>
<li><p>final 修饰的属性在定义时,必须赋初值,并且以后不能再修改，赋值可以在如下位置： 定义时、构造器、代码块</p>
</li>
<li><p>final 修饰的属性是静态的，则初始化的位置只能是 定义时、静态代码块</p>
</li>
<li><p>final 类不能继承，但可以实例化对象</p>
</li>
<li><p>如果类不是 final 类，但是含有 final 方法，则该方法虽然不能重写，但是可以被继承</p>
</li>
<li><p>如果一个类已经是 final 类了，就没有必要再将方法修饰成 final 方法</p>
</li>
<li><p>final不能修饰构造器本身</p>
</li>
<li><p>final 和 static 往往搭配使用，效率更高，不会导致类加载-底层编译器做了优化处理</p>
</li>
<li><p>包装类(Integer, Double,Float,Boolean等都是final)，String也是final类</p>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h3><h4 id="基本介绍-20"><a href="#基本介绍-20" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>用 abstract 关键字来修饰一个类时,这个类就叫抽象类 </li>
<li>用abstract 关键字来修饰一个方法时,这个方法就是抽象方法，没有方法体 </li>
<li><strong>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类</strong></li>
</ul>
<h4 id="注意事项和细节-23"><a href="#注意事项和细节-23" class="headerlink" title="注意事项和细节"></a><strong>注意事项和细节</strong></h4><ul>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含 abstract 方法。也就是说,抽象类可以没有 abstract 方法</li>
<li>一旦类包含了 abstract 方法,则这个类必须声明为 abstract</li>
<li>abstract 只能修饰类和方法</li>
<li>抽象类可以有任意成员，抽象类本质还是类</li>
<li>抽象方法不能有主体</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有的抽象方法，除非它自己也声明为 abstract 类</li>
<li>抽象方法不能使用 private 、final 和 static 来修饰，因为这些关键字都是和重写相违背的</li>
</ul>
<h4 id="抽象类模版设计模式"><a href="#抽象类模版设计模式" class="headerlink" title="抽象类模版设计模式"></a>抽象类模版设计模式</h4><p>实例</p>
<ul>
<li>编写方法cal()，可以计算某段代码的耗时时间</li>
<li>b写抽象方法job()</li>
<li>编写一个子类A,继承抽象类Template，井实现job方法</li>
<li>编写一个测试类TestTemplate,看看是否好用</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class TextTemplate {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        A a = new A();</span><br><span class="line">        a.cal();</span><br><span class="line"></span><br><span class="line">        B b = new B();</span><br><span class="line">        b.cal();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">abstract public class Template {</span><br><span class="line"></span><br><span class="line">    public abstract void job();</span><br><span class="line"></span><br><span class="line">    public void cal() {</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            job();</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println("时间" + (end - start));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A extends Template{</span><br><span class="line"></span><br><span class="line">    public void job() {</span><br><span class="line">        long num = 0;</span><br><span class="line">        for (long i = 0; i &lt;= 10000000; i++) {</span><br><span class="line">            num += i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class B extends Template{</span><br><span class="line"></span><br><span class="line">    public void job() {</span><br><span class="line">        long num = 0;</span><br><span class="line">        for (long i = 0; i &lt;= 10000000; i++) {</span><br><span class="line">            num *= i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="接口⭐️"><a href="#接口⭐️" class="headerlink" title="接口⭐️"></a><strong>接口⭐️</strong></h3><h4 id="基本介绍-21"><a href="#基本介绍-21" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>接口就是给出一些没有实现的方法,封装到一起,到某个类要使用的时候,再根据具体情况把这些方法写出来</li>
</ul>
<h4 id="基本语法-8"><a href="#基本语法-8" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名{</span><br><span class="line">  //属性</span><br><span class="line">  //方法</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class 类名 implements 接口 {</span><br><span class="line">  自己属性;</span><br><span class="line">  自己方法;</span><br><span class="line">  //必须实现接口的抽象方法</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>Jdk7.0 前接口里的所有方法都没有方法体(只能抽象方法)</li>
<li>Jdk8.0 后接口类可以有静态方法，defaut 实现方法，<strong>也就是说接口中可以有方法的具体实现</strong></li>
</ul>
<h4 id="注意事项和细节-24"><a href="#注意事项和细节-24" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>接口不能被实例化</p>
</li>
<li><p>接口中所有的方法是 public 和 abstract 方法，接口中抽象方法，可以不用 abstract 修饰</p>
</li>
<li><p>普通类实现接口，就必须将该接口的所有方法实现</p>
</li>
<li><p>抽象类实现接口，可以不用实现接口的方法</p>
</li>
<li><p>一个类同时可以实现多个接口</p>
</li>
<li><p>接口中的属性,只能是 final 的，而且是 public static final 修饰符</p>
</li>
<li><p>接口中属性的访问形式：接口名.属性名</p>
</li>
<li><p>一个接口不能继承其它的类,但是可以继承多个别的接口</p>
</li>
<li><p>接口的修饰符 只能是 public 和默认，这点和类的修饰符是一样的</p>
</li>
</ul>
<h4 id="实现接口VS继承类"><a href="#实现接口VS继承类" class="headerlink" title="实现接口VS继承类"></a>实现接口VS继承类</h4><ul>
<li><p>继承的价值主要在于</p>
<ul>
<li>解决代码的复用性和可维护性</li>
</ul>
</li>
<li><p>接口的价值主要在于</p>
<ul>
<li><strong>设计，设计好各种规范(方法)，让其它类去实现这些方法</strong></li>
</ul>
</li>
<li><p>接口比继承更加灵活，继承是满足 is -a的关系，而接口只需满足 like-a的关系</p>
</li>
<li><p>接口在一定程度上实现代码解耦</p>
</li>
</ul>
<h4 id="接口类型数组"><a href="#接口类型数组" class="headerlink" title="接口类型数组"></a><strong>接口类型数组</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class InterfacePolyArr {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        //多态数组 -&gt; 接口类型数组</span><br><span class="line">        Usb[] usbs = new Usb[2];</span><br><span class="line">        usbs[0] = new Phone_();</span><br><span class="line">        usbs[1] = new Camera_();</span><br><span class="line">        /*</span><br><span class="line">        给Usb数组中，存放 Phone 和 相机对象，Phone类还有一个特有的方法call（），</span><br><span class="line">        请遍历Usb数组，如果是Phone对象，除了调用Usb 接口定义的方法外，</span><br><span class="line">        还需要调用Phone 特有方法 call</span><br><span class="line">         */</span><br><span class="line">        for(int i = 0; i &lt; usbs.length; i++) {</span><br><span class="line">            usbs[i].work();//动态绑定..</span><br><span class="line">            //和前面一样，我们仍然需要进行类型的向下转型</span><br><span class="line">            if(usbs[i] instanceof Phone_) {//判断他的运行类型是 Phone_</span><br><span class="line">                ((Phone_) usbs[i]).call();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface Usb{</span><br><span class="line">    void work();</span><br><span class="line">}</span><br><span class="line">class Phone_ implements Usb {</span><br><span class="line">    public void call() {</span><br><span class="line">        System.out.println("手机可以打电话...");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() {</span><br><span class="line">        System.out.println("手机工作中...");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">class Camera_ implements Usb {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() {</span><br><span class="line">        System.out.println("相机工作中...");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="内部类⭐️"><a href="#内部类⭐️" class="headerlink" title="内部类⭐️"></a>内部类⭐️</h3><h4 id="基本介绍-22"><a href="#基本介绍-22" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)</li>
<li>内部类最大的特点就是<strong>可以直接访问私有属性</strong>，井且可以<strong>体现类与类之间的包含关系</strong></li>
</ul>
<h4 id="基本语法-9"><a href="#基本语法-9" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Outer{//外部类</span><br><span class="line">  class Inner{//内部类</span><br><span class="line">    </span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">class Other{//外部其他类</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h4><ul>
<li>定义在外部类局部位置上<ul>
<li>局部类内部(有类名)</li>
<li>匿名局部类(没有类名⭐️)</li>
</ul>
</li>
<li>定义在外部类的成员位置上<ul>
<li>成员内部类(无static修饰)</li>
<li>静态内部类(static修饰)</li>
</ul>
</li>
</ul>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a><strong>局部内部类</strong></h4><h5 id="基本介绍-23"><a href="#基本介绍-23" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul>
<li>局部内部类是定义在外部类的局部位置，在方法中、代码块中，并且有类名</li>
</ul>
<h5 id="注意事项和细节-25"><a href="#注意事项和细节-25" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>可以直接访问外部类的所有成员，包含私有的 </li>
<li>不能添加访问修饰符,但是可以使用final修饰 </li>
<li>作用域：仅仅在定义它的方法或代码块中 </li>
<li>内部类访问外部类：直接访问 </li>
<li>外部类访问内部类：创建对象再访问 </li>
<li>外部其他类访问局部内部类：不能访问 </li>
<li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果访问外部类的成员使用”外部类名.this.成员”去访问</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInnerClass {//</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        //演示一遍</span><br><span class="line">        Outer02 outer02 = new Outer02();</span><br><span class="line">        outer02.m1();</span><br><span class="line">        System.out.println("outer02的hashcode=" + outer02);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Outer02 {//外部类</span><br><span class="line">    private int n1 = 100;</span><br><span class="line"></span><br><span class="line">    private void m2() {</span><br><span class="line">        System.out.println("Outer02 m2()");</span><br><span class="line">    }//私有方法</span><br><span class="line"></span><br><span class="line">    public void m1() {//方法</span><br><span class="line">        //1.局部内部类是定义在外部类的局部位置,通常在方法</span><br><span class="line">        //3.不能添加访问修饰符,但是可以使用final 修饰</span><br><span class="line">        //4.作用域 : 仅仅在定义它的方法或代码块中</span><br><span class="line">        final class Inner02 {//局部内部类(本质仍然是一个类)</span><br><span class="line">            //2.可以直接访问外部类的所有成员，包含私有的</span><br><span class="line">            private int n1 = 800;</span><br><span class="line"></span><br><span class="line">            public void f1() {</span><br><span class="line">                //5. 局部内部类可以直接访问外部类的成员，比如下面 外部类n1 和 m2()</span><br><span class="line">                //7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，</span><br><span class="line">                //   使用 外部类名.this.成员)去访问</span><br><span class="line">                //    Outer02.this 本质就是外部类的对象, 即哪个对象调用了m1, Outer02.this就是哪个对象</span><br><span class="line">                System.out.println("n1=" + n1 + " 外部类的n1=" + Outer02.this.n1);</span><br><span class="line">                System.out.println("Outer02.this hashcode=" + Outer02.this);</span><br><span class="line">                m2();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        //6. 外部类在方法中，可以创建Inner02对象，然后调用方法即可</span><br><span class="line">        Inner02 inner02 = new Inner02();</span><br><span class="line">        inner02.f1();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="匿名内部类⭐️⭐️"><a href="#匿名内部类⭐️⭐️" class="headerlink" title="匿名内部类⭐️⭐️"></a><strong>匿名内部类⭐️⭐️</strong></h4><h5 id="基本介绍-24"><a href="#基本介绍-24" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul>
<li>匿名内部类是定义在外部类的局部位置，比如方法中，<strong>并目没有类名</strong>，同时还是一个对象</li>
</ul>
<h5 id="基本语法-10"><a href="#基本语法-10" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类或接口(参数列表){</span><br><span class="line">  类体;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h5 id="底层"><a href="#底层" class="headerlink" title="底层"></a><strong>底层</strong></h5><ul>
<li>本质： IA tiger = class Xxxx$1    class Xxxx$1 = new IA</li>
<li>接口的底层：class Xxxx$1 implement IA{@Overide}</li>
<li>本质： Father father = class Xxxx$2    class Xxxx$2 = new Father</li>
<li>类的底层：class Xxxx$2 extends Father{@Overide}</li>
</ul>
<h5 id="注意事项和细节-26"><a href="#注意事项和细节-26" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>匿名内部类既是一个类的定义同时本身也是一个对象,因此从语法上看，它既有定义类的特征，也有创建对象的特征 </li>
<li>可以直接访问外部类的所有成员，包含私有的 </li>
<li>不能添加访问修饰符,因为它的地位就是一个局部变量 </li>
<li>作用域：仅仅在定义它的方法或代码块中 </li>
<li>匿名内部类方位外部类成员：直接访问 </li>
<li><strong>外部其他类访问匿名内部类：不能访问</strong> </li>
<li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.this.成员)去访问</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class AnonymousInnerClass {</span><br><span class="line"></span><br><span class="line">        //演示基于类的匿名内部类</span><br><span class="line">        //分析</span><br><span class="line">        //1. father编译类型 Father</span><br><span class="line">        //2. father运行类型 Outer04$2</span><br><span class="line">        //3. 底层会创建匿名内部类</span><br><span class="line">        /*</span><br><span class="line">            class Outer04$2 extends Father{</span><br><span class="line">                @Override</span><br><span class="line">                public void test() {</span><br><span class="line">                    System.out.println("匿名内部类重写了test方法");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">         */</span><br><span class="line">        //4. 同时也直接返回了 匿名内部类 Outer04$2的对象</span><br><span class="line">        //5. 注意("jack") 参数列表会传递给 构造器</span><br><span class="line">        Father father = new Father("jack"){</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void test() {</span><br><span class="line">                System.out.println("匿名内部类重写了test方法");</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        System.out.println("father对象的运行类型=" + father.getClass());//Outer04$2</span><br><span class="line">        father.test();</span><br><span class="line"></span><br><span class="line">        //基于抽象类的匿名内部类</span><br><span class="line">        Animal animal = new Animal(){</span><br><span class="line">            @Override</span><br><span class="line">            void eat() {</span><br><span class="line">                System.out.println("小狗吃骨头...");</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        animal.eat();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface IA {//接口</span><br><span class="line">    public void cry();</span><br><span class="line">}</span><br><span class="line">//class Tiger implements IA {</span><br><span class="line">//</span><br><span class="line">//    @Override</span><br><span class="line">//    public void cry() {</span><br><span class="line">//        System.out.println("老虎叫唤...");</span><br><span class="line">//    }</span><br><span class="line">//}</span><br><span class="line">//class Dog implements  IA{</span><br><span class="line">//    @Override</span><br><span class="line">//    public void cry() {</span><br><span class="line">//        System.out.println("小狗汪汪...");</span><br><span class="line">//    }</span><br><span class="line">//}</span><br><span class="line"></span><br><span class="line">class Father {//类</span><br><span class="line">    public Father(String name) {//构造器</span><br><span class="line">        System.out.println("接收到name=" + name);</span><br><span class="line">    }</span><br><span class="line">    public void test() {//方法</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">abstract class Animal { //抽象类</span><br><span class="line">    abstract void eat();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><strong>成员内部类</strong></h4><h5 id="基本介绍-25"><a href="#基本介绍-25" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul>
<li>成员内部类是定义在外部类的成员位置，并且没有static修饰</li>
</ul>
<h5 id="注意事项和细节-27"><a href="#注意事项和细节-27" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li><p>可以直接访问外部类的所有成员，包含私有的 </p>
</li>
<li><p>可以添加任意访问修饰符 </p>
</li>
<li><p>作用域：为整个外部类类体 </p>
</li>
<li><p>成员内部类访问外部类：直接访问 </p>
</li>
<li><p>外部类访问成员内部类；创建对象，再访问 </p>
</li>
<li><p>外部其他类访问成员内部类 </p>
<ul>
<li><p>外部类.内部类  引用名 = 外部对象.new 内部类(); </p>
</li>
<li><p>外部类.内部类  引用名 = <strong>外部对象</strong>.get();</p>
</li>
</ul>
</li>
<li><p>如果外部类和成员内部类的成员重名时，成员内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.this.成员)去访问</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MemberInnerClass01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Outer08 outer08 = new Outer08();</span><br><span class="line">        outer08.t1();</span><br><span class="line"></span><br><span class="line">        //外部其他类，使用成员内部类的三种方式</span><br><span class="line">        //</span><br><span class="line">        // 第一种方式</span><br><span class="line">        // outer08.new Inner08(); 相当于把 new Inner08()当做是outer08成员</span><br><span class="line">        // 这就是一个语法，不要特别的纠结.</span><br><span class="line">        Outer08.Inner08 inner08 = outer08.new Inner08();</span><br><span class="line">        inner08.say();</span><br><span class="line">        // 第二方式 在外部类中，编写一个方法，可以返回 Inner08对象</span><br><span class="line">        Outer08.Inner08 inner08Instance = outer08.getInner08Instance();</span><br><span class="line">        inner08Instance.say();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Outer08 { //外部类</span><br><span class="line">    private int n1 = 10;</span><br><span class="line">    public String name = "张三";</span><br><span class="line"></span><br><span class="line">    private void hi() {</span><br><span class="line">        System.out.println("hi()方法...");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //1.注意: 成员内部类，是定义在外部内的成员位置上</span><br><span class="line">    //2.可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员</span><br><span class="line">    public class Inner08 {//成员内部类</span><br><span class="line">        private double sal = 99.8;</span><br><span class="line">        private int n1 = 66;</span><br><span class="line"></span><br><span class="line">        public void say() {</span><br><span class="line">            //可以直接访问外部类的所有成员，包含私有的</span><br><span class="line">            //如果成员内部类的成员和外部类的成员重名，会遵守就近原则.</span><br><span class="line">            //，可以通过  外部类名.this.属性 来访问外部类的成员</span><br><span class="line">            System.out.println("n1 = " + n1 + " name = " + name + " 外部类的n1=" + Outer08.this.n1);</span><br><span class="line">            hi();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //方法，返回一个Inner08实例</span><br><span class="line">    public Inner08 getInner08Instance() {</span><br><span class="line">        return new Inner08();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    //写方法</span><br><span class="line">    public void t1() {</span><br><span class="line">        //使用成员内部类</span><br><span class="line">        //创建成员内部类的对象，然后使用相关的方法</span><br><span class="line">        Inner08 inner08 = new Inner08();</span><br><span class="line">        inner08.say();</span><br><span class="line">        System.out.println(inner08.sal);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><strong>静态内部类</strong></h4><h5 id="基本介绍-26"><a href="#基本介绍-26" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul>
<li>静态内部类是定义在外部类的成员位置，并且有 static 修饰</li>
</ul>
<h5 id="注意事项和细节-28"><a href="#注意事项和细节-28" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员 </li>
<li>可以添加任意访问修饰符 </li>
<li>作用域：整个外部类类体 </li>
<li>静态内部类访问外部类：直接访问 </li>
<li>外部类访问静态内部类：创建对象，再访问 </li>
<li>外部其他类访问静态内部类： <ul>
<li>外部类.内部类  引用名 = new 外部类.内部类(); </li>
<li>外部类.内部类  引用名 = <strong>外部对象</strong>.get(); </li>
<li>外部类.内部类  引用名 = <strong>外部类</strong>.get();</li>
</ul>
</li>
<li>如果外部类和静态内部类的成员重名时，静态内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.this.成员)去访问</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class StaticInnerClass01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Outer10 outer10 = new Outer10();</span><br><span class="line">        outer10.m1();</span><br><span class="line"></span><br><span class="line">        //外部其他类 使用静态内部类</span><br><span class="line">        //方式1</span><br><span class="line">        //因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)</span><br><span class="line">        Outer10.Inner10 inner10 = new Outer10.Inner10();</span><br><span class="line">        inner10.say();</span><br><span class="line">        //方式2</span><br><span class="line">        //编写一个方法，可以返回静态内部类的对象实例.</span><br><span class="line">        Outer10.Inner10 inner101 = outer10.getInner10();</span><br><span class="line">        System.out.println("============");</span><br><span class="line">        inner101.say();</span><br><span class="line"></span><br><span class="line">        Outer10.Inner10 inner10_ = Outer10.getInner10_();</span><br><span class="line">        System.out.println("************");</span><br><span class="line">        inner10_.say();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Outer10 { //外部类</span><br><span class="line">    private int n1 = 10;</span><br><span class="line">    private static String name = "张三";</span><br><span class="line">    private static void cry() {}</span><br><span class="line">    //Inner10就是静态内部类</span><br><span class="line">    //1. 放在外部类的成员位置</span><br><span class="line">    //2. 使用static 修饰</span><br><span class="line">    //3. 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</span><br><span class="line">    //4. 可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员</span><br><span class="line">    //5. 作用域 ：同其他的成员，为整个类体</span><br><span class="line">    static class Inner10 {</span><br><span class="line">        private static String name = "韩顺平教育";</span><br><span class="line">        public void say() {</span><br><span class="line">            //如果外部类和静态内部类的成员重名时，静态内部类访问的时，</span><br><span class="line">            //默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.成员)</span><br><span class="line">            System.out.println(name + " 外部类name= " + Outer10.name);</span><br><span class="line">            cry();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void m1() { //外部类---访问------&gt;静态内部类 访问方式：创建对象，再访问</span><br><span class="line">        Inner10 inner10 = new Inner10();</span><br><span class="line">        inner10.say();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Inner10 getInner10() {</span><br><span class="line">        return new Inner10();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static Inner10 getInner10_() {</span><br><span class="line">        return new Inner10();</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="类加载顺序⭐️⭐️"><a href="#类加载顺序⭐️⭐️" class="headerlink" title="类加载顺序⭐️⭐️"></a><strong>类加载顺序⭐️⭐️</strong></h3><h4 id="类什么时候被加载"><a href="#类什么时候被加载" class="headerlink" title="类什么时候被加载"></a>类什么时候被加载</h4><ul>
<li><p>创建对象实例时</p>
</li>
<li><p>创建子类对象实例时，父类也会被加载</p>
</li>
<li><p>使用类的静态成员时</p>
</li>
</ul>
<h4 id="创建一个对象时，在一个类的调用顺序"><a href="#创建一个对象时，在一个类的调用顺序" class="headerlink" title="创建一个对象时，在一个类的调用顺序"></a>创建一个对象时，在一个类的调用顺序</h4><ul>
<li><p>调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级样，如果有多个静态代码块和多个静 态变量初始化，则按他们定义的顺序调 </p>
</li>
<li><p>调用普通代码块和普通属性的初始化(注意：普通代码块和普通属性初始化调用的优先级一样，若果有多个普通代码块和多个普通属性初始化，则按定义顺序调用) </p>
</li>
<li><p>调用构造方法</p>
</li>
</ul>
<h4 id="创建子类时顺序"><a href="#创建子类时顺序" class="headerlink" title="创建子类时顺序"></a>创建子类时顺序</h4><ul>
<li><p>父类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p>
</li>
<li><p>子类的静态代码块和静态属性(优先级一样，按定义顺序执行)</p>
</li>
<li><p>父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p>
</li>
<li><p>父类构造方法</p>
</li>
<li><p>子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</p>
</li>
<li><p>子类构造方法</p>
</li>
</ul>
<h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a><strong>枚举和注解</strong></h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="基本介绍-27"><a href="#基本介绍-27" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>枚举是一组常量的集合，属于一种特殊的类，里面只包含一组有限的特定的对象</li>
</ul>
<h3 id="定义类实现枚举"><a href="#定义类实现枚举" class="headerlink" title="定义类实现枚举"></a><strong>定义类实现枚举</strong></h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul>
<li>构造器私有化<br>本类内部创建一组对象</li>
<li>对外暴露对象(通过为对象添加public final static修饰符)</li>
<li>提供get方法，但是不提供set方法</li>
</ul>
<h4 id="注意事项和细节-29"><a href="#注意事项和细节-29" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>不需要提供setxxx 方法，因为<strong>枚举对象值通常为只读</strong></li>
<li>枚举对象/属性使用 final + static 共同修饰，实现底层优化</li>
<li>枚举对象名通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ul>
<h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a><strong>enum关键字实现枚举</strong></h3><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h4><ul>
<li>关键字 enum 代替 class </li>
<li>行首：常量名(实参列表)</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Season {</span><br><span class="line">    SPRING("春天","温暖"),WINTER("冬天","寒冷");</span><br><span class="line">  </span><br><span class="line">    private String name;</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    private Season(String name, String desc) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="注意事项和细节-30"><a href="#注意事项和细节-30" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类 </p>
</li>
<li><p>传统的 public static final Season SPRING = new Season(“春天””温暖”)； 简化成 SPRING(“春天”，”温暖”)，我们必须知道它调用的是哪个构造器 </p>
</li>
<li><p>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略 </p>
</li>
<li><p>多个枚举对象，使用,间隔，最后;结尾 </p>
</li>
<li><p>枚举对象必须放在枚举类行首</p>
</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p>toString：Enum类己经重写过了，返回的是当前对象名子类可以重写该方法，用于返回对象的属性信息 </p>
</li>
<li><p>name：返回当前对象名(常量名)，子类中不能重写 </p>
</li>
<li><p>ordinal：返回当前对象的位置号，默认从0开始 </p>
</li>
<li><p>values：返回当前枚举类中所有的常量 </p>
</li>
<li><p>valueof：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常 </p>
</li>
<li><p>compareTo：比较两个枚举常量的编号，做差</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class EnumMethod {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        //使用Season2 枚举类，来演示各种方法</span><br><span class="line">        Season2 autumn = Season2.AUTUMN;</span><br><span class="line"></span><br><span class="line">        //输出枚举对象的名字</span><br><span class="line">        System.out.println(autumn.name());</span><br><span class="line">        //ordinal() 输出的是该枚举对象的次序/编号，从0开始编号</span><br><span class="line">        //AUTUMN 枚举对象是第三个，因此输出 2</span><br><span class="line">        System.out.println(autumn.ordinal());</span><br><span class="line">        //从反编译可以看出 values方法，返回 Season2[]</span><br><span class="line">        //含有定义的所有枚举对象</span><br><span class="line">        Season2[] values = Season2.values();</span><br><span class="line">        System.out.println("===遍历取出枚举对象(增强for)====");</span><br><span class="line">        for (Season2 season: values) {//增强for循环</span><br><span class="line">            System.out.println(season);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //valueOf：将字符串转换成枚举对象，要求字符串必须␋为已有的常量名，否则报异常</span><br><span class="line">        //执行流程</span><br><span class="line">        //1. 根据你输入的 "AUTUMN" 到 Season2的枚举对象去查找</span><br><span class="line">        //2. 如果找到了，就返回，如果没有找到，就报错</span><br><span class="line">        Season2 autumn1 = Season2.valueOf("AUTUMN");</span><br><span class="line">        System.out.println("autumn1=" + autumn1);</span><br><span class="line">        System.out.println(autumn == autumn1);</span><br><span class="line"></span><br><span class="line">        //compareTo：比较两个枚举常量，比较的就是编号</span><br><span class="line">        //</span><br><span class="line">        //1. 就是把 Season2.AUTUMN 枚举对象的编号 和 Season2.SUMMER枚举对象的编号比较</span><br><span class="line">        //2. 看看结果</span><br><span class="line">        /*</span><br><span class="line">        public final int compareTo(E o) {</span><br><span class="line"></span><br><span class="line">            return self.ordinal - other.ordinal;</span><br><span class="line">        }</span><br><span class="line">        Season2.AUTUMN的编号[2] - Season2.SUMMER的编号[3]</span><br><span class="line">         */</span><br><span class="line">        System.out.println(Season2.AUTUMN.compareTo(Season2.SUMMER));</span><br><span class="line"></span><br><span class="line">        //补充了一个增强for</span><br><span class="line">//        int[] nums = {1, 2, 9};</span><br><span class="line">//        //普通的for循环</span><br><span class="line">//        System.out.println("=====普通的for=====");</span><br><span class="line">//        for (int i = 0; i &lt; nums.length; i++) {</span><br><span class="line">//            System.out.println(nums[i]);</span><br><span class="line">//        }</span><br><span class="line">//        System.out.println("=====增强的for=====");</span><br><span class="line">//        //执行流程是 依次从nums数组中取出数据，赋给i, 如果取出完毕，则退出for</span><br><span class="line">//        for(int i : nums) {</span><br><span class="line">//            System.out.println("i=" + i);</span><br><span class="line">//        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><ul>
<li>使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制</li>
<li>枚举类和普通类一样，可以实现接口：enum 类名 implements 接口1，接口2{}</li>
</ul>
<h3 id="JDk内置的基本注解类型"><a href="#JDk内置的基本注解类型" class="headerlink" title="JDk内置的基本注解类型"></a><strong>JDk内置的基本注解类型</strong></h3><h4 id="基本介绍-28"><a href="#基本介绍-28" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包,类、方法、属性、构造器、局部变量等数据信息 </li>
<li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息 </li>
<li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版本中所有遗留的繁冗代码和XML配置</li>
</ul>
<h4 id="基本Annotation介绍"><a href="#基本Annotation介绍" class="headerlink" title="基本Annotation介绍"></a>基本Annotation介绍</h4><ul>
<li>@Override： 限定某个方法，是重写父类方法，该注解只能用于方法 </li>
<li>@Deprecated：用于表示某个程序元素(类，方法等)己过时 </li>
<li>@SuppressWarnings：抑制编译器警告</li>
</ul>
<h4 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h4><h5 id=""><a href="#" class="headerlink" title=""></a></h5><ul>
<li>Override表示指定重写父类的方法(从编译层面验证)，如果父类没有方法，则会报错 </li>
<li>如果没写 Override还是会重写父类  </li>
<li>Override只能修饰方法，不能修饰其它类，包，属性等等  </li>
<li>如果写了Override注解，编译器就会去检查该方法是否真的重写了父类的方法，若果没有构成重写则编译错误  </li>
<li>查看@Override注解源码@Target(ElementType.MRTHOD)，说明只能修饰方法<br>@Target是修饰注解的注解，称为元注解</li>
</ul>
<h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><ul>
<li>用于表示某个程序元素(类，方法等)己过时 </li>
<li>可以修饰方法，类，字段，包，参数 等等 </li>
<li>@Target(value=(CONSTRUCTOR,FIELD,LOCAL_ VARIABLE, METHOD,PACKAGE, PARAMETER, TYPE})  </li>
<li>@Deprecated 的作用可以做到新旧版本的兼容和过渡</li>
</ul>
<h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><ul>
<li>抑制编译器警告信息 </li>
<li>unchecked 是忽略没有检查的警告 </li>
<li>rawtypes 是忽略没有指定泛型的警告 </li>
<li>unused 是忽略没有使用某个变量的警告错误 </li>
<li>@SuppressWarnings 可以修饰的程序元素为，查看 @Target</li>
<li>生成 @SupperssWarnings  时，不用背，直接点击左侧的黄色提示，就可以选择(注意可以指定生成的位置)</li>
</ul>
<h3 id="元注解：对注解进行注解"><a href="#元注解：对注解进行注解" class="headerlink" title="元注解：对注解进行注解"></a>元注解：对注解进行注解</h3><h4 id="基本介绍-29"><a href="#基本介绍-29" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>JDK 的元 Annotation 用于修饰其他 Annotation</li>
</ul>
<h4 id="四种元注解"><a href="#四种元注解" class="headerlink" title="四种元注解"></a>四种元注解</h4><ul>
<li><p>Retention：指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</p>
</li>
<li><p>Target：指定注解可以在哪些地方使用</p>
</li>
<li><p>Documented：指定该注解是否会在 javadoc 体现</p>
</li>
<li><p>lnherited：子类会继承父类注解</p>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h2><h3 id="基本介绍-30"><a href="#基本介绍-30" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h3><ul>
<li>Java语言中，将程序执行中发生的不正常情况称为 “异常”</li>
</ul>
<h3 id="执行中异常事件分类"><a href="#执行中异常事件分类" class="headerlink" title="执行中异常事件分类"></a>执行中异常事件分类</h3><ul>
<li>Error(错误)：Java虚拟机无法解决的严重问题<ul>
<li>如：JVM系统内部错误、资源耗尽等严重情況<ul>
<li>比如：StackoverflowError[栈溢出]和OOM(out ofmemory)，Error 是严重错误，程序会崩溃</li>
</ul>
</li>
</ul>
</li>
<li>Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理<ul>
<li>例如空指针访问， 试图读取不存在的文件，网络连接中断等等</li>
<li>Exception 分为两大类<ul>
<li>运行时异常</li>
<li>编译时异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常体系图⭐️"><a href="#异常体系图⭐️" class="headerlink" title="异常体系图⭐️"></a><strong>异常体系图⭐️</strong></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071837830.png" alt="image-20221007183718691"></p>
<h4 id="注意事项和细节-31"><a href="#注意事项和细节-31" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>异常分为两大类</p>
<ul>
<li>运行时异常</li>
<li>编译时异常</li>
</ul>
</li>
<li><p>运行时异常</p>
<ul>
<li><p>编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常</p>
</li>
<li><p>可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</p>
</li>
</ul>
</li>
<li><p>编译时异常</p>
<ul>
<li><strong>编译器要求必须处置的异常</strong></li>
</ul>
</li>
</ul>
<h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a><strong>常见的异常</strong></h3><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><ul>
<li><p>NullPointerException：空指针异常 </p>
</li>
<li><p>ArithmeticException：数学运算异常 </p>
</li>
<li><p>ArrayIndexOutOfBoundsException：数组下标越界异常 </p>
</li>
<li><p>ClassCastException：类型转换异常 </p>
</li>
<li><p>NumberFormatException：数字格式不正确异常</p>
</li>
</ul>
<h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><ul>
<li><p>SQLException：操作数据库时，查询表可能发生异常 </p>
</li>
<li><p>lOException：操作文供时，发生的异常 </p>
</li>
<li><p>FileNotFoundException：当操作一个不存在的文件时，发生异常 </p>
</li>
<li><p>ClassNotFoundException：加载类，而该类不存在时异常 </p>
</li>
<li><p>EOFException：操作文件，到文件末尾，发生异常 </p>
</li>
<li><p>illegalArguementException：参数异常</p>
</li>
</ul>
<h3 id="异常处理⭐️"><a href="#异常处理⭐️" class="headerlink" title="异常处理⭐️"></a>异常处理⭐️</h3><h4 id="基本介绍-31"><a href="#基本介绍-31" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>异常处理就是当异常发生时，对异常处理的方式</li>
</ul>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a><strong>try-catch-finally</strong></h4><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><strong>流程图</strong></h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071837034.png" alt="image-20221007183736843"></p>
<h5 id="注意事项和细节-32"><a href="#注意事项和细节-32" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块</li>
<li>如果异常没有发生，则顺序执行 try 的代码块，不会进入到 catch 块</li>
<li>如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)，则使用如下代码-finally{}</li>
<li>可以有多个 catch 语句，捕获不同的异常(进行不同的业务处理)，要求父类异常在后，子类异常在前，比如(Exception 在后，NullPointer Exception 在前)，如果发生异常，只会匹配一个 catch</li>
<li>try-finally 配合，相当于没有捕获异常，程序直接崩溃但执行 finally</li>
</ul>
<h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a><strong>throws</strong></h4><h5 id="基本介绍-32"><a href="#基本介绍-32" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul>
<li>将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是 JVM，默认抛出运行异常</li>
</ul>
<h5 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a><strong>流程图</strong></h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071837925.png" alt="image-20221007183758706"></p>
<h5 id="注意事项和细节-33"><a href="#注意事项和细节-33" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>对于编译异常，程序中必须处理，比如 try-catch 或者 throws</li>
<li>对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理</li>
<li>子类重写父类的方法时，对抛出异常的规定：子类重与的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类拋出的异常的类型的子类型</li>
<li>在throws 过程中，如果有方法 try-catch，就相当于处理异常，就可以不必throws</li>
<li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a><strong>自定义异常</strong></h3><h4 id="基本介绍-33"><a href="#基本介绍-33" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>当程序中出现了某些 “错误〞，但该错误信息并没有在 Throwable 子类中描述处理，这时可以设计异常类，用于描达该错误信息</li>
</ul>
<h4 id="自定义异常步骤"><a href="#自定义异常步骤" class="headerlink" title="自定义异常步骤"></a>自定义异常步骤</h4><ul>
<li>定义类<ul>
<li>自定义异常类名(程序员自己写)继承Exception或Runtime Exception</li>
</ul>
</li>
<li>如果继承Exception，属于编译异常</li>
<li>如果继承RuntimeException，属子运行异常(一般来说，继承RuntimeException)</li>
</ul>
<h3 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a><strong>throw和throws</strong></h3><h4 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a><strong>对比</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071838515.png" alt="image-20221007183817378"></p>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a><strong>常用类</strong></h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a><strong>包装类</strong></h3><h4 id="基本介绍-34"><a href="#基本介绍-34" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ul>
<li>八种基本数据类型相应的引用类型——包装类</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071838691.png" alt="image-20221007183850438"></p>
<h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a><strong>装箱和拆箱</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Integer01 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        //演示int &lt;--&gt; Integer 的装箱和拆箱</span><br><span class="line">        //jdk5前是手动装箱和拆箱</span><br><span class="line">        //手动装箱 int-&gt;Integer</span><br><span class="line">        int n1 = 100;</span><br><span class="line">        Integer integer = new Integer(n1);</span><br><span class="line">        Integer integer1 = Integer.valueOf(n1);</span><br><span class="line"></span><br><span class="line">        //手动拆箱</span><br><span class="line">        //Integer -&gt; int</span><br><span class="line">        int i = integer.intValue();</span><br><span class="line"></span><br><span class="line">        //jdk5后，就可以自动装箱和自动拆箱</span><br><span class="line">        int n2 = 200;</span><br><span class="line">        //自动装箱 int-&gt;Integer</span><br><span class="line">        Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)</span><br><span class="line">        //自动拆箱 Integer-&gt;int</span><br><span class="line">        int n3 = integer2; //底层仍然使用的是 intValue()方法</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="包装类方法"><a href="#包装类方法" class="headerlink" title="包装类方法"></a><strong>包装类方法</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class WrapperVSString {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        //包装类(Integer)-&gt;String</span><br><span class="line">        Integer i = 100;//自动装箱</span><br><span class="line">        //方式1</span><br><span class="line">        String str1 = i + "";</span><br><span class="line">        //方式2</span><br><span class="line">        String str2 = i.toString();</span><br><span class="line">        //方式3</span><br><span class="line">        String str3 = String.valueOf(i);</span><br><span class="line"></span><br><span class="line">        //String -&gt; 包装类(Integer)</span><br><span class="line">        String str4 = "12345";</span><br><span class="line">        Integer i2 = Integer.parseInt(str4);//使用到自动装箱</span><br><span class="line">        Integer i3 = new Integer(str4);//构造器</span><br><span class="line"></span><br><span class="line">        System.out.println("ok~~");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Integer创建机制"><a href="#Integer创建机制" class="headerlink" title="Integer创建机制"></a><strong>Integer创建机制</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class WrapperExercise03 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        //示例一</span><br><span class="line">        Integer i1 = new Integer(127);</span><br><span class="line">        Integer i2 = new Integer(127);</span><br><span class="line">        System.out.println(i1 == i2);//F</span><br><span class="line">//示例二</span><br><span class="line">        Integer i3 = new Integer(128);</span><br><span class="line">        Integer i4 = new Integer(128);</span><br><span class="line">        System.out.println(i3 == i4);//F</span><br><span class="line"></span><br><span class="line">//示例三</span><br><span class="line">        Integer i5 = 127;//底层Integer.valueOf(127)</span><br><span class="line">        Integer i6 = 127;//-128~127</span><br><span class="line">        System.out.println(i5 == i6); //T</span><br><span class="line">//示例四</span><br><span class="line">        Integer i7 = 128;</span><br><span class="line">        Integer i8 = 128;</span><br><span class="line">        System.out.println(i7 == i8);//F</span><br><span class="line">//示例五</span><br><span class="line">        Integer i9 = 127; //Integer.valueOf(127)</span><br><span class="line">        Integer i10 = new Integer(127);</span><br><span class="line">        System.out.println(i9 == i10);//F</span><br><span class="line"></span><br><span class="line">        //示例六</span><br><span class="line">        Integer i11=127;</span><br><span class="line">        int i12=127;</span><br><span class="line">//只有有基本数据类型，判断的是</span><br><span class="line">//值是否相同</span><br><span class="line">        System.out.println(i11==i12); //T</span><br><span class="line">//示例七</span><br><span class="line">        Integer i13=128;</span><br><span class="line">        int i14=128;</span><br><span class="line">        System.out.println(i13==i14);//T</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="String⭐️"><a href="#String⭐️" class="headerlink" title="String⭐️"></a><strong>String⭐️</strong></h3><h4 id="基本介绍-35"><a href="#基本介绍-35" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>String 对象用于保存字符串，也就是一组字符序列 </li>
<li>字符串常量对象是用<strong>双引号</strong>括起的字符序列 </li>
<li>宇符串的宇符使用 Unicode 宇符编码，一个字符(不区分字母还是汉字)占两个字节</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071840344.png" alt="image-20221007184047207"></p>
<h4 id="创建String对象方式"><a href="#创建String对象方式" class="headerlink" title="创建String对象方式"></a>创建String对象方式</h4><ul>
<li><p>直接赋值 String s = “hsp”;</p>
</li>
<li><p>调用构造器 String s2 = new String(“hsp”);</p>
</li>
</ul>
<h5 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a>两种方式对比</h5><ul>
<li><p>方式一：先从常量池查看是否有”hsp”数据空间，如果有，直接指向； 如果沒有则重新创建，然后植自。s最终指向的是常量池的空间地址 </p>
</li>
<li><p>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的 hsp 空间。如果常量池没有”hsp’，重新创建，如果有，直接通过 value 指向，最终指向的是堆中的空间地址</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071842968.png" alt="image-20221007184253786"></p>
<h4 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h4><ul>
<li><p>String s1 = new String(); </p>
</li>
<li><p>String s2 = new String (String original); </p>
</li>
<li><p>String s3 = new String (char[] a); </p>
</li>
<li><p>String s4 = new String (char[] a,int startIndex,int count);</p>
</li>
</ul>
<h4 id="注意事项和细节-34"><a href="#注意事项和细节-34" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>String 是 final 类，不能被继承</p>
</li>
<li><p>string 有属性 private final char valve []; 用于存放字符串内容</p>
</li>
<li><p><strong>value 是一个 final 类型，不可以修改(值可以修改，地址不可修改)</strong></p>
</li>
<li><p>intern 方法：返回常量池的地址对象</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071845020.png" alt="image-20221007184518582"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071845452.png" alt="image-20221007184533176"></p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><h5 id="相等特性"><a href="#相等特性" class="headerlink" title="相等特性"></a>相等特性</h5><ul>
<li>equals判断内容</li>
<li>==判断地址</li>
</ul>
<h5 id="字符串特性"><a href="#字符串特性" class="headerlink" title="字符串特性"></a>字符串特性</h5><ul>
<li>String c1 =“ab”+”cd”;<ul>
<li>常量在池中相加</li>
</ul>
</li>
<li>String c1 = a + b;<ul>
<li>变量在堆中相加</li>
</ul>
</li>
</ul>
<p>使用例子</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StringExercise03 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        String a = "hsp"; //a 指向 常量池的 “hsp”</span><br><span class="line">        String b =new String("hsp");//b 指向堆中对象</span><br><span class="line">        System.out.println(a.equals(b)); //T</span><br><span class="line">        System.out.println(a==b); //F</span><br><span class="line">        //b.intern() 方法返回常量池地址</span><br><span class="line">        System.out.println(a==b.intern()); //T //ntern方法：返回常量池的地址对象</span><br><span class="line">        System.out.println(b==b.intern()); //F</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StringExercise09 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        String s1 = "hspedu";  //s1 指向池中的 “hspedu”</span><br><span class="line">        String s2 = "java"; // s2 指向池中的 “java”</span><br><span class="line">        String s5 = "hspedujava"; //s5 指向池中的 “hspedujava”</span><br><span class="line">        String s6 = (s1 + s2).intern();//s6 指向池中的   “hspedujava”</span><br><span class="line">        System.out.println(s5 == s6); //T</span><br><span class="line">        System.out.println(s5.equals(s6));//T</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = "hello";</span><br><span class="line">s1 = "haha";</span><br><span class="line"></span><br><span class="line">//创建了两个对象，s1指向“hello”，</span><br><span class="line">//再在常量池中创建“haha”，s1指向"haha“</span><br></pre></td></tr></tbody></table></figure>

<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>equals：区分大小写，判断内容是否相等 </li>
<li>equalslgnoreCase：忽略大小写的判断内容是否相等 </li>
<li>length：获取字符的个数，字符串的长度 </li>
<li>indexOf：获取字符在字符串中第1次出现的索引,索引从0开始，如果找不到,返回-1 </li>
<li>lastlndexOf：获取宇符在字符串中最后1次出现的索引,索引从0开始，如找不到,返回-1 </li>
<li>substring： 截取指定范围的子串 </li>
<li>trim：去前后空格 </li>
<li>charAt：获取某索引处的字符，注意不能使用Str[index]这种方式 </li>
<li>toUpperCase：大写字母 </li>
<li>toLowerCase：小写字母 </li>
<li>concat：拼接 </li>
<li>replace：替换字符串中的字符 </li>
<li>split：分割字符串 </li>
<li>compareTo：比较两个字符串的大小 </li>
<li>toCharArray：转换成字符数组 </li>
<li>format：格式字符串</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//1. equals 前面已经讲过了. 比较内容是否相同，区分大小写</span><br><span class="line">        String str1 = "hello";</span><br><span class="line">        String str2 = "Hello";</span><br><span class="line">        System.out.println(str1.equals(str2));//</span><br><span class="line"></span><br><span class="line">        // 2.equalsIgnoreCase 忽略大小写的判断内容是否相等</span><br><span class="line">        String username = "johN";</span><br><span class="line">        if ("john".equalsIgnoreCase(username)) {</span><br><span class="line">            System.out.println("Success!");</span><br><span class="line">        } else {</span><br><span class="line">            System.out.println("Failure!");</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 3.length 获取字符的个数，字符串的长度</span><br><span class="line">        System.out.println("韩顺平".length());</span><br><span class="line"></span><br><span class="line">        // 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从0开始，如果找不到，返回-1</span><br><span class="line">        String s1 = "wer@terwe@g";</span><br><span class="line">        int index = s1.indexOf('@');</span><br><span class="line">        System.out.println(index);// 3</span><br><span class="line">        System.out.println("weIndex=" + s1.indexOf("we"));//0</span><br><span class="line"></span><br><span class="line">        // 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1</span><br><span class="line">        s1 = "wer@terwe@g@";</span><br><span class="line">        index = s1.lastIndexOf('@');</span><br><span class="line">        System.out.println(index);//11</span><br><span class="line">        System.out.println("ter的位置=" + s1.lastIndexOf("ter"));//4</span><br><span class="line"></span><br><span class="line">        // 6.substring 截取指定范围的子串</span><br><span class="line">        String name = "hello,张三";</span><br><span class="line">        //下面name.substring(6) 从索引6开始截取后面所有的内容</span><br><span class="line">        System.out.println(name.substring(6));//截取后面的字符</span><br><span class="line">        //name.substring(0,5)表示从索引0开始截取，截取到索引 5-1=4位置</span><br><span class="line">        System.out.println(name.substring(2,5));//llo</span><br></pre></td></tr></tbody></table></figure>



<h3 id="StringBuffer⭐️"><a href="#StringBuffer⭐️" class="headerlink" title="StringBuffer⭐️"></a>StringBuffer⭐️</h3><h4 id="基本介绍-36"><a href="#基本介绍-36" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><p>java.lang.StringBuffer 代表可变的字符序列，可以对字符串内容进行增删。</p>
</li>
<li><p>很多方法与 String 相同，但 StringBuffer 是可变长度的。</p>
</li>
<li><p>String Buffer 是一个容器。</p>
</li>
</ul>
<h4 id="注意事项和细节-35"><a href="#注意事项和细节-35" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li><p>StringBuffer 的直接父类是 AbstractstringBuilder</p>
</li>
<li><p>StringBuffer 实现了 Serializable，即StringBuffer的对象可以串行化</p>
</li>
<li><p>在父类中 AbstractstringBuilder 有属性 char[] valve,不是final，该 valve 数组存放 宁符串内容，引出存放在堆中的</p>
</li>
<li><p>StringBuffer 是一个 final 类，不能被继承</p>
</li>
<li><p>StringBuffer 字符内容存在 char[] value，所以在变化〔增加/删除)不用每次都更换地址(即不是每次创建新对象)</p>
</li>
</ul>
<h4 id="String和StringBuffer对比"><a href="#String和StringBuffer对比" class="headerlink" title="String和StringBuffer对比"></a>String和StringBuffer对比</h4><ul>
<li><p>String 保存的是宇符串常量，里面的值不能更改，每次 String 类的更新实际上就是更改地址</p>
</li>
<li><p>StringBuffer 保存的是字符串变量，里面的值可以更改，不用更新地址，效率高</p>
</li>
</ul>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a><strong>构造器</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1. 创建一个 大小为 16的 char[] ,用于存放字符内容</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line"></span><br><span class="line">//2 通过构造器指定 char[] 大小</span><br><span class="line">StringBuffer stringBuffer1 = new StringBuffer(100);</span><br><span class="line"></span><br><span class="line">//3. 通过 给一个String 创建 StringBuffer, char[] 大小就是 str.length() + 16</span><br><span class="line">StringBuffer hello = new StringBuffer("hello");</span><br></pre></td></tr></tbody></table></figure>

<h4 id="String和StringBuffer转换"><a href="#String和StringBuffer转换" class="headerlink" title="String和StringBuffer转换"></a><strong>String和StringBuffer转换</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// String——&gt;StringBuffer</span><br><span class="line">String str = "hello tom";</span><br><span class="line"></span><br><span class="line">//方式1 使用构造器</span><br><span class="line">//注意： 返回的才是StringBuffer对象，对str 本身没有影响</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer(str);</span><br><span class="line">//方式2 使用的是append方法</span><br><span class="line">StringBuffer stringBuffer1 = new StringBuffer();</span><br><span class="line">stringBuffer1 = stringBuffer1.append(str);</span><br><span class="line"></span><br><span class="line">// StringBuffer -&gt;String</span><br><span class="line">StringBuffer stringBuffer3 = new StringBuffer("韩顺平教育");</span><br><span class="line">//方式1 使用StringBuffer提供的 toString方法</span><br><span class="line">String s = stringBuffer3.toString();</span><br><span class="line">//方式2: 使用构造器来搞定</span><br><span class="line">String s1 = new String(stringBuffer3);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>增：append </li>
<li>删：delete(start,end) </li>
<li>改：replace (start,end,string) </li>
<li>查：indexOf </li>
<li>插：insert </li>
<li>获取长度：length</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer s = new StringBuffer("hello");</span><br><span class="line"></span><br><span class="line">//增</span><br><span class="line">s.append(',');// "hello,"</span><br><span class="line">s.append("张三丰");//"hello,张三丰"</span><br><span class="line">s.append("赵敏").append(100).append(true).append(10.5);//"hello,张三丰赵敏100true10.5"</span><br><span class="line">System.out.println(s);//"hello,张三丰赵敏100true10.5"</span><br><span class="line"></span><br><span class="line">//删</span><br><span class="line">/*</span><br><span class="line">* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span><br><span class="line">* : 删除 11~14的字符 [11, 14)</span><br><span class="line">*/</span><br><span class="line">s.delete(11, 14);</span><br><span class="line">System.out.println(s);//"hello,张三丰赵敏true10.5"</span><br><span class="line"></span><br><span class="line">//改</span><br><span class="line">//，使用 周芷若 替换 索引9-11的字符 [9,11)</span><br><span class="line">s.replace(9, 11, "周芷若");</span><br><span class="line">System.out.println(s);//"hello,张三丰周芷若true10.5"</span><br><span class="line">//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1</span><br><span class="line">int indexOf = s.indexOf("张三丰");</span><br><span class="line">System.out.println(indexOf);//6</span><br><span class="line"></span><br><span class="line">//插</span><br><span class="line">//，在索引为9的位置插入 "赵敏",原来索引为9的内容自动后移</span><br><span class="line">s.insert(9, "赵敏");</span><br><span class="line">System.out.println(s);//"hello,张三丰赵敏周芷若true10.5"</span><br><span class="line"></span><br><span class="line">//长度</span><br><span class="line">System.out.println(s.length());//22</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></tbody></table></figure>



<h4 id="StringBulider⭐️"><a href="#StringBulider⭐️" class="headerlink" title="StringBulider⭐️"></a>StringBulider⭐️</h4><h4 id="基本介绍-37"><a href="#基本介绍-37" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步，</li>
<li>该类被设计用作 String Buffer 的个简易替换，用在字符串缓冲区被单个线程使用的时候</li>
<li>如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer 快</li>
<li>在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据</li>
</ul>
<h4 id="注意事项和细节-36"><a href="#注意事项和细节-36" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ul>
<li>StringBuilder 继承 AbstractstringBuilder 类</li>
<li>实现了 Serializable，说明 StringBuilder 对象是可以串行化(对象可以网络传输，可以保存到文件)</li>
<li>StringBuilder 是 final 类，不能被继承</li>
<li>StringBuitder 对象字符序列仍然足存放在其父类 AbstractstringBuilder的 char [I valve;因此，字符序列是堆中</li>
<li>StringBoilder 的方法，没有做互斥的处理，即没有synchronized 关键字，此在单线程的情況下使用</li>
</ul>
<h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>和 StringBuffer 相同</li>
</ul>
<h4 id="三类对比"><a href="#三类对比" class="headerlink" title="三类对比"></a>三类对比</h4><ul>
<li><p>String：不可变字符序列，效率低,但是复用率高</p>
</li>
<li><p>StringBuffer：可变字符序列，效率较高(增删)，线程安全</p>
</li>
<li><p>String Builder：可变字符序列、效率最高、线程不安全</p>
</li>
<li><p>StringBuilder 和  StringBuffer 非常类似，均代表可变的字符序列，且方法相同</p>
</li>
<li><p>String使用注意说明：string s=”a”;//创建了一个字符串s+=”b”;1/实际上原来的”a”字符串对象已经丢奔了，现在又产生了一个字符串S+”b”(也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能</p>
</li>
</ul>
<h4 id="三类选择"><a href="#三类选择" class="headerlink" title="三类选择"></a>三类选择</h4><ul>
<li><p>如果宇符串存在大量的修改操作，一般使用 StringBuffer 或StringBuilder</p>
</li>
<li><p>如果字符串存在大量的修改操作，并在单线程的情況，使用 StringBuilder</p>
</li>
<li><p>如果字符串存在大量的修改操作，并在多线程的情况，使用 String Buffer</p>
</li>
<li><p>如果我们字符串很少修改，被多个对象引用，使用String</p>
</li>
</ul>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><h4 id="基本介绍-38"><a href="#基本介绍-38" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数，均为静态方法</li>
</ul>
<h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p>abs：绝对值</p>
</li>
<li><p>pow：求幂</p>
</li>
<li><p>ceil：向上取整</p>
</li>
<li><p>floor：向下取整</p>
</li>
<li><p>round：四舍五入</p>
</li>
<li><p>sqrt：求开方</p>
</li>
<li><p>random：求随机数</p>
</li>
<li><p>max：求两个数的最大值</p>
</li>
<li><p>min：求两个数的最小值</p>
</li>
</ul>
<h3 id="Date、Calenda、LocalDate"><a href="#Date、Calenda、LocalDate" class="headerlink" title="Date、Calenda、LocalDate"></a>Date、Calenda、LocalDate</h3><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><h5 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><p>Date：精确到毫秒，代表特定时间 </p>
</li>
<li><p>Simple Date Format：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类 它允许进行格式化（日期一＞文本）解析（文本-＞日期）和规范化</p>
</li>
</ul>
<h4 id="Calenda"><a href="#Calenda" class="headerlink" title="Calenda"></a>Calenda</h4><h5 id="基本介绍-39"><a href="#基本介绍-39" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul>
<li>是一个抽象类，并且构造器是 private，可以通过 getInstance() 来获得实例，提供大量的方法和字段</li>
</ul>
<h5 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><p>getInstance()：获取实例</p>
</li>
<li><p>get.XXXX：获取字段</p>
</li>
</ul>
<h4 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h4><h5 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><p>LocalDateTime ldt = LocalDateTime.now()</p>
<ul>
<li>获取时间</li>
</ul>
</li>
<li><p>get.Xxxx()</p>
<ul>
<li>获取字段</li>
</ul>
</li>
<li><p>DateTimeFormatter.format()</p>
<ul>
<li>格式化</li>
</ul>
</li>
<li><p>DateTimeFormatter.ofPattern()</p>
<ul>
<li>定制格式化</li>
</ul>
</li>
<li><p>Date date = Date.from(instant);</p>
<ul>
<li>Instant转换Date</li>
</ul>
</li>
<li><p>Instant instant = date.tolnstant();</p>
<ul>
<li>Date转换Instant</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//1. 使用now() 返回表示当前日期时间的 对象</span><br><span class="line">LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()</span><br><span class="line">System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">//2. 使用DateTimeFormatter 对象来进行格式化</span><br><span class="line">// 创建 DateTimeFormatter对象</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");</span><br><span class="line">String format = dateTimeFormatter.format(ldt);</span><br><span class="line">System.out.println("格式化的日期=" + format);</span><br><span class="line"></span><br><span class="line">System.out.println("年=" + ldt.getYear());</span><br><span class="line">System.out.println("月=" + ldt.getMonth());</span><br><span class="line">System.out.println("月=" + ldt.getMonthValue());</span><br><span class="line">System.out.println("日=" + ldt.getDayOfMonth());</span><br><span class="line">System.out.println("时=" + ldt.getHour());</span><br><span class="line">System.out.println("分=" + ldt.getMinute());</span><br><span class="line">System.out.println("秒=" + ldt.getSecond());</span><br><span class="line"></span><br><span class="line">LocalDate now = LocalDate.now(); //可以获取年月日</span><br><span class="line">LocalTime now2 = LocalTime.now();//获取到时分秒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//提供 plus 和 minus方法可以对当前时间进行加或者减</span><br><span class="line">//看看890天后，是什么时候 把 年月日-时分秒</span><br><span class="line">LocalDateTime localDateTime = ldt.plusDays(890);</span><br><span class="line">System.out.println("890天后=" + dateTimeFormatter.format(localDateTime));</span><br><span class="line"></span><br><span class="line">//看看在 3456分钟前是什么时候，把 年月日-时分秒输出</span><br><span class="line">LocalDateTime localDateTime2 = ldt.minusMinutes(3456);</span><br><span class="line">System.out.println("3456分钟前 日期=" + dateTimeFormatter.format(localDateTime2));</span><br></pre></td></tr></tbody></table></figure>



<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><h4 id="常用方法-8"><a href="#常用方法-8" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p>exit</p>
<ul>
<li>退出当前程序</li>
</ul>
</li>
<li><p>arraycopy</p>
<ul>
<li>复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组 int[] src={1,2.3}: int[] dest = new int[3]; System.arraycopy (src, 0, dest, 0, 3);</li>
</ul>
</li>
<li><p>currentTimeMillens</p>
<ul>
<li>返回当前时间距离1970-1-1的毫秒数</li>
</ul>
</li>
<li><p>gc()</p>
<ul>
<li>运行垃圾回收机制</li>
</ul>
</li>
</ul>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h4 id="基本介绍-40"><a href="#基本介绍-40" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>Arrays 里面包含了一系列静态方法，用于管理或操作数组(比如排序和搜索)</li>
</ul>
<h4 id="常用方法-9"><a href="#常用方法-9" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p>toString：返回数组的字符串形式： Arrays.toString (arr) </p>
</li>
<li><p>sort：排序(自然排序和定制排序)： Arrays.sout(arr) </p>
</li>
<li><p>binarySearch：通过二分搜索法进行查找，必须是有排序的数组： int index = Arrays.binarySearch (arr, 需要查找的数) </p>
</li>
<li><p>copyOf：数组元素的复制： Integer[] newArr = Arrays.copyOf(arr, arr.length) </p>
</li>
<li><p>fill：数组元素的填充 Integer[] num = new Integer[]{9,3,2} Arrays.fill (num, 99); </p>
</li>
<li><p>equals：比较两个数组元素内容是否完全一 boolean equals = Arrays.equals(arr. arr2) </p>
</li>
<li><p>aslist：将一组值，转换成list List asList = Arrays.asList(2,3,4,5,6,1)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = {1, 2, 90, 123, 567};</span><br><span class="line">// binarySearch 通过二分搜索法进行查找，要求必须排好</span><br><span class="line">// </span><br><span class="line">//1. 使用 binarySearch 二叉查找</span><br><span class="line">//2. 要求该数组是有序的. 如果该数组是无序的，不能使用binarySearch</span><br><span class="line">//3. 如果数组中不存在该元素，就返回 return -(low + 1);  // key not found.</span><br><span class="line">int index = Arrays.binarySearch(arr, 567);</span><br><span class="line">System.out.println("index=" + index);</span><br><span class="line"></span><br><span class="line">//copyOf 数组元素的复制</span><br><span class="line">// </span><br><span class="line">//1. 从 arr 数组中，拷贝 arr.length个元素到 newArr数组中</span><br><span class="line">//2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null</span><br><span class="line">//3. 如果拷贝长度 &lt; 0 就抛出异常NegativeArraySizeException</span><br><span class="line">//4. 该方法的底层使用的是 System.arraycopy()</span><br><span class="line">Integer[] newArr = Arrays.copyOf(arr, arr.length);</span><br><span class="line">System.out.println("==拷贝执行完毕后==");</span><br><span class="line">System.out.println(Arrays.toString(newArr));</span><br><span class="line"></span><br><span class="line">//ill 数组元素的填充</span><br><span class="line">Integer[] num = new Integer[]{9,3,2};</span><br><span class="line">//</span><br><span class="line">//1. 使用 99 去填充 num数组，可以理解成是替换原理的元素</span><br><span class="line">Arrays.fill(num, 99);</span><br><span class="line">System.out.println("==num数组填充后==");</span><br><span class="line">System.out.println(Arrays.toString(num));</span><br><span class="line"></span><br><span class="line">//equals 比较两个数组元素内容是否完全一致</span><br><span class="line">Integer[] arr2 = {1, 2, 90, 123};</span><br><span class="line">//</span><br><span class="line">//1. 如果arr 和 arr2 数组的元素一样，则方法true;</span><br><span class="line">//2. 如果不是完全一样，就返回 false</span><br><span class="line">boolean equals = Arrays.equals(arr, arr2);</span><br><span class="line">System.out.println("equals=" + equals);</span><br><span class="line"></span><br><span class="line">//asList 将一组值，转换成list</span><br><span class="line">//</span><br><span class="line">//1. asList方法，会将 (2,3,4,5,6,1)数据转成一个List集合</span><br><span class="line">//2. 返回的 asList 编译类型 List(接口)</span><br><span class="line">//3. asList 运行类型 java.util.Arrays#ArrayList, 是Arrays类的</span><br><span class="line">//   静态内部类 private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">//              implements RandomAccess, java.io.Serializable</span><br><span class="line">List asList = Arrays.asList(2,3,4,5,6,1);</span><br><span class="line">System.out.println("asList=" + asList);</span><br><span class="line">System.out.println("asList的运行类型" + asList.getClass());</span><br></pre></td></tr></tbody></table></figure>



<h3 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger BigDecimal"></a>BigInteger BigDecimal</h3><h4 id="基本介绍-41"><a href="#基本介绍-41" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><p>Biglnteger 适合保存比较大的整型 </p>
</li>
<li><p>BigDecimal 适合保存精度更高的浮点型（小数）</p>
</li>
</ul>
<h4 id="常用方法-10"><a href="#常用方法-10" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p>add：加</p>
</li>
<li><p>subtract：减</p>
</li>
<li><p>multiply：乘</p>
</li>
<li><p>divide：除</p>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h2><h3 id="基本介绍-42"><a href="#基本介绍-42" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>可以动态保存任意多个对象</li>
<li>提供了一系列方便的操作对象的方法</li>
<li>使用集合添加、删除新元素的示意代码更简洁</li>
</ul>
<h3 id="集合框架体系⭐️"><a href="#集合框架体系⭐️" class="headerlink" title="集合框架体系⭐️"></a><strong>集合框架体系⭐️</strong></h3><h4 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a><strong>框架图</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210071915652.png" alt="image-20221007191500475"></p>
<p>所有的集合框架都包含如下内容</p>
<ul>
<li>接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li>
<li>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap</li>
<li>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>
</ul>
<p>除了集合，还定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a><strong>Collection</strong></h3><h4 id="基本介绍-43"><a href="#基本介绍-43" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><p>Collection 实现子类可以存放多个元素，每个元素可以是 Object</p>
</li>
<li><p>Collection 的实现类，有些可以存放重复的元素，有些不可以</p>
</li>
<li><p>Collection 的实现类，有些是有序的(List)，有些不是有序(Set)</p>
</li>
<li><p>Collection 接口没有直接的实现子类，是通过它的子接口 Set 和 List 来实现的</p>
</li>
</ul>
<h4 id="接口常用方法"><a href="#接口常用方法" class="headerlink" title="接口常用方法"></a>接口常用方法</h4><ul>
<li><p>add：添加单个元素 </p>
</li>
<li><p>remove：删除指定元素 </p>
</li>
<li><p>contains：查找元素是否存在 </p>
</li>
<li><p>size：获取元素个数 </p>
</li>
<li><p>isEmpty：判断是否为空 </p>
</li>
<li><p>clear：清空 </p>
</li>
<li><p>addAll：添加多个元素 </p>
</li>
<li><p>containsAll：查找多个元素是否都存在 </p>
</li>
<li><p>removeAll：删除多个元素</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//        说明：以ArrayList实现类来演示</span><br><span class="line">List list = new ArrayList();</span><br><span class="line">//        add:添加单个元素</span><br><span class="line">        list.add("jack");</span><br><span class="line">        list.add(10);//list.add(new Integer(10))</span><br><span class="line">        list.add(true);</span><br><span class="line">        System.out.println("list=" + list);</span><br><span class="line">//        remove:删除指定元素</span><br><span class="line">        //list.remove(0);//删除第一个元素</span><br><span class="line">        list.remove(true);//指定删除某个元素</span><br><span class="line">        System.out.println("list=" + list);</span><br><span class="line">//        contains:查找元素是否存在</span><br><span class="line">        System.out.println(list.contains("jack"));//T</span><br><span class="line">//        size:获取元素个数</span><br><span class="line">        System.out.println(list.size());//2</span><br><span class="line">//        isEmpty:判断是否为空</span><br><span class="line">        System.out.println(list.isEmpty());//F</span><br><span class="line">//        clear:清空</span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println("list=" + list);</span><br><span class="line">//        addAll:添加多个元素</span><br><span class="line">        ArrayList list2 = new ArrayList();</span><br><span class="line">        list2.add("红楼梦");</span><br><span class="line">        list2.add("三国演义");</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        System.out.println("list=" + list);</span><br><span class="line">//        containsAll:查找多个元素是否都存在</span><br><span class="line">        System.out.println(list.containsAll(list2));//T</span><br><span class="line">//        removeAll：删除多个元素</span><br><span class="line">        list.add("聊斋");</span><br><span class="line">        list.removeAll(list2);</span><br><span class="line">        System.out.println("list=" + list);//[聊斋]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h3 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h3><h4 id="基本介绍-44"><a href="#基本介绍-44" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>List 集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</li>
<li>List 集合中的每个元素都有其对应的顺序索引，即支持索引</li>
<li>List 容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器元素</li>
<li>常用： ArrayList、LinkedList、Vector</li>
</ul>
<h4 id="常用方法-11"><a href="#常用方法-11" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>void add(int index, Object ele)：在index位置插入ele元素 </li>
<li>boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来 </li>
<li>Object get(int index)：获取指定index位置的元素 </li>
<li>int indexOf(Object obj)：返回obj在集合中首次出现的位置 </li>
<li>int lastindexOf(Object obj)：返回obj在当前集合中末次出现的位置 </li>
<li>Object remove(int index)：移除指定index位置的元素，井返回此元素 </li>
<li>Object set(int index, Object ele)：设置指定index位置的元素为ele，相当于是替换 </li>
<li>List sublist(int fromlndex, int tolndex)：返回从fromlndex到tolndex位置的子集合</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">        list.add("张三丰");</span><br><span class="line">        list.add("贾宝玉");</span><br><span class="line">//        void add(int index, Object ele):在index位置插入ele元素</span><br><span class="line">        //在index = 1的位置插入一个对象</span><br><span class="line">        list.add(1, "韩顺平");</span><br><span class="line">        System.out.println("list=" + list);</span><br><span class="line"></span><br><span class="line">//        boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span><br><span class="line">        List list2 = new ArrayList();</span><br><span class="line">        list2.add("jack");</span><br><span class="line">        list2.add("tom");</span><br><span class="line">        list.addAll(1, list2);</span><br><span class="line">        System.out.println("list=" + list);</span><br><span class="line"></span><br><span class="line">//        Object get(int index):获取指定index位置的元素</span><br><span class="line"></span><br><span class="line">//        int indexOf(Object obj):返回obj在集合中首次出现的位置</span><br><span class="line">        System.out.println(list.indexOf("tom"));//2</span><br><span class="line"></span><br><span class="line">//        int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span><br><span class="line">        list.add("韩顺平");</span><br><span class="line">        System.out.println("list=" + list);</span><br><span class="line">        System.out.println(list.lastIndexOf("韩顺平"));</span><br><span class="line"></span><br><span class="line">//        Object remove(int index):移除指定index位置的元素，并返回此元素</span><br><span class="line">        list.remove(0);</span><br><span class="line">        System.out.println("list=" + list);</span><br><span class="line"></span><br><span class="line">//        Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span><br><span class="line">        list.set(1, "玛丽");</span><br><span class="line">        System.out.println("list=" + list);</span><br><span class="line"></span><br><span class="line">//        List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span><br><span class="line">        // 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span><br><span class="line">        List returnlist = list.subList(0, 2);</span><br><span class="line">        System.out.println("returnlist=" + returnlist);</span><br></pre></td></tr></tbody></table></figure>



<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="基本介绍-45"><a href="#基本介绍-45" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h5><ul>
<li>lterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素 </li>
<li>实现了 Collection 接口的集合都有一个 iterator() 方法，用以返回一个实现了 lterator 接口的对象，即可以返回一个迭代器 </li>
<li>lterator 仅用于遍历集合，lterator 本身并不存放对象 </li>
<li>在调用 it.next() 方法之前必须要调用 it.hasNext() 进行检测。若不调用，且下一条记录无效，直接调用 it.next() 会抛出 NoSuchElementException 异常</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionIterator {</span><br><span class="line">    @SuppressWarnings({"all"})</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        Collection col = new ArrayList();</span><br><span class="line"></span><br><span class="line">        col.add(new Book("三国演义", "罗贯中", 10.1));</span><br><span class="line">        col.add(new Book("小李飞刀", "古龙", 5.1));</span><br><span class="line">        col.add(new Book("红楼梦", "曹雪芹", 34.6));</span><br><span class="line"></span><br><span class="line">        //System.out.println("col=" + col);</span><br><span class="line">        //现在老师希望能够遍历 col集合</span><br><span class="line">        //1. 先得到 col 对应的 迭代器</span><br><span class="line">        Iterator iterator = col.iterator();</span><br><span class="line">        //2. 使用while循环遍历</span><br><span class="line">//        while (iterator.hasNext()) {//判断是否还有数据</span><br><span class="line">//            //返回下一个元素，类型是Object</span><br><span class="line">//            Object obj = iterator.next();</span><br><span class="line">//            System.out.println("obj=" + obj);</span><br><span class="line">//        }</span><br><span class="line">      </span><br><span class="line">        //老师教大家一个快捷键，快速生成 while =&gt; itit</span><br><span class="line">        //显示所有的快捷键的的快捷键 ctrl + j</span><br><span class="line">      </span><br><span class="line">        while (iterator.hasNext()) {</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println("obj=" + obj);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        //3. 当退出while循环后 , 这时iterator迭代器，指向最后的元素</span><br><span class="line">        //   iterator.next();//NoSuchElementException</span><br><span class="line">        //4. 如果希望再次遍历，需要重置我们的迭代器</span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println("===第二次遍历===");</span><br><span class="line">        while (iterator.hasNext()) {</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println("obj=" + obj);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Book {</span><br><span class="line">    private String name;</span><br><span class="line">    private String author;</span><br><span class="line">    private double price;</span><br><span class="line"></span><br><span class="line">    public Book(String name, String author, double price) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.author = author;</span><br><span class="line">        this.price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getName() {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setName(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getAuthor() {</span><br><span class="line">        return author;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) {</span><br><span class="line">        this.author = author;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public double getPrice() {</span><br><span class="line">        return price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) {</span><br><span class="line">        this.price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() {</span><br><span class="line">        return "Book{" +</span><br><span class="line">                "name='" + name + '\'' +</span><br><span class="line">                ", author='" + author + '\'' +</span><br><span class="line">                ", price=" + price +</span><br><span class="line">                '}';</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="for增强循环"><a href="#for增强循环" class="headerlink" title="for增强循环"></a>for增强循环</h4><h5 id="基本介绍-46"><a href="#基本介绍-46" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul>
<li>增强 for 循环，可以代替 iteertor 迭代器，特点：增强 for 就是简化版的 iteraotr,本质一样，只能用于遍历集合或数组</li>
</ul>
<h5 id="基本语法-11"><a href="#基本语法-11" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型 元素名:集合名或数组名){</span><br><span class="line">	访问元素;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="注意事项和细节-37"><a href="#注意事项和细节-37" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>允许所有元素<ul>
<li>包括 null 加入</li>
</ul>
</li>
<li>ArrayList 基本等同于 Vector,除了 ArrayList 是线程不安全的，但其执行效率高<ul>
<li>在多线程情况下，不建议使用 ArrayList</li>
</ul>
</li>
</ul>
<h5 id="底层结构和源码分析"><a href="#底层结构和源码分析" class="headerlink" title="底层结构和源码分析"></a><strong>底层结构和源码分析</strong></h5><ul>
<li>ArrayList 中维护了一个 Object 类型的数组 - elementData<ul>
<li>transient Object[] elementData;</li>
<li>transient 表示瞬间,短暂的，<strong>表示该属性不会被序列化</strong></li>
</ul>
</li>
<li>创建 ArrayList 对象时<ul>
<li>如果使用的是无参构造器，则初始 elementData 容量为0，第1次添加，则扩容 elementData 为10，如需要再次扩容，则扩容 elementData 为1.5倍 </li>
<li>如果使用的是指定大小的构造器，则初始 elementData 容量为指定大小，如果需要扩容，则直接扩容 elementData 为1.5倍</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102033297.png" alt="image-20221010203320092"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102033618.png" alt="image-20221010203332438"></p>
<h4 id="Vector⭐️"><a href="#Vector⭐️" class="headerlink" title="Vector⭐️"></a>Vector⭐️</h4><h5 id="注意事项和细节-38"><a href="#注意事项和细节-38" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>Vector 底层是一个对象数组<ul>
<li>protected Object[] elementData;</li>
</ul>
</li>
<li>Vector 是线程同步的，即线程安全，Vector 类的操作方法带有 synchronized</li>
</ul>
<h5 id="底层机制和源码分析"><a href="#底层机制和源码分析" class="headerlink" title="底层机制和源码分析"></a>底层机制和源码分析</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Vector_ {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        //无参构造器</span><br><span class="line">        //有参数的构造</span><br><span class="line">        Vector vector = new Vector(8);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) {</span><br><span class="line">            vector.add(i);</span><br><span class="line">        }</span><br><span class="line">        vector.add(100);</span><br><span class="line">        System.out.println("vector=" + vector);</span><br><span class="line">        //老韩解读源码</span><br><span class="line">        //1. new Vector() 底层</span><br><span class="line">        /*</span><br><span class="line">            public Vector() {</span><br><span class="line">                this(10);</span><br><span class="line">            }</span><br><span class="line">         补充：如果是  Vector vector = new Vector(8);</span><br><span class="line">            走的方法:</span><br><span class="line">            public Vector(int initialCapacity) {</span><br><span class="line">                this(initialCapacity, 0);</span><br><span class="line">            }</span><br><span class="line">         2. vector.add(i)</span><br><span class="line">         2.1  //下面这个方法就添加数据到vector集合</span><br><span class="line">            public synchronized boolean add(E e) {</span><br><span class="line">                modCount++;</span><br><span class="line">                ensureCapacityHelper(elementCount + 1);</span><br><span class="line">                elementData[elementCount++] = e;</span><br><span class="line">                return true;</span><br><span class="line">            }</span><br><span class="line">          2.2  //确定是否需要扩容 条件 ： minCapacity - elementData.length&gt;0</span><br><span class="line">            private void ensureCapacityHelper(int minCapacity) {</span><br><span class="line">                // overflow-conscious code</span><br><span class="line">                if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">                    grow(minCapacity);</span><br><span class="line">            }</span><br><span class="line">          2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法</span><br><span class="line">              //newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">              //                             capacityIncrement : oldCapacity);</span><br><span class="line">              //就是扩容两倍.</span><br><span class="line">            private void grow(int minCapacity) {</span><br><span class="line">                // overflow-conscious code</span><br><span class="line">                int oldCapacity = elementData.length;</span><br><span class="line">                int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                                 capacityIncrement : oldCapacity);</span><br><span class="line">                if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">                    newCapacity = minCapacity;</span><br><span class="line">                if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">                    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">                elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">            }</span><br><span class="line">         */</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a><strong>ArrayList和Vector</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102035032.png" alt="image-20221010203556918"></p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h4><h5 id="注意事项和细节-39"><a href="#注意事项和细节-39" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>LinkedList 底层实现了<strong>双向链表</strong>和<strong>双端队列</strong>特点</li>
<li>可以添加任意元素包括 null</li>
<li>线程不安全，没有实现同步</li>
</ul>
<h5 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h5><ul>
<li>Linkedlis t底层维护了一个双向链表 </li>
<li>Linkedlist 中维护了两个属性 first 和 last 分别指向首节点和尾节点 </li>
<li>每个节点（Node对象），里面又维护了 prev、next, item 三个属性，其中通过 prev 指向前一个，通过 next 指向后一个节点。最终实现双向链表 </li>
<li>所以 LinkedList 的元素的添加和删除，不是通过数组完成的，相对来说效率较高</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102038008.png" alt="image-20221010203815869"></p>
<h4 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h4><ul>
<li>如果我们改查的操作多，选择 ArrayList </li>
<li>如果我们增删的操作多，选择 LinkedList </li>
<li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择 ArrayList</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本介绍-47"><a href="#基本介绍-47" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>无序，没有索引</li>
<li>不允许重复元素，最多包含一个 null</li>
<li>JDK API 中 Set 接口的实现类有<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/xinyemoon/Image/master/Note/202210102040344.png" alt="image-20221010204040225"></li>
</ul>
<h4 id="常用方法-12"><a href="#常用方法-12" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>add：添加单个元素 </li>
<li>remove：删除指定元素 </li>
<li>contains：查找元素是否存在 </li>
<li>size：获取元素个数 </li>
<li>isEmpty：判断是否为空 </li>
<li>clear：清空 </li>
<li>addAll：添加多个元素 </li>
<li>containsAll：查找多个元素是否都存在 </li>
<li>removeAll：删除多个元素</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class SetMethod {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        //老韩解读</span><br><span class="line">        //1. 以Set 接口的实现类 HashSet 来讲解Set 接口的方法</span><br><span class="line">        //2. set 接口的实现类的对象(Set接口对象), 不能存放重复的元素, 可以添加一个null</span><br><span class="line">        //3. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)</span><br><span class="line">        //4. 注意：取出的顺序的顺序虽然不是添加的顺序，但是他的固定.</span><br><span class="line">        Set set = new HashSet();</span><br><span class="line">        set.add("john");</span><br><span class="line">        set.add("lucy");</span><br><span class="line">        set.add("john");//重复</span><br><span class="line">        set.add("jack");</span><br><span class="line">        set.add("hsp");</span><br><span class="line">        set.add("mary");</span><br><span class="line">        set.add(null);//</span><br><span class="line">        set.add(null);//再次添加null</span><br><span class="line">        for(int i = 0; i &lt;10;i ++) {</span><br><span class="line">            System.out.println("set=" + set);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //遍历</span><br><span class="line">        //方式1： 使用迭代器</span><br><span class="line">        System.out.println("=====使用迭代器====");</span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        while (iterator.hasNext()) {</span><br><span class="line">            Object obj =  iterator.next();</span><br><span class="line">            System.out.println("obj=" + obj);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        set.remove(null);</span><br><span class="line"></span><br><span class="line">        //方式2: 增强for</span><br><span class="line">        System.out.println("=====增强for====");</span><br><span class="line"></span><br><span class="line">        for (Object o : set) {</span><br><span class="line">            System.out.println("o=" + o);</span><br><span class="line">        }</span><br><span class="line">        //set 接口对象，不能通过索引来获取</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul>
<li>迭代器</li>
<li>增强for</li>
<li>不能使用索引方式获取（普通遍历循环)</li>
</ul>
<h4 id="HashSet⭐️"><a href="#HashSet⭐️" class="headerlink" title="HashSet⭐️"></a><strong>HashSet⭐️</strong></h4><h5 id="注意事项和细节-40"><a href="#注意事项和细节-40" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li>Hashset 实现了 Set 接口</li>
<li>Hashset 实际上是 HashMap</li>
<li>可以存放 null 值，但是只能有一个 null</li>
<li>Hashset 不保证元素是有序的,取决于 hash 后，再确定索引的结果</li>
<li>不能有重复元素/对象</li>
</ul>
<h5 id="底层机制和源码分析-1"><a href="#底层机制和源码分析-1" class="headerlink" title="底层机制和源码分析"></a>底层机制和源码分析</h5><ul>
<li>HashSet 底层是 HashMap</li>
<li>添加一个元素时，先得到 hash 值会转成索引值 </li>
<li>找到存储数据表 table，看这个素引位置是否己经存放的有元素如果没有，直接加入</li>
<li>如果有调用 equals 比较，如果相同，就放奔添加，如果不相同，则添加到最后 </li>
<li>在 Java8 中，如果一条链表的元素个数超过 TREEIFY THRESHOLD（默认是8），井且 table 的大小＞= MIN TREEIFY CAPACITY（默认64)就会进行树化(红黑树）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../AppData/Roaming/Typora/typora-user-images/image-20221011203044548.png" alt="image-20221011203044548"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class HashSetSource {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        HashSet hashSet = new HashSet();</span><br><span class="line">        hashSet.add("java");//到此位置，第1次add分析完毕.</span><br><span class="line">        hashSet.add("php");//到此位置，第2次add分析完毕</span><br><span class="line">        hashSet.add("java");</span><br><span class="line">        System.out.println("set=" + hashSet);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        HashSet 的源码解读</span><br><span class="line">        1. 执行 HashSet()</span><br><span class="line">            public HashSet() {</span><br><span class="line">                map = new HashMap&lt;&gt;();</span><br><span class="line">            }</span><br><span class="line">        2. 执行 add()</span><br><span class="line">           public boolean add(E e) {//e = "java"</span><br><span class="line">                return map.put(e, PRESENT)==null;//(static) PRESENT = new Object();</span><br><span class="line">           }</span><br><span class="line">         3.执行 put() , 该方法会执行 hash(key) 得到key对应的hash值 算法h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span><br><span class="line">             public V put(K key, V value) {//key = "java" value = PRESENT 共享</span><br><span class="line">                return putVal(hash(key), key, value, false, true);</span><br><span class="line">            }</span><br><span class="line">         4.执行 putVal</span><br><span class="line">         final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) {</span><br><span class="line">                Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //定义了辅助变量</span><br><span class="line">                //table 就是 HashMap 的一个数组，类型是 Node[]</span><br><span class="line">                //if 语句表示如果当前table 是null, 或者 大小=0</span><br><span class="line">                //就是第一次扩容，到16个空间.</span><br><span class="line">                if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">                    n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">                //(1)根据key，得到hash 去计算该key应该存放到table表的哪个索引位置</span><br><span class="line">                //并把这个位置的对象，赋给 p</span><br><span class="line">                //(2)判断p 是否为null</span><br><span class="line">                //(2.1) 如果p 为null, 表示还没有存放元素, 就创建一个Node (key="java",value=PRESENT)</span><br><span class="line">                //(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)</span><br><span class="line"></span><br><span class="line">                if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">                    tab[i] = newNode(hash, key, value, null);</span><br><span class="line">                else {</span><br><span class="line">                    //一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建</span><br><span class="line">                    Node&lt;K,V&gt; e; K k; //</span><br><span class="line">                    //如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样</span><br><span class="line">                    //并且满足 下面两个条件之一:</span><br><span class="line">                    //(1) 准备加入的key 和 p 指向的Node 结点的 key 是同一个对象</span><br><span class="line">                    //(2)  p 指向的Node 结点的 key 的equals() 和准备加入的key比较后相同</span><br><span class="line">                    //就不能加入</span><br><span class="line">                    if (p.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        e = p;</span><br><span class="line">                    //再判断 p 是不是一颗红黑树,</span><br><span class="line">                    //如果是一颗红黑树，就调用 putTreeVal , 来进行添加</span><br><span class="line">                    else if (p instanceof TreeNode)</span><br><span class="line">                        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">                    else {//如果table对应索引位置，已经是一个链表, 就使用for循环比较</span><br><span class="line">                    </span><br><span class="line">                          //(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后</span><br><span class="line">                          //    注意在把元素添加到链表后，立即判断 该链表是否已经达到8个结点</span><br><span class="line">                          //    , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)</span><br><span class="line">                          //    注意，在转成红黑树时，要进行判断, 判断条件</span><br><span class="line">                          //    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))</span><br><span class="line">                          //            resize();</span><br><span class="line">                          //    如果上面条件成立，先table扩容.</span><br><span class="line">                          //    只有上面条件不成立时，才进行转成红黑树</span><br><span class="line">                          //(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接break</span><br><span class="line"></span><br><span class="line">                        for (int binCount = 0; ; ++binCount) {</span><br><span class="line">                            if ((e = p.next) == null) {</span><br><span class="line">                                p.next = newNode(hash, key, value, null);</span><br><span class="line">                                if (binCount &gt;= TREEIFY_THRESHOLD(8) - 1) // -1 for 1st</span><br><span class="line">                                    treeifyBin(tab, hash);</span><br><span class="line">                                break;</span><br><span class="line">                            }</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                                break;</span><br><span class="line">                            p = e;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    if (e != null) { // existing mapping for key</span><br><span class="line">                        V oldValue = e.value;</span><br><span class="line">                        if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                            e.value = value;</span><br><span class="line">                        afterNodeAccess(e);</span><br><span class="line">                        return oldValue;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                ++modCount;</span><br><span class="line">                //size 就是我们每加入一个结点Node(k,v,h,next), size++</span><br><span class="line">                if (++size &gt; threshold)</span><br><span class="line">                    resize();//扩容</span><br><span class="line">                afterNodeInsertion(evict);</span><br><span class="line">                return null;</span><br><span class="line">            }</span><br><span class="line">         */</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="扩容和红黑树机制"><a href="#扩容和红黑树机制" class="headerlink" title="扩容和红黑树机制"></a>扩容和红黑树机制</h4><ul>
<li><p>HashSet 底层 是HashMap</p>
</li>
<li><p>第一次添加时，table 数组扩容到 16，临界值(threshold)是 16*加载因子(loadFactor)是0.75= 12</p>
</li>
<li><p>每加入一个节点，size 就会 ++，到达临界值就会扩容</p>
</li>
<li><p>如果 table 数组使用到了临界值 12,就会扩容到<code>16*2=32</code>,新的临界值就是32*0.75=24，依次类推</p>
</li>
<li><p>在 Java8 中，如果一条链表的元素个数到达 TREEIFY_ THRESHOLD(默认是 8）井且table的大小＞=MIN TREEIFY CAPACITY (默认64),就会进行树化(红黑树），否则仍然采用数组扩容机制</p>
</li>
</ul>
<p>●  </p>
<h4 id="去重机制对比"><a href="#去重机制对比" class="headerlink" title="去重机制对比"></a>去重机制对比</h4><ul>
<li><p>HashSet 去重机制:</p>
<ul>
<li>hashCode() + equals()，底层先通过存入对象，通过运算 hash 值得到对应的索引，如果 table 索引所在的位置没有数据就直接存放；如果有数据就进行 equals（注意重写情况）比较[遍历比较]，如果比较后，不相同就加入，否则就不加入</li>
</ul>
</li>
<li><p>TreeSet 的去重机制</p>
<ul>
<li>如果你传入了一个 Comparator 匿名对象，就使用实现的compare 去重，如果方法返回0,就是相同的元素/数据，就不添加，如果你没有传入一个 Comparator 匿名对象，则以你添加的对象实现的 Compareable 接口的 compareTo 去重</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Homework06 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        HashSet set = new HashSet();//ok</span><br><span class="line">        Person p1 = new Person(1001,"AA");//ok</span><br><span class="line">        Person p2 = new Person(1002,"BB");//ok</span><br><span class="line">        set.add(p1);//ok</span><br><span class="line">        set.add(p2);//ok</span><br><span class="line">        p1.name = "CC";</span><br><span class="line">        set.remove(p1);</span><br><span class="line">        System.out.println(set);//2</span><br><span class="line">        set.add(new Person(1001,"CC"));</span><br><span class="line">        System.out.println(set);//3</span><br><span class="line">        set.add(new Person(1001,"AA"));</span><br><span class="line">        System.out.println(set);//4</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Person {</span><br><span class="line">    public String name;</span><br><span class="line">    public int id;</span><br><span class="line"></span><br><span class="line">    public Person(int id, String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) {</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        return id == person.id &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() {</span><br><span class="line">        return Objects.hash(name, id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() {</span><br><span class="line">        return "Person{" +</span><br><span class="line">                "name='" + name + '\'' +</span><br><span class="line">                ", id=" + id +</span><br><span class="line">                '}';</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../AppData/Roaming/Typora/typora-user-images/image-20221011203401416.png" alt="image-20221011203401416"></p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><h5 id="注意事项和细节-41"><a href="#注意事项和细节-41" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ul>
<li><p>LinkedHashset 是 Hashset 的子类 </p>
</li>
<li><p>LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个 数组＋双向链表 </p>
</li>
<li><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序(图)，这使得元素看起来是以插入顺序保存的 </p>
</li>
<li><p>LinkedHashSet 不允许添重复元素</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../AppData/Roaming/Typora/typora-user-images/image-20221011203532680.png" alt="image-20221011203532680"></p>
<h5 id="底层机制和源代码分析"><a href="#底层机制和源代码分析" class="headerlink" title="底层机制和源代码分析"></a>底层机制和源代码分析</h5><ul>
<li><p>LinkedHashSet 加入顺序和取出元素/数据的顺序一致</p>
</li>
<li><p>LinkedHashSet 底层维护的是一个 LinkedHashMap (是HashMap的子类)</p>
</li>
<li><p>LinkedHashSet 底层结构 (数组table+双向链表)</p>
</li>
<li><p>添加第一次时，直接将 数组 table 扩容到 16 ,存放的结点类型是 LinkedHashMap$Entry</p>
</li>
<li><p>数组是 HashMap </p>
<ul>
<li><code>Node[]</code>存放的元素/数据是 LinkedHashMap Entry 类型</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashSetSource {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        //分析一下LinkedHashSet的底层机制</span><br><span class="line">        Set set = new LinkedHashSet();</span><br><span class="line">        set.add(new String("AA"));</span><br><span class="line">        set.add(456);</span><br><span class="line">        set.add(456);</span><br><span class="line">        set.add(new Customer("刘", 1001));</span><br><span class="line">        set.add(123);</span><br><span class="line">        set.add("HSP");</span><br><span class="line"></span><br><span class="line">        System.out.println("set=" + set);</span><br><span class="line">        </span><br><span class="line">        //1. LinkedHashSet 加入顺序和取出元素/数据的顺序一致</span><br><span class="line">        //2. LinkedHashSet 底层维护的是一个LinkedHashMap(是HashMap的子类)</span><br><span class="line">        //3. LinkedHashSet 底层结构 (数组table+双向链表)</span><br><span class="line">        //4. 添加第一次时，直接将 数组table 扩容到 16 ,存放的结点类型是 LinkedHashMap$Entry</span><br><span class="line">        //5. 数组是 HashMap$Node[] 存放的元素/数据是 LinkedHashMap$Entry类型</span><br><span class="line">        /*</span><br><span class="line">                //继承关系是在内部类完成.</span><br><span class="line">                static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {</span><br><span class="line">                    Entry&lt;K,V&gt; before, after;</span><br><span class="line">                    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {</span><br><span class="line">                        super(hash, key, value, next);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">         */</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">class Customer {</span><br><span class="line">    private String name;</span><br><span class="line">    private int no;</span><br><span class="line"></span><br><span class="line">    public Customer(String name, int no) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.no = no;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><h4 id="底层机制-1"><a href="#底层机制-1" class="headerlink" title="底层机制"></a>底层机制</h4><ul>
<li><p>TreeSet() 构造器需传入 Comparator 接口的匿名内部类，因为底层 Comparable&lt;? super K&gt; k = (Comparator&lt;? super K&gt;) key; 若没有传入，则需要把传入的类实现Comparable 接口 </p>
</li>
<li><p>若按照 compare 方法比较 value 相同则无法加入 value</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class TreeSet_ {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        //1. 当我们使用无参构造器，创建TreeSet时，默认按字母排序</span><br><span class="line">        //2. 老师希望添加的元素，按照字符串大小来排序</span><br><span class="line">        //3. 使用TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)</span><br><span class="line">        //   并指定排序规则</span><br><span class="line">        //4. 简单看看源码</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">        1. 构造器把传入的比较器对象，赋给了 TreeSet的底层的 TreeMap的属性this.comparator</span><br><span class="line"></span><br><span class="line">         public TreeMap(Comparator&lt;? super K&gt; comparator) {</span><br><span class="line">                this.comparator = comparator;</span><br><span class="line">            }</span><br><span class="line">         2. 在 调用 treeSet.add("tom"), 在底层会执行到</span><br><span class="line"></span><br><span class="line">             if (cpr != null) {//cpr 就是我们的匿名内部类(对象)</span><br><span class="line">                do {</span><br><span class="line">                    parent = t;</span><br><span class="line">                    //动态绑定到我们的匿名内部类(对象)compare</span><br><span class="line">                    cmp = cpr.compare(key, t.key);</span><br><span class="line">                    if (cmp &lt; 0)</span><br><span class="line">                        t = t.left;</span><br><span class="line">                    else if (cmp &gt; 0)</span><br><span class="line">                        t = t.right;</span><br><span class="line">                    else //如果相等，即返回0,这个Key就没有加入</span><br><span class="line">                        return t.setValue(value);</span><br><span class="line">                } while (t != null);</span><br><span class="line">            }</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">//        TreeSet treeSet = new TreeSet();</span><br><span class="line">        TreeSet treeSet = new TreeSet(new Comparator() {</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Object o1, Object o2) {</span><br><span class="line">                //下面 调用String的 compareTo方法进行字符串大小比较</span><br><span class="line">                //如果老韩要求加入的元素，按照长度大小排序</span><br><span class="line">                //return ((String) o2).compareTo((String) o1);</span><br><span class="line">                return ((String) o1).length() - ((String) o2).length();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        //添加数据.</span><br><span class="line">        treeSet.add("jack");</span><br><span class="line">        treeSet.add("tom");//3</span><br><span class="line">        treeSet.add("sp");</span><br><span class="line">        treeSet.add("a");</span><br><span class="line">        treeSet.add("abc");//3</span><br><span class="line">        </span><br><span class="line">        System.out.println("treeSet=" + treeSet);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">新野</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/11/JavaSE/">http://example.com/2022/10/11/JavaSE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Nature</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808863.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/09/25/DTD/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808853.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">DTD</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/25/Servlet/" title="Servlet"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808864.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Servlet</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/xinyemoon/Image@v1.0.4/Blog/202209202244761.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">新野</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">急也没用</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaSE"><span class="toc-number">1.</span> <span class="toc-text">JavaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">导论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E6%9F%B1%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.1.</span> <span class="toc-text">标柱注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">学习方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">java概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.2.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E2%AD%90%EF%B8%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">代码规范⭐️</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-JRE%E2%AD%90%EF%B8%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">JDK  JRE⭐️</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%AD%90%EF%B8%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">数据类型⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">引用数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">基本数据类型转化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">自动类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C-String-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.4.</span> <span class="toc-text">基本数据类型和 String 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC-String-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">基本类型转 String 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">String 类型转基本数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.1.</span> <span class="toc-text">算数运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B7%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">+号使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B7%E4%BD%BF%E7%94%A8-1"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">++号使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B7%E4%BD%BF%E7%94%A8-2"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">%号使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.2.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#amp-amp-%E5%92%8C-amp-%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">&amp;&amp;和&amp;基本规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C-%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">||和|基本规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">^逻辑异或</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.4.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.5.</span> <span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.4.6.</span> <span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83"><span class="toc-number">1.4.7.</span> <span class="toc-text">标识符的命名规则和规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E8%8C%83"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">1.4.8.</span> <span class="toc-text">关键字、保留字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="toc-number">1.4.9.</span> <span class="toc-text">键盘输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E2%AD%90%EF%B8%8F"><span class="toc-number">1.4.10.</span> <span class="toc-text">进制⭐️</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.4.11.</span> <span class="toc-text">原码 反码 补码⭐️⭐️</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E2%AD%90%EF%B8%8F"><span class="toc-number">1.4.12.</span> <span class="toc-text">位运算符⭐️</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">顺序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6-if-else-switch"><span class="toc-number">1.5.2.</span> <span class="toc-text">分支控制(if  else  switch)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%88%86%E6%94%AF"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">单分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%88%86%E6%94%AF"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">双分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E6%94%AF"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">多分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%88%86%E6%94%AF"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">嵌套分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">switch分支结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6-for-while-do-while-%E2%AD%90%EF%B8%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">循环控制(for  while  do while)⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">for循环控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">while循环控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do-while%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">do while循环控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">多重循环控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6break"><span class="toc-number">1.5.4.</span> <span class="toc-text">跳转控制break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6continue"><span class="toc-number">1.5.5.</span> <span class="toc-text">跳转控制continue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6return"><span class="toc-number">1.5.6.</span> <span class="toc-text">跳转控制return</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">1.6.</span> <span class="toc-text">数组、排序、查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E2%AD%90%EF%B8%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">数组⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">概念解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">相关名词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">数组定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">数组初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.1.4.1.</span> <span class="toc-text">动态初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.1.4.2.</span> <span class="toc-text">静态初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">数组的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-1"><span class="toc-number">1.6.1.6.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.1.7.</span> <span class="toc-text">数组赋值机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.6.1.8.</span> <span class="toc-text">数组拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.6.1.9.</span> <span class="toc-text">数组反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0"><span class="toc-number">1.6.1.10.</span> <span class="toc-text">数组添加</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%B7%BB%E5%8A%A0"><span class="toc-number">1.6.1.10.1.</span> <span class="toc-text">静态添加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0"><span class="toc-number">1.6.1.10.2.</span> <span class="toc-text">动态添加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%A0%E5%87%8F"><span class="toc-number">1.6.1.10.3.</span> <span class="toc-text">动态删减</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">二维数组遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">二维数组内存图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-2"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.6.2.5.1.</span> <span class="toc-text">动态初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%962"><span class="toc-number">1.6.2.5.2.</span> <span class="toc-text">动态初始化2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%88%97%E6%95%B0%E4%B8%8D%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.6.2.5.3.</span> <span class="toc-text">动态初始化-列数不确定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.6.2.5.4.</span> <span class="toc-text">静态初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.6.3.</span> <span class="toc-text">排序(基础)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">排序分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.6.4.</span> <span class="toc-text">查找(基础)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">二分查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.7.</span> <span class="toc-text">面向对象(基础)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%9C%A8%E5%BD%A2%E5%BC%8F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">对象存在形式⭐️</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-x2F-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">属性/成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.7.1.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-3"><span class="toc-number">1.7.1.3.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">如何创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.7.1.4.1.</span> <span class="toc-text">对象创建流程分析⭐️⭐️</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">对象分配机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">Java内存结构分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.1.7.</span> <span class="toc-text">Java创建对象流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E2%AD%90%EF%B8%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">成员方法⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">方法定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">调用的内存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-4"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">注意事项和细节</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.7.2.4.1.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.2.4.2.</span> <span class="toc-text">返回类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">1.7.2.4.3.</span> <span class="toc-text">方法名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">1.7.2.4.4.</span> <span class="toc-text">参数列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BD%93"><span class="toc-number">1.7.2.4.5.</span> <span class="toc-text">方法体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">1.7.2.4.6.</span> <span class="toc-text">方法调用细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E4%BC%A0%E6%B3%95%E5%8F%82%E6%9C%BA%E5%88%B6%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">成员方传法参机制⭐️⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82%E6%95%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">基本数据类型的传参数机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82%E6%95%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">引用数据类型的传参数机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">1.7.4.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">递归调用内存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-5"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD-overload"><span class="toc-number">1.7.5.</span> <span class="toc-text">方法重载 (overload)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-6"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.6.</span> <span class="toc-text">可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-7"><span class="toc-number">1.7.6.3.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.7.7.</span> <span class="toc-text">变量作用域⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.7.1.</span> <span class="toc-text">全局变量和局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-8"><span class="toc-number">1.7.7.2.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.7.3.</span> <span class="toc-text">两种调用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E2%AD%90%EF%B8%8F"><span class="toc-number">1.7.8.</span> <span class="toc-text">构造器⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">1.7.8.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">1.7.8.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-9"><span class="toc-number">1.7.8.3.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">1.7.9.</span> <span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">1.7.9.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">1.7.9.2.</span> <span class="toc-text">内存分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-10"><span class="toc-number">1.7.9.3.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD%E7%BA%A7"><span class="toc-number">1.8.</span> <span class="toc-text">面向对象(中级)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IDEA"><span class="toc-number">1.8.1.</span> <span class="toc-text">IDEA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.8.2.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">包的命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%8C%85"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">引入包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-11"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-1"><span class="toc-number">1.8.3.</span> <span class="toc-text">访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">访问权限⭐️⭐️</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-12"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E2%AD%90%EF%B8%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">封装⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">封装步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E2%AD%90%EF%B8%8F"><span class="toc-number">1.8.5.</span> <span class="toc-text">继承⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-10"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-13"><span class="toc-number">1.8.5.3.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.8.5.4.</span> <span class="toc-text">继承本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.8.5.5.</span> <span class="toc-text">继承内存图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.8.6.</span> <span class="toc-text">多态⭐️⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-11"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%85%B7%E4%BD%93%E4%BD%93%E7%8E%B0"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">多态具体体现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">1.8.6.2.1.</span> <span class="toc-text">方法的多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">1.8.6.2.2.</span> <span class="toc-text">对象的多态</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-14"><span class="toc-number">1.8.6.2.2.1.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.8.6.2.2.2.</span> <span class="toc-text">向上转型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.8.6.2.2.3.</span> <span class="toc-text">向下转型</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.6.2.3.</span> <span class="toc-text">属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.8.6.3.</span> <span class="toc-text">动态绑定机制⭐️⭐️</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.6.4.</span> <span class="toc-text">多态的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.6.4.1.</span> <span class="toc-text">多态数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Super"><span class="toc-number">1.8.7.</span> <span class="toc-text">Super</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-12"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="toc-number">1.8.7.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-15"><span class="toc-number">1.8.7.3.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%92%8Cthis"><span class="toc-number">1.8.7.4.</span> <span class="toc-text">super和this</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-overwrite"><span class="toc-number">1.8.8.</span> <span class="toc-text">方法重写(overwrite)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-13"><span class="toc-number">1.8.8.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-16"><span class="toc-number">1.8.8.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">1.8.9.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D"><span class="toc-number">1.8.9.1.</span> <span class="toc-text">==</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals"><span class="toc-number">1.8.9.2.</span> <span class="toc-text">equals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode"><span class="toc-number">1.8.9.3.</span> <span class="toc-text">hashCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-NaN"><span class="toc-number">1.8.9.4.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finalize"><span class="toc-number">1.8.9.5.</span> <span class="toc-text">finalize</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><span class="toc-number">1.8.10.</span> <span class="toc-text">断点调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-14"><span class="toc-number">1.8.10.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-17"><span class="toc-number">1.8.10.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7"><span class="toc-number">1.9.</span> <span class="toc-text">面向对象(高级)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95%E2%AD%90%EF%B8%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text">类变量和类方法⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">类变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-15"><span class="toc-number">1.9.1.1.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-5"><span class="toc-number">1.9.1.1.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.1.1.3.</span> <span class="toc-text">如何访问类变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.9.1.1.4.</span> <span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-18"><span class="toc-number">1.9.1.1.5.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-16"><span class="toc-number">1.9.1.2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-6"><span class="toc-number">1.9.1.2.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">1.9.1.2.3.</span> <span class="toc-text">类方法调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.9.1.2.4.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-19"><span class="toc-number">1.9.1.2.5.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.2.</span> <span class="toc-text">main方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">深入理解main方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-20"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.9.3.</span> <span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-17"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-7"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-1"><span class="toc-number">1.9.3.2.1.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-21"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.9.4.</span> <span class="toc-text">单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-18"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">1.9.4.4.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.9.5.</span> <span class="toc-text">final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-19"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-22"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.9.6.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-20"><span class="toc-number">1.9.6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-23"><span class="toc-number">1.9.6.2.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%A8%A1%E7%89%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.9.6.3.</span> <span class="toc-text">抽象类模版设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E2%AD%90%EF%B8%8F"><span class="toc-number">1.9.7.</span> <span class="toc-text">接口⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-21"><span class="toc-number">1.9.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-8"><span class="toc-number">1.9.7.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-24"><span class="toc-number">1.9.7.3.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3VS%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-number">1.9.7.4.</span> <span class="toc-text">实现接口VS继承类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.7.5.</span> <span class="toc-text">接口类型数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E2%AD%90%EF%B8%8F"><span class="toc-number">1.9.8.</span> <span class="toc-text">内部类⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-22"><span class="toc-number">1.9.8.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-9"><span class="toc-number">1.9.8.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%86%E7%B1%BB"><span class="toc-number">1.9.8.3.</span> <span class="toc-text">内部类分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.9.8.4.</span> <span class="toc-text">局部内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-23"><span class="toc-number">1.9.8.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-25"><span class="toc-number">1.9.8.4.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.9.8.5.</span> <span class="toc-text">匿名内部类⭐️⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-24"><span class="toc-number">1.9.8.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-10"><span class="toc-number">1.9.8.5.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82"><span class="toc-number">1.9.8.5.3.</span> <span class="toc-text">底层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-26"><span class="toc-number">1.9.8.5.4.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.9.8.6.</span> <span class="toc-text">成员内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-25"><span class="toc-number">1.9.8.6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-27"><span class="toc-number">1.9.8.6.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.9.8.7.</span> <span class="toc-text">静态内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-26"><span class="toc-number">1.9.8.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-28"><span class="toc-number">1.9.8.7.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="toc-number">1.9.9.</span> <span class="toc-text">类加载顺序⭐️⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.9.9.1.</span> <span class="toc-text">类什么时候被加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.9.9.2.</span> <span class="toc-text">创建一个对象时，在一个类的调用顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E6%97%B6%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.9.9.3.</span> <span class="toc-text">创建子类时顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.</span> <span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.10.1.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-27"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">基本介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.10.2.</span> <span class="toc-text">定义类实现枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-29"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.10.3.</span> <span class="toc-text">enum关键字实现枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-30"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.10.3.4.</span> <span class="toc-text">实现接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDk%E5%86%85%E7%BD%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.4.</span> <span class="toc-text">JDk内置的基本注解类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-28"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%ACAnnotation%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">基本Annotation介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Override"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">Override</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.10.4.3.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deprecated"><span class="toc-number">1.10.4.4.</span> <span class="toc-text">@Deprecated</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-1"><span class="toc-number">1.10.4.4.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SuppressWarnings"><span class="toc-number">1.10.4.5.</span> <span class="toc-text">@SuppressWarnings</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%9A%E5%AF%B9%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.5.</span> <span class="toc-text">元注解：对注解进行注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-29"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.5.2.</span> <span class="toc-text">四种元注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.11.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-30"><span class="toc-number">1.11.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%AD%E5%BC%82%E5%B8%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB"><span class="toc-number">1.11.2.</span> <span class="toc-text">执行中异常事件分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE%E2%AD%90%EF%B8%8F"><span class="toc-number">1.11.3.</span> <span class="toc-text">异常体系图⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-31"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.11.4.</span> <span class="toc-text">常见的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">运行时异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">编译时异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E2%AD%90%EF%B8%8F"><span class="toc-number">1.11.5.</span> <span class="toc-text">异常处理⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-31"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">try-catch-finally</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.11.5.2.1.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-32"><span class="toc-number">1.11.5.2.2.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throws"><span class="toc-number">1.11.5.3.</span> <span class="toc-text">throws</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-32"><span class="toc-number">1.11.5.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE-1"><span class="toc-number">1.11.5.3.2.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-33"><span class="toc-number">1.11.5.3.3.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.11.6.</span> <span class="toc-text">自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-33"><span class="toc-number">1.11.6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.11.6.2.</span> <span class="toc-text">自定义异常步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E5%92%8Cthrows"><span class="toc-number">1.11.7.</span> <span class="toc-text">throw和throws</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-1"><span class="toc-number">1.11.7.1.</span> <span class="toc-text">对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">1.12.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.12.1.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-34"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">装箱和拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">包装类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Integer%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">1.12.1.4.</span> <span class="toc-text">Integer创建机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E2%AD%90%EF%B8%8F"><span class="toc-number">1.12.2.</span> <span class="toc-text">String⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-35"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAString%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">创建String对象方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.12.2.2.1.</span> <span class="toc-text">两种方式对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.12.2.3.</span> <span class="toc-text">常用构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-34"><span class="toc-number">1.12.2.4.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">1.12.2.5.</span> <span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E7%89%B9%E6%80%A7"><span class="toc-number">1.12.2.5.1.</span> <span class="toc-text">相等特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%B9%E6%80%A7"><span class="toc-number">1.12.2.5.2.</span> <span class="toc-text">字符串特性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.12.2.6.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer%E2%AD%90%EF%B8%8F"><span class="toc-number">1.12.3.</span> <span class="toc-text">StringBuffer⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-36"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-35"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E5%92%8CStringBuffer%E5%AF%B9%E6%AF%94"><span class="toc-number">1.12.3.3.</span> <span class="toc-text">String和StringBuffer对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.12.3.4.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E5%92%8CStringBuffer%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.12.3.5.</span> <span class="toc-text">String和StringBuffer转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.12.3.6.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBulider%E2%AD%90%EF%B8%8F"><span class="toc-number">1.12.3.7.</span> <span class="toc-text">StringBulider⭐️</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-37"><span class="toc-number">1.12.3.8.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-36"><span class="toc-number">1.12.3.9.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.12.3.10.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%B1%BB%E5%AF%B9%E6%AF%94"><span class="toc-number">1.12.3.11.</span> <span class="toc-text">三类对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%B1%BB%E9%80%89%E6%8B%A9"><span class="toc-number">1.12.3.12.</span> <span class="toc-text">三类选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">1.12.4.</span> <span class="toc-text">Math</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-38"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-4"><span class="toc-number">1.12.4.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date%E3%80%81Calenda%E3%80%81LocalDate"><span class="toc-number">1.12.5.</span> <span class="toc-text">Date、Calenda、LocalDate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Date"><span class="toc-number">1.12.5.1.</span> <span class="toc-text">Date</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-5"><span class="toc-number">1.12.5.1.1.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calenda"><span class="toc-number">1.12.5.2.</span> <span class="toc-text">Calenda</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-39"><span class="toc-number">1.12.5.2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-6"><span class="toc-number">1.12.5.2.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDate"><span class="toc-number">1.12.5.3.</span> <span class="toc-text">LocalDate</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-7"><span class="toc-number">1.12.5.3.1.</span> <span class="toc-text">常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System"><span class="toc-number">1.12.6.</span> <span class="toc-text">System</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-8"><span class="toc-number">1.12.6.1.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays"><span class="toc-number">1.12.7.</span> <span class="toc-text">Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-40"><span class="toc-number">1.12.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-9"><span class="toc-number">1.12.7.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInteger-BigDecimal"><span class="toc-number">1.12.8.</span> <span class="toc-text">BigInteger BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-41"><span class="toc-number">1.12.8.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-10"><span class="toc-number">1.12.8.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.13.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-42"><span class="toc-number">1.13.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E2%AD%90%EF%B8%8F"><span class="toc-number">1.13.2.</span> <span class="toc-text">集合框架体系⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%9B%BE"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">框架图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection"><span class="toc-number">1.13.3.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-43"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.13.3.2.</span> <span class="toc-text">接口常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">1.13.4.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-44"><span class="toc-number">1.13.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-11"><span class="toc-number">1.13.4.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.13.4.3.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-45"><span class="toc-number">1.13.4.3.1.</span> <span class="toc-text">基本介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%A2%9E%E5%BC%BA%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.13.4.4.</span> <span class="toc-text">for增强循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-46"><span class="toc-number">1.13.4.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-11"><span class="toc-number">1.13.4.4.2.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">1.13.4.5.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-37"><span class="toc-number">1.13.4.5.1.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.13.4.5.2.</span> <span class="toc-text">底层结构和源码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector%E2%AD%90%EF%B8%8F"><span class="toc-number">1.13.4.6.</span> <span class="toc-text">Vector⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-38"><span class="toc-number">1.13.4.6.1.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.13.4.6.2.</span> <span class="toc-text">底层机制和源码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%92%8CVector"><span class="toc-number">1.13.4.7.</span> <span class="toc-text">ArrayList和Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList"><span class="toc-number">1.13.4.8.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-39"><span class="toc-number">1.13.4.8.1.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">1.13.4.8.2.</span> <span class="toc-text">底层机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList"><span class="toc-number">1.13.4.9.</span> <span class="toc-text">ArrayList和LinkedList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">1.13.5.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-47"><span class="toc-number">1.13.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-12"><span class="toc-number">1.13.5.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.13.5.3.</span> <span class="toc-text">遍历方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet%E2%AD%90%EF%B8%8F"><span class="toc-number">1.13.5.4.</span> <span class="toc-text">HashSet⭐️</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-40"><span class="toc-number">1.13.5.4.1.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">1.13.5.4.2.</span> <span class="toc-text">底层机制和源码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9C%BA%E5%88%B6"><span class="toc-number">1.13.5.5.</span> <span class="toc-text">扩容和红黑树机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">1.13.5.6.</span> <span class="toc-text">去重机制对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">1.13.5.7.</span> <span class="toc-text">LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-41"><span class="toc-number">1.13.5.7.1.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.13.5.7.2.</span> <span class="toc-text">底层机制和源代码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-number">1.13.5.8.</span> <span class="toc-text">TreeSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6-1"><span class="toc-number">1.13.5.9.</span> <span class="toc-text">底层机制</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/11/JavaSE/" title="JavaSE"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808863.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaSE"></a><div class="content"><a class="title" href="/2022/10/11/JavaSE/" title="JavaSE">JavaSE</a><time datetime="2022-10-11T12:41:28.161Z" title="发表于 2022-10-11 20:41:28">2022-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/25/DTD/" title="DTD"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808853.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DTD"></a><div class="content"><a class="title" href="/2022/09/25/DTD/" title="DTD">DTD</a><time datetime="2022-09-25T04:17:48.000Z" title="发表于 2022-09-25 12:17:48">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/25/Servlet/" title="Servlet"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808864.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Servlet"></a><div class="content"><a class="title" href="/2022/09/25/Servlet/" title="Servlet">Servlet</a><time datetime="2022-09-25T04:15:55.000Z" title="发表于 2022-09-25 12:15:55">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/22/XML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="XML学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209221808862.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XML学习笔记"></a><div class="content"><a class="title" href="/2022/09/22/XML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="XML学习笔记">XML学习笔记</a><time datetime="2022-09-22T10:13:30.000Z" title="发表于 2022-09-22 18:13:30">2022-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/13/Junit%E7%AC%94%E8%AE%B0-%E4%B8%80/" title="Junit笔记(一)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/xinyemoon/Image/Article/202209202248518.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Junit笔记(一)"></a><div class="content"><a class="title" href="/2022/09/13/Junit%E7%AC%94%E8%AE%B0-%E4%B8%80/" title="Junit笔记(一)">Junit笔记(一)</a><time datetime="2022-09-13T14:54:00.000Z" title="发表于 2022-09-13 22:54:00">2022-09-13</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2022 By 新野</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-sigma-one.vercel.app/',
      region: 'ap-shanghai',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-sigma-one.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="66641056" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-listfolded="true" data-lrctype="0"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax="">
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax="" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>